"use strict";(self.webpackChunkkcl_website=self.webpackChunkkcl_website||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"2024-03-20-newsletter","metadata":{"permalink":"/blog/2024-03-20-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-03-20-newsletter/index.md","source":"@site/blog/2024-03-20-newsletter/index.md","title":"KCL Newsletter (2024 03.06 - 2024.03.20)","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations and polices, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2024-03-20T00:00:00.000Z","formattedDate":"March 20, 2024","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Newsletter","permalink":"/blog/tags/newsletter"}],"readingTime":3.04,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-03-20-newsletter","title":"KCL Newsletter (2024 03.06 - 2024.03.20)","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Newsletter"],"image":"/img/biweekly-newsletter.png"},"nextItem":{"title":"KCL v0.8.0 Release Blog","permalink":"/blog/2024-03-06-kcl-0.8.0-release"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations and polices, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest news, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThanks to to all contributors for their outstanding work over the past twenty days (2024 03.06 - 2024 03.20). Here is an overview of the key content:\\n\\n**\ud83d\udce6 Module Updates**\\n\\n- Added new kubeadm configuration module.\\n- Updated Knative Operator module to align with upstream Knative CRD definitions.\\n\\n**\ud83c\udfc4 Language Updates**\\n\\n**KCL has released v0.8.1 and v0.8.2**, mainly including the following updates:\\n\\n- Enhanced error messages for simplified experience when binary expression types do not match.\\n- Fixed abnormal error of high-order lambda functions capturing local scope closure variables.\\n- Removed inequality comparison operations for uncommon list data types.\\n\\n**\ud83d\udd27 Toolchain Updates**\\n\\n- Fixed an issue in the kcl import tool where input Kubernetes CRDs with the regex property conflicted with the KCL regex system library.\\n- Fixed a syntax error in the KCL file output when the input Kubernetes CRD properties had complex default values in the kcl import tool.\\n- Added support for setting the version of a newly created KCL module with the `--version` flag in the kcl mod init command.\\n- Commands such as kcl run, kcl mod add, and kcl mod pull now support accessing private Git repositories.\\n- Fixed a path error encountered when running the kcl run command on a local OCI Registry on Windows.\\n\\n**\ud83d\udd25 SDK Updates**\\n\\n- The KCL Rust, Go, and Java SDKs have released version 0.8, primarily synchronizing with KCL syntax and semantic updates.\\n- The KCL Python SDK has released versions 0.8.0.2 and 0.7.6, addressing the issue of outdated dependencies for `protobuf` and `pyyaml`.\\n\\n**\ud83d\udcbb IDE Updates**\\n\\n- Support for multiple quick fix repair options.\\n\\n![multiple-quick-fix](/img/blog/2024-03-20-newsletter/multiple-quick-fix.png)\\n\\n**\ud83c\udf81 API Updates**\\n\\n- Added `ListOptions` API, which can read all `option` function call information in KCL projects.\\n\\n**\ud83d\udea2 Integration Updates**\\n\\n- Crossplane KCL Function has released version 0.3.2, supporting access to non-HTTPS protocol OCI Registries and local debugging.\\n\\n**\ud83c\udf10 Website Updates**\\n\\n+ Enabled the `kcl-lang.dev` domain, allowing access to the KCL website through both `kcl-lang.io` and `kcl-lang.dev`.\\n+ Optimized website loading speed for an improved documentation experience on the KCL website.\\n\\n## Special Thanks\\n\\nThank you to all the community contributors over the past two weeks, listed in no particular order:\\n\\n- Thank you to @bozaro for the contribution to the KCL Go SDK with the Go language plugin API. \ud83d\ude4c\\n- Thank you to @shashank-iitbhu for enhancing the quick fix feature in the KCL IDE, adding support for multiple fix options. \ud83d\ude4c\\n- Thank you to @octonawish-akcodes for the ongoing contribution to the KCL IDE, automatically monitoring kcl.mod dependencies and updating them. \ud83d\ude4c\\n- Thank you to @liangyuanpeng for fixing the CLA Bot CI automatic PR locking, contributing to the kubeadm model, and supporting the version setting feature in `kcl mod init`. \ud83d\ude4c\\n- Thank you to @Stefano Borrelli, @sfshumaker, @eshepelyuk, @vtomilov, @ricochet1k, @yjsnly, @markphillips100, @userxiaosi, @wilsonwang371, @steeling, @bozaro, @nizq, @reckless-huang, @folliehiyuki, @samuel-deal-tisseo, @MrGuoRanDuo, and @MattHodge for providing valuable suggestions and feedback while using KCL recently. \ud83d\ude4c\\n\\n## Resources\\n\\n\u2764\ufe0f See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.9.0 Milestone](https://github.com/kcl-lang/kcl/milestone/9)"},{"id":"2024-03-06-kcl-0.8.0-release","metadata":{"permalink":"/blog/2024-03-06-kcl-0.8.0-release","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-03-06-kcl-0.8.0-release/index.md","source":"@site/blog/2024-03-06-kcl-0.8.0-release/index.md","title":"KCL v0.8.0 Release Blog","description":"Introduction","date":"2024-03-06T00:00:00.000Z","formattedDate":"March 6, 2024","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":13.385,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-03-06-kcl-0.8.0-release","title":"KCL v0.8.0 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Newsletter (2024 03.06 - 2024.03.20)","permalink":"/blog/2024-03-20-newsletter"},"nextItem":{"title":"Empowering Cloud-Native Platforms: The Synergy of KCL and Crossplane","permalink":"/blog/2024-03-04-crossplane-marketplace-kcl"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.8.0 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n- _Use KCL language, tools and IDE extensions with more complete features and fewer errors to improve code writing experience and efficiency._\\n\\n- _More comprehensive and rich community ecosystem integration, improving operation and maintenance experience._\\n\\n- _More comprehensive KCL third-party dependencies, easier integration with cloud-native ecosystem._\\n\\nKCL v0.8.0 is now available for download at [KCL v0.8.0 Release Page](https://github.com/kcl-lang/kcl/releases/tag/v0.8.0) or [KCL Official Website](https://kcl-lang.io).\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF). KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.8.0 and recent developments in the KCL community to readers.\\n\\n## Language Updates\\n\\n### \ud83d\ude97 Grammar and Semantics Updates\\n\\n#### KCL supports `show-hidden`\\n\\nKCL v0.8.0 adds support for `--show-hidden` to display private variables.\\n\\nThe `main.k`\\n\\n```kcl\\na = {_b = 1}\\n```\\n\\nCompile by `kcl run main.k --show-hidden`.\\n\\n```yaml\\na:\\n  _b: 1\\n```\\n\\n#### KCL supports arguments and keyword arguments union\\n\\nKCL v0.8.0 adds support for arguments and keyword arguments union. Schema instances with arguments will union arguments during union operations.\\n\\n```kcl\\nschema Person[separator]:\\n    firstName: str = \\"John\\"\\n    lastName: str\\n    fullName: str = firstName + separator + lastName\\n\\nx = Person(\\" \\") {lastName = \\"Doe\\"}\\n\\ny = Person(\\"-\\") {lastName = \\"Doe1\\"}\\n\\nz = x | y\\n```\\n\\nThe compiled result is as follows:\\n\\n```yaml\\nx:\\n  firstName: John\\n  lastName: Doe\\n  fullName: John Doe\\ny:\\n  firstName: John\\n  lastName: Doe1\\n  fullName: John-Doe1\\nz:\\n  firstName: John\\n  lastName: Doe1\\n  fullName: John-Doe1\\n```\\n\\n#### KCL supports scalar yaml stream output\\n\\nIn v0.8.0, by using `yaml_stream` method, you can output the result of yaml scalar.\\n\\n```kcl\\nimport manifests\\n\\nx0 = 1\\nx1 = 2\\nmanifests.yaml_stream([x0, x1])\\n```\\n\\nThe compiled result is as follows:\\n\\n```yaml\\n1\\n---\\n2\\n```\\n\\n#### KCL removes the `__settings__` attribute in the compiled output\\n\\nIn v0.8.0, the `__settings__` attribute is removed from the compiled output.\\n\\n```kcl\\nschema Person:\\n    __settings__: {str:str} = {\\"output_type\\": \\"STANDALONE\\"}\\n    name?: str\\n    age?: int\\n    school?: str\\n\\na = Person{\\n    name: \\"a\\",\\n}\\n```\\n\\nThe compiled result is as follows.\\n\\n```yaml\\na:\\n  name: a\\n```\\n\\n#### KCL supports the key and value evaluation in the config expression\\n\\nIn v0.8.0, KCL supports the key and value evaluation in the config expression.\\n\\n```kcl\\n_data = {\\n    \\"a\\": \'foo\'\\n    \\"b\\": \'bar\'\\n}\\n\\nr0 = [{v = k} for k, v in _data]\\nr1 = [{k = v} for k, v in _data]\\nr2 = [{k.foo = v} for k, v in _data]\\nr3 = [[k] for k, v in _data]\\nr4 = [[k, v] for k, v in _data]\\n```\\n\\nThe compiled result is as follows.\\n\\n```yaml\\nr0:\\n  - foo: a\\n  - bar: b\\nr1:\\n  - a: foo\\n  - b: bar\\nr2:\\n  - a:\\n      foo: foo\\n  - b:\\n      foo: bar\\nr3:\\n  - - a\\n  - - b\\nr4:\\n  - - a\\n    - foo\\n  - - b\\n    - bar\\n```\\n\\n### \ud83d\ude80 Diagnostic Optimization\\n\\nKCL uses the `elif` keyword in the `if` block, not `else if`.\\n\\nCompile the following KCL program:\\n\\n```kcl\\nif True: a = 1\\nelse if False: b = 1\\n```\\n\\nThe diagnostic information in KCL has added suggestions for error correction:\\n\\n```shell\\nerror[E1001]: InvalidSyntax\\n --\x3e main.k:2:6\\n  |\\n2 | else if False: b = 1\\n  |      ^ \'else if\' here is invalid in KCL, consider using the \'elif\' keyword\\n  |\\n```\\n\\n### \ud83d\ude80 Language writing experience optimization\\n\\n#### KCL standard library adds file system access functions\\n\\nKCL has added methods to access the file system. In v0.8.0, it supports methods such as `read`, `glob`, etc. to access the file system.\\n\\nBy using the `read`, you can read the contents of a file as a string.\\n\\n```kcl\\nimport file\\n\\na = file.read(\\"hello.txt\\")\\n```\\n\\nAdd the following content to the `hello.txt` file:\\n\\n```shell\\nHello World !\\n```\\n\\nThe compilation result is as follows:\\n\\n```shell\\na: Hello World !\\n```\\n\\nBy combining the `json.decode` method, you can easily deserialize a JSON file.\\n\\nAdd the following content to the `hello.json` file:\\n\\n```json\\n{\\n  \\"name\\": \\"John\\",\\n  \\"age\\": 10\\n}\\n```\\n\\nKCL program:\\n\\n```kcl\\nimport file\\nimport json\\n\\n_a = json.decode(file.read(\\"hello.json\\"))\\n\\nname = _a.name\\nage = _a.age\\n```\\n\\nThe compilation result is as follows:\\n\\n```yaml\\nname: John\\nage: 10\\n```\\n\\nMore details - <https://kcl-lang.io/zh-CN/docs/reference/model/file/>\\n\\n#### KCL Compiler supports the use of environment variable `KCL_CACHE_PATH` to specify the cache path\\n\\nKCL Compiler will cache the generated code to the directory specified by the environment variable `KCL_CACHE_PATH`. If not specified, it will be generated to the project root directory.\\n\\n#### KCL Plugin System supports using Golang to write KCL plugins\\n\\nKCL Plugin System supports using Golang to write KCL plugins. The following is an example of using Golang to define the `hello` plugin.\\n\\n```golang\\npackage hello_plugin\\n\\nimport (\\n    \\"kcl-lang.io/kcl-go/pkg/plugin\\"\\n)\\n\\nfunc init() {\\n    plugin.RegisterPlugin(plugin.Plugin{\\n        Name: \\"hello\\",\\n        MethodMap: map[string]plugin.MethodSpec{\\n            \\"add\\": {\\n                Body: func(args *plugin.MethodArgs) (*plugin.MethodResult, error) {\\n                    v := args.IntArg(0) + args.IntArg(1)\\n                    return &plugin.MethodResult{V: v}, nil\\n                },\\n            },\\n        },\\n    })\\n}\\n```\\n\\nWith the `hello` plugin, you can use the `add` method in the KCL program.\\n\\n```kcl\\npackage main\\n\\nimport (\\n    \\"fmt\\"\\n\\n    \\"kcl-lang.io/kcl-go/pkg/kcl\\"\\n    \\"kcl-lang.io/kcl-go/pkg/native\\"                // Import the native API\\n    _ \\"kcl-lang.io/kcl-go/pkg/plugin/hello_plugin\\" // Import the hello plugin\\n)\\n\\nfunc main() {\\n    // Note we use `native.MustRun` here instead of `kcl.MustRun`, because it needs the cgo feature.\\n    yaml := native.MustRun(\\"main.k\\", kcl.WithCode(code)).GetRawYamlResult()\\n    fmt.Println(yaml)\\n}\\n\\nconst code = `\\nimport kcl_plugin.hello\\n\\nname = \\"kcl\\"\\nthree = hello.add(1,2) # 3\\n```\\n\\n### \ud83d\ude38 KCL supports linux arm64\\n\\nKCL v0.8.0 adds support for the Linux arm64 platform in the release product.\\n\\nYou can find the compressed package with the suffix `linux-arm64` on the [KCL Release Page](https://github.com/kcl-lang/kcl/releases)\\n\\n### \ud83c\udfc4 SDK & API Updates\\n\\n#### Rust SDK\\n\\nKCL Rust SDK provides a series of APIs for compiling, validating, testing, and formatting KCL files.\\n\\n[KCL Rust SDK: https://github.com/kcl-lang/lib](https://github.com/kcl-lang/lib)\\n\\n#### Java SDK\\n\\nKCL Java SDK adds syntax tree, scope, symbol, and other syntax and semantic structure definitions and related query APIs.\\n\\n#### Go SDK\\n\\n- KCL Doc supports output in OpenAPI format.\\n- Go SDK add APIs for parsing.\\n\\n#### API Update\\n\\n- KCL API adds API for validating JSON and YAML files.\\n- Introducing syntax and semantic analysis APIs for analyzing KCL code.\\n- Introducing a binary artifact build API for caching compilation results.\\n- Introducing a binary artifact execution API for directly running compiled results, avoiding redundant compilation and improving performance.\\n- Introducing a code generation API to programmatically implement KCL code generation instead of writing complex templates.\\n\\nMore updates can be found [here](https://kcl-lang.io/docs/reference/xlang-api/go-api).\\n\\n### \ud83d\udc1e Other Updates and Bug Fixes\\n\\n- Fixed compilation errors caused by using the -S compilation parameter in KCL CLI.\\n- Corrected an issue in the kcl fmt tool where an extra newline was added at the end when formatting lambda expressions.\\n- Resolved an error in Schema Doc code completion snippets.\\n- Fixed a recursive check error for required properties in Schema objects.\\n- Enhanced the robustness of Schema index signature type checks.\\n- Addressed an issue where string identifiers like \u201c$if\u201d were not correctly defined within Schema.\\n- Optimized error messages for unexpected tokens in syntax errors.\\n- Rectified variable calculations in unexpected dictionary comprehension expressions where the key and loop variable were the same.\\n\\n## IDE & Toolchain Updates\\n\\n### IDE Updates\\n\\n#### IDE semantic-level highlighting enhancement\\n\\nKCL IDE previously only supported KCL syntax highlighting, as shown in the figure below:\\n\\n![old-ide](/img/blog/2024-01-18-biweekly-newsletter/old-ide.png)\\n\\nWe have gradually introduced a new KCL semantic model in the past year. With the support of the new semantic model, KCL IDE now supports semantic-level highlighting. Code that is semantically related will be highlighted in the same way.\\n\\n![new-ide](/img/blog/2024-01-18-biweekly-newsletter/new-ide.png)\\n\\nFor more information about the KCL semantic model, see:\\n[Unlocking Advanced Code Intelligence with the KCL Semantic Model](https://kcl-lang.io/zh-CN/blog/2023-12-09-kcl-new-semantic-model)\\n\\n#### IDE supports completion of builtin methods\\n\\nKCL IDE supports completion of builtin methods, as shown in the figure below:\\n\\n![builtin-completion](/img/blog/2024-03-06-kcl-0.8.0-release/builtin-ide.gif)\\n\\n#### IDE supports quick fix for variable reference errors\\n\\nKCL IDE supports quick fix for variable reference errors, as shown in the figure below:\\n\\n![quick-fix](/img/blog/2024-03-06-kcl-0.8.0-release/quick-fix.gif)\\n\\n#### IDE supports incremental parsing and asynchronous compilation\\n\\nIDE supports incremental parsing and asynchronous compilation through the new semantic model, which improves the compilation speed and writing experience.\\n\\nMore details: <https://kcl-lang.io/zh-CN/blog/2023-12-09-kcl-new-semantic-model>\\n\\n#### IDE LSP bug fixes\\n\\n- Fixed an issue where string interpolation variables in assert statements couldn\u2019t navigate.\\n- Corrected an exception-triggering issue in function autocompletion within strings.\\n- Resolved an autocompletion error when a comment followed a string.\\n- Fixed an issue where internal property symbols in schemas couldn\u2019t navigate.\\n- Addressed an exception in alias semantic checks and autocompletion for import statements.\\n- Rectified autocompletion issues in check expressions within schemas.\\n- Fixed autocompletion errors in nested schema definitions.\\n- Resolved missing hover information for certain elements.\\n- Ensured consistent symbol types for autocompletion across different syntaxes.\\n- Distinguished between schema type and instance autocompletion symbols.\\n- Standardized schema comment documentation autocompletion format.\\n- Fixed issues where symbols within configuration block if statements couldn\u2019t navigate or autocompletion was affected.\\n\\n### Vet Tool Updates\\n\\nIn v0.8.0 release, we have optimized the diagnostic of the KCL verification tool. In the work of using the KCL verification tool to verify json/yaml files, the abnormal location of the json file will be accurately located.\\n\\nTake `hello.json` as an example, we will verify the content of the json file through the following `main.k` file.\\n\\n```json\\n{\\n  \\"name\\": 10,\\n  \\"age\\": 18,\\n  \\"message\\": \\"This is Alice\\"\\n}\\n```\\n\\nThe `main.k`\\n\\n```kcl\\nschema User:\\n    name: str\\n    age: int\\n    message?: str\\n```\\n\\nWe can verify the content of the json file through the following command.\\n\\n```shell\\nkcl vet hello.json main.k\\n```\\n\\nWe can see the error location in the json file:\\n\\n```shell\\nerror[E2G22]: TypeError\\n --\x3e test.json:2:5\\n  |\\n2 |     \\"name\\": 10,\\n  |     ^ expected str, got int(10)\\n  |\\n\\n --\x3e main.k:2:5\\n  |\\n2 |     name: str\\n  |     ^ variable is defined here, its type is str, but got int(10)\\n  |\\n```\\n\\n#### KCL cli supports git repository as a compilation entry\\n\\nBy using the following command, you can use the KCL git repository as a compilation entry.\\n\\n```shell\\nkcl run <git url>\\n```\\n\\n#### kcl mod graph supports output KCL package dependency graph\\n\\nYou can use command `kcl mod graph` to output the KCL package dependency graph.\\n\\n### KCL Package Management\\n\\n#### KCL Package Management supports adding git dependencies through commit\\n\\nKCL Package Management adds the ability to add git repo dependencies through commit. For example, using <https://github.com/KusionStack/catalog>\uff0cadd commit `a29e3db` as a dependency. You can add it through editing the kcl.mod file or directly through the command line.\\n\\nEdit the kcl.mod file as follows:\\n\\n```toml\\n[dependencies]\\ncatalog = { git = \\"https://github.com/KusionStack/catalog.git\\", commit = \\"a29e3db\\" }\\n```\\n\\nOr add it through the command line:\\n\\n```shell\\nkcl mod add --git https://github.com/KusionStack/catalog.git --commit a29e3db\\n```\\n\\n#### KCL Package Management supports the dependency name with `-`\\n\\nKCL Package Management supports the dependency name with `-`. For example, you can add the `set-annotation` as a dependency through the following command:\\n\\n```shell\\nkcl mod add set-annotation\\n```\\n\\nIn the KCL program, you can reference it through `set_annotation`.\\n\\n```kcl\\nimport set_annotation\\n```\\n\\n### KCL Import Tool\\n\\n- Support mapping OpenAPI multiplyOf specification to KCL multiplyof function for validation.\\n- Support outputting multiple KCL files from YAML Stream-formatted Kubernetes CRD files.\\n- Support generating validation expressions for OpenAPI allOf keyword.\\n- Support generating validation expressions for KCL array and dictionary types using all/any.\\n\\n## Community Integrations & Extensions Updates\\n\\n### Flux KCL Controller Release\\n\\nWe have developed [Flux KCL Controller](https://github.com/kcl-lang/flux-kcl-controller) to supports KCL integration with Flux. After installing Flux KCL Controller in the cluster, you can use the following resources to achieve continuous integration of KCL git repositories through FluxCD.\\n\\n```yaml\\napiVersion: source.toolkit.fluxcd.io/v1\\nkind: GitRepository\\nmetadata:\\n  name: kcl-deployment\\n  namespace: source-system\\nspec:\\n  interval: 30s\\n  # The URL of the git repository\\n  url: https://github.com/awesome-kusion/kcl-deployment.git\\n  ref:\\n    branch: main\\n---\\napiVersion: krm.kcl.dev.fluxcd/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: kcl-deployment\\n  namespace: source-system\\nspec:\\n  sourceRef:\\n    kind: GitRepository\\n    name: kcl-deployment\\n```\\n\\nMore details: <https://kcl-lang.io/zh-CN/blog/2024-02-01-biweekly-newsletter/>\\n\\n### CodeQL KCL Tool\\n\\nWe finished CodeQL KCL dbschema definition and data extraction for KCL syntax and semantics. We can use CodeQL to query KCL code for static analysis and scanning to improve code security.\\n\\nMore details: <https://github.com/kcl-lang/codeql-kcl>\\n\\n## KCL Modules Update\\n\\nThere are 303 KCL modules in the KCL v0.8.0 release on <https://artifacthub.io>, mainly including new models related to Crossplane Provider and libraries related to JSON merge operations.\\n\\n- KCL JSON Patch Library: <https://artifacthub.io/packages/kcl/kcl-module/jsonpatch>\\n- KCL JSON Merge Patch Library: <https://artifacthub.io/packages/kcl/kcl-module/json_merge_patch>\\n- KCL Kubernetes Strategy Merge Patch Library: <https://artifacthub.io/packages/kcl/kcl-module/strategic_merge_patch>\\n- KCL Crossplane and Crossplane Provider Series Models: <https://artifacthub.io/packages/search?org=kcl&sort=relevance&page=1&ts_query_web=crossplane>\\n- Kubernetes 1.29 version: <https://artifacthub.io/packages/kcl/kcl-module/k8s/1.29.0>\\n\\n- New Podinfo application configuration model, supports setting external dynamic parameters such as replicas, etc., can render Kubernetes resource configuration directly through a command, and can modify and customize resource templates based on this model.\\n\\n```shell\\nkcl run oci://ghcr.io/kcl-lang/podinfo -D replicas=2\\n```\\n\\n- JSON Schema library released version 0.0.4, fixed type definition errors. You can execute the following command to update or add dependencies.\\n\\n```shell\\nkcl mod add jsonschema:0.0.4\\n```\\n\\n## Other Updates\\n\\nThe full update and bugfix List of KCL v0.8.0 can be found at: <https://github.com/kcl-lang/kcl/compare/v0.7.0...v0.8.0>\\n\\n## Document Updates\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.x, v0.5.x, v0.6.x, v0.7.0 and v0.8.0 versions are supported.\\n\\n## Community Updates\\n\\n### KCL LFX Project KickOff\\n\\nCongratulations to @AkashKumar7902, @octonawish-akcodes, @shashank-iitbhu for being selected for the CNCF KCL LFX project, and thanks to @Vanshikav123, @Amit Pandey for their active participation.\\n\\n### KCL on Crossplane Function Market\\n\\nAfter the release of the combination function in Crossplane v1.14, the scope of using Crossplane to build cloud-native platforms has been rapidly expanded. The KCL team has followed up and proactively built a reusable function. The entire Crossplane ecosystem can now leverage the high-level experience and capabilities provided by KCL to build its own cloud-native platform.\\n\\nMore details: <https://blog.crossplane.io/function-kcl/>\\n\\n## Special Thanks\\n\\nThanks to the community friends for their contributions to KCL v0.8.0. The following list is in no particular order:\\n\\n- Thanks to @jakezhu9 for the continuous contribution to the kcl import tool \ud83e\udd1d\\n- Thanks to @octonawish-akcodes for the continuous contributions to KCL code cleanup and FAQ documentation \ud83d\ude4c\\n- Thanks to @satyazzz123 for contributing to the support of reading environment variables in KRM KCL \ud83d\ude4c\\n- Thanks to @AkashKumar7902 for the contributions to the package management tool feature in KCL \ud83d\ude4c\\n- Thanks to @UtkarshUmre for the contribution to the KCL linux-arm64 build CI \ud83d\ude4c\\n- Thanks to @octonawish-akcodes and @d4v1d03 for the continuous contributions to KCL FAQ documentation and KCL IDE feature \ud83d\ude4c\\n- Thanks to @octonawish-akcodes for the contribution to the Ansible KCL Module\\n- Thanks to @AkashKumar7902 and @Vanshikav123 for the contributions to the package management tool feature in KCL \ud83d\ude4c\\n- Thanks to @StevenLeiZhang for the contributions to KCL documentation and KCL plugin\\n- Thanks to @patrycju, @Callum Lyall, @Matt Gowie, @ShiroDN, @FLAGLORD, @YiuTerran, @flyinox, @steeling, @Anoop, @Even Solberg, @Phillip Neumann, @Naxe, @rozaliev, @CloudZero357, @martingreber, @az, @Art3mK, @Erick, @TheChinBot, @Evgeny Shepelyuk, @yonas, @vtomilov, @Fdall, @bozaro, @starkers, and @MrGuoRanDuo for their valuable suggestions and feedback during the iteration process of KCL v0.8 \ud83d\ude4c\\n\\n## Next Steps\\n\\nWe expect to release KCL v0.9.0 in May 2024. For more details, please refer to KCL 2024 Roadmap and KCL v0.9.0 Milestone. If you have more ideas and needs, please feel free to raise Issues or Discussions in the KCL Github repository, and welcome to join our community for discussion \ud83d\ude4c \ud83d\ude4c \ud83d\ude4c\\n\\n- KCL 2024 Roadmap: https://github.com/kcl-lang/kcl/issues/882\\n- KCL v0.9.0 Milestone: https://github.com/kcl-lang/kcl/milestone/9\\n- KCL GitHub Issues: https://github.com/kcl-lang/kcl/issues\\n- KCL GitHub Discussion: https://github.com/orgs/kcl-lang/discussions\\n- KCL Community: https://github.com/kcl-lang/community\\n\\n## Additional Resources\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/)\\n- [KusionStack Repo](https://github.com/KusionStack/)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2024-03-04-crossplane-marketplace-kcl","metadata":{"permalink":"/blog/2024-03-04-crossplane-marketplace-kcl","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-03-04-crossplane-marketplace-kcl/index.md","source":"@site/blog/2024-03-04-crossplane-marketplace-kcl/index.md","title":"Empowering Cloud-Native Platforms: The Synergy of KCL and Crossplane","description":"Content sourced from the original Crossplane official blog post//blog.crossplane.io/function-kcl","date":"2024-03-04T00:00:00.000Z","formattedDate":"March 4, 2024","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Crossplane","permalink":"/blog/tags/crossplane"}],"readingTime":3.58,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-03-04-crossplane-marketplace-kcl","title":"Empowering Cloud-Native Platforms: The Synergy of KCL and Crossplane","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Crossplane"]},"prevItem":{"title":"KCL v0.8.0 Release Blog","permalink":"/blog/2024-03-06-kcl-0.8.0-release"},"nextItem":{"title":"KCL Newsletter (2024 02.02 - 2024.02.22)","permalink":"/blog/2024-02-22-newsletter"}},"content":"> _Content sourced from the original Crossplane official blog post: [https://blog.crossplane.io/function-kcl](https://blog.crossplane.io/function-kcl)_\\n\\n## Introduction\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations and polices, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\n**Since the release of the beta version of composite functions in Crossplane v1.14**, the potential for building cloud-native platforms using Crossplane has been rapidly expanding. The KCL team promptly followed up and actively built a reusable function. **The entire Crossplane ecosystem can now utilize the high-level experience and capabilities provided by KCL to build its own cloud-native platform**.\\n\\nAdditionally, Crossplane announced that the KCL function has become the first third-party function component to be released to the Upbound Marketplace, available at https://marketplace.upbound.io/providers/crossplane-contrib/function-kcl. The source code can be found at https://github.com/crossplane-contrib/function-kcl, and contributions and feedback are welcome.\\n\\nYou can install the function-kcl with the following command and start using it across the entire Crossplane control plane:\\n\\n```shell\\ncrossplane\xa0xpkg\xa0install\xa0function\xa0xpkg.upbound.io/crossplane-contrib/function-kcl:v0.2.0\\n```\\n\\n**The Crossplane team and community are thankful for the KCL team\'s significant contribution, and its substantial enhancement to the evolving Functions for Crossplane ecosystem!**\\n\\n![crossplane-announcing](/img/blog/2024-03-04-crossplane-marketplace-kcl/crossplane-announcing.png)\\n\\nCrossplane, along with its composite model, allows developers to create higher-level abstractions that encapsulate and combine various types of cloud resources across different providers and services. Rendering these abstractions using composite functions can effectively enhance the template functionality of various provider resources while reducing the amount of YAML code required.\\n\\nCombining KCL with Composition Functions offers several benefits:\\n\\n- **Simplification of Complex Configurations**: KCL provides a more concise syntax and structure as a DSL, reducing the complexity of configurations. When combined with Crossplane\u2019s composite resources, you can create more intuitive and easy-to-understand configuration templates with loop and condition features, simplifying the definition and maintenance of resources instead of duplicate YAMLs.\\n- **Reusability and Modularity**: KCL supports modularity and code reuse through OCI Registry, which means you can create reusable configuration components. Combined with Crossplane, this promotes the modularity of composite resources, increases the reuse of configurations, and reduces errors.\\n- **Automation and Policy-Driven**: You can use KCL\u2019s powerful features to write policies and constraints that, combined with Crossplane\u2019s declarative resource management, can be automatically enforced, ensuring compliance within the cloud environment.\\n\\n## Getting Started\\n\\nThere are two ways to combine KCL and Crossplane:\\n\\n- One involves using KCL to write Crossplane composite functions and install them for use in a cluster, still using YAML to define the schema and input required by the app team. KCL is used to write rendering logic to Crossplane Managed Resource to interface with different cloud platforms or Kubernetes clusters. **Note: This approach can install KCL functions for use in the cluster and also use the crossplane beta render command to complete Managed Resource rendering directly on the client.**\\n\\n![crossplane-kcl-func](/img/blog/2024-03-04-crossplane-marketplace-kcl/crossplane-kcl-func.png)\\n\\n- The other method involves using KCL to entirely provide abstractions for application developers on the client side and generating Crossplane managed resources to deploy to a cluster, providing a unified programmable access layer for Kubernetes. Specific usage defines the schema input required by the app team using KCL Schema and writes the logic to render it to Crossplane Managed Resource to interface with different cloud platforms or Kubernetes clusters.\\n\\n![kcl-on-crossplane](/img/blog/2024-03-04-crossplane-marketplace-kcl/kcl-on-crossplane.png)\\n\\n**For detailed instructions on both approaches, please refer to the Crossplane official blog content: https://blog.crossplane.io/function-kcl**\\n\\n![crossplane-kcl-blog](/img/blog/2024-03-04-crossplane-marketplace-kcl/crossplane-kcl-blog.png)\\n\\nBoth of these methods require a Registry to facilitate the work. The final choice between them may depend on your operational habits and environmental costs. Regardless of the chosen method, **we recommend maintaining KCL code in Git for better GitOps implementation and better IDE experience and reusable modules**, such as using the Crossplane AWS Module: https://github.com/kcl-lang/modules/tree/main/crossplane-provider-aws\\n\\n## Summary\\n\\nThe function-kcl project is now donated to the Crossplane community, and we encourage the entire community to test it and try using KCL (the latest advanced language experience provided by Crossplane Functions) to build a cloud-native control plane. We welcome contributions and feedback from the community on the GitHub repository. Let us know your thoughts! https://github.com/crossplane-contrib/function-kcl\\n\\nFor more resources, please refer to:\\n\\n- KCL Website: https://kcl-lang.io/\\n- KusionStack Website: https://kusionstack.io/\\n- KCL v0.9.0 Milestone: https://github.com/kcl-lang/kcl/milestone/9"},{"id":"2024-02-22-newsletter","metadata":{"permalink":"/blog/2024-02-22-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-02-22-newsletter/index.md","source":"@site/blog/2024-02-22-newsletter/index.md","title":"KCL Newsletter (2024 02.02 - 2024.02.22)","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations and polices, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2024-02-22T00:00:00.000Z","formattedDate":"February 22, 2024","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Newsletter","permalink":"/blog/tags/newsletter"}],"readingTime":3.505,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-02-22-newsletter","title":"KCL Newsletter (2024 02.02 - 2024.02.22)","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"Empowering Cloud-Native Platforms: The Synergy of KCL and Crossplane","permalink":"/blog/2024-03-04-crossplane-marketplace-kcl"},"nextItem":{"title":"2024 LFX Mentorship Internship Launch:KCL Open Source Community Welcomes Your Participation!!!","permalink":"/blog/2024-02-05-lfs-guide"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations and polices, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest news, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThanks to to all contributors for their outstanding work over the past twenty days (2024 02.02 - 2024 02.22). Here is an overview of the key content:\\n\\n**\ud83d\udce6 Module Updates**\\n\\nThe JSON Schema module 0.0.4 has released, fixing type definition errors. You can update or add dependencies by running the following command:\\n\\n```shell\\nkcl mod add jsonschema:0.0.4\\n```\\n\\n**\ud83c\udfc4 Language Updates**\\n\\nKCL has released preview version 0.8.0, mainly including the following updates:\\n\\n- Added the file system library for reading KCL module information and system files, including the `read`, `glob`, `workdir`, and `modpath` functions. See more details in this [issue](https://github.com/kcl-lang/kcl/issues/1049)\\n- Optimized syntax error messages for unexpected tokens.\\n- Removed output for unexpected internal built-in type attributes in schema objects.\\n- Fixed variable calculation in unexpected dictionary generation expressions where the key is the same as the loop variable.\\n- Fixed errors in defining string identifiers within schemas, such as `\\"$if\\"`.\\n\\n**\ud83d\udd27 Toolchain Updates**\\n\\n- `kcl run` supports using the -H parameter to output hidden fields starting with `_`.\\n- `kcl run` supports running remote Git repository code directly.\\n- Introduce the `kcl mod graph` subcommand used to output module dependency graphs.\\n- Fixed formatting errors when there is an if statement within an else block.\\n\\n**\ud83d\udcbb IDE Updates**\\n\\n- Enhanced autocompletion and hover documentation for built-in functions and system libraries\\n- Fixed issues with navigating and autocompleting if statements symbols within configuration blocks\\n- Added quick fix feature for variable reference errors\\n\\n**\ud83c\udf81 API Updates**\\n\\n- The `OverrideFile` API has added path for querying and modifying configurations, such as `a[\\"b\\"].c`\\n- The `Run` API has added the `WithShowHidden` and the `WithTypePath` flags.\\n\\n**\ud83d\ude80 Plugin System Updates**\\n\\nIn addition to using Python for KCL plugin functions, it now supports using Go to write plugin functions for KCL, which is very simple to use.\\n\\n- Define a plugin (using a hello plugin containing the add function as an example)\\n\\n```go\\npackage hello_plugin\\n\\nimport (\\n\\t\\"kcl-lang.io/kcl-go/pkg/plugin\\"\\n)\\n\\nfunc init() {\\n\\tplugin.RegisterPlugin(plugin.Plugin{\\n\\t\\tName: \\"hello\\",\\n\\t\\tMethodMap: map[string]plugin.MethodSpec{\\n\\t\\t\\t\\"add\\": {\\n\\t\\t\\t\\tBody: func(args *plugin.MethodArgs) (*plugin.MethodResult, error) {\\n\\t\\t\\t\\t\\tv := args.IntArg(0) + args.IntArg(1)\\n\\t\\t\\t\\t\\treturn &plugin.MethodResult{V: v}, nil\\n\\t\\t\\t\\t},\\n\\t\\t\\t},\\n\\t\\t},\\n\\t})\\n}\\n```\\n\\n- Use the plugin\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\"fmt\\"\\n\\n\\t\\"kcl-lang.io/kcl-go/pkg/kcl\\"\\n\\t\\"kcl-lang.io/kcl-go/pkg/native\\"                // Import the native API\\n\\t_ \\"kcl-lang.io/kcl-go/pkg/plugin/hello_plugin\\" // Import the hello plugin\\n)\\n\\nfunc main() {\\n\\t// Note we use `native.MustRun` here instead of `kcl.MustRun`, because it needs the cgo feature.\\n\\tyaml := native.MustRun(\\"main.k\\", kcl.WithCode(code)).GetRawYamlResult()\\n\\tfmt.Println(yaml)\\n}\\n\\nconst code = `\\nimport kcl_plugin.hello\\n\\nname = \\"kcl\\"\\nthree = hello.add(1,2) # 3\\n`\\n```\\n\\n**\ud83d\udea2 Integration Updates**\\n\\n- Released initial version of Ansible KCL module, supporting basic execution of KCL code, with other functionalities being improved\\n- Optimized Git Source functionality for KCL FluxCD Controller, with OCI Source functionality in progress\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @octonawish-akcodes and @d4v1d03 for their continuous contributions to KCL FAQ documentation and KCL IDE functionality \ud83d\ude4c\\n- Thanks to @octonawish-akcodes for the contribution to the Ansible KCL Module\\n- Thanks to @AkashKumar7902 and @Vanshikav123 for the contribution to the KCL package management tool functionality \ud83d\ude4c\\n- Thanks to @StevenLeiZhang for the contribution to KCL documentation and KCL plugins\\n- Thanks to @TheChinBot, @Evgeny Shepelyuk, @yonas, @steeling, @vtomilov, @Fdall, @CloudZero357, @bozaro, @starkers, @MrGuoRanDuo and @FLAGLORD, among others, for their valuable feedback and suggestions while using KCL recently. \ud83d\ude4c\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.8.0 Milestone](https://github.com/kcl-lang/kcl/milestone/8)\\n- [KCL v0.9.0 Milestone](https://github.com/kcl-lang/kcl/milestone/9)"},{"id":"2024-02-05-lfs-guide","metadata":{"permalink":"/blog/2024-02-05-lfs-guide","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-02-05-lfx-guide/index.md","source":"@site/blog/2024-02-05-lfx-guide/index.md","title":"2024 LFX Mentorship Internship Launch:KCL Open Source Community Welcomes Your Participation!!!","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2024-02-05T00:00:00.000Z","formattedDate":"February 5, 2024","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"LFX-Mentorship","permalink":"/blog/tags/lfx-mentorship"}],"readingTime":3.42,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-02-05-lfs-guide","title":"2024 LFX Mentorship Internship Launch:KCL Open Source Community Welcomes Your Participation!!!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","LFX-Mentorship"]},"prevItem":{"title":"KCL Newsletter (2024 02.02 - 2024.02.22)","permalink":"/blog/2024-02-22-newsletter"},"nextItem":{"title":"KCL Biweekly Newsletter (2024 01.19 - 2024.02.01) | KCL v0.7.5 Released and Flux Integration","permalink":"/blog/2024-02-01-biweekly-newsletter"}},"content":"[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\n- **_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n- **_KCL Github Repo: [https://github.com/kcl-lang](https://github.com/kcl-lang)_**\\n\\nFor those interested in cloud-native, platform engineering,compiler, package management tools, and IDEs, we invite you to apply for the 2024 Spring Linux Foundation LFX Mentorship project. You can earn a minimum of $3000 for completing the project! Apply now!\\n\\n## LFX Mentorship Project\\n\\nWe have three Mentorship projects, covering package management tools, compiler, and IDEs.\\n\\n### 1. Add version management for KCL package management tool\\n\\nKCL package management tool (kpm) currently supports uploading, downloading, and distributing KCL packages, but does not support version management of KCL packages. In the process of using kpm to add third-party dependencies to KCL package, kpm will automatically download all third-party dependencies based on the dependency relationship. If different versions of the same package appear during the download, the corresponding selection strategy should be provided according to the package version management policy to select the appropriate version for download.\\n\\nIn this project, you need to add the package version management part of kpm to ensure that kpm can select the appropriate third-party dependencies.\\n\\n- More details: https://github.com/kcl-lang/kpm/issues/246\\n- Pretest: https://github.com/kcl-lang/kpm/issues/263\\n- Apply Link: https://mentorship.lfx.linuxfoundation.org/project/06b5baee-bdcd-4f5e-9a1a-454191445a01\\n\\n### 2. KCL IDE Quick Fix\\n\\nFor KCL IDE, develop a quick fix feature. When a KCL program has a compilation error in the IDE, the Quick Fix feature can provide quick problem fixes at the location of the KCL program error based on the user\'s error type.\\n\\nIn this project, you need to develop different Quick Fix functions for IDE based on the error type of the KCL program.\\n\\n- More Details: https://github.com/kcl-lang/kcl/issues/997\\n- Pretest: https://github.com/kcl-lang/kcl/issues/1020\\n- Apply Link: https://mentorship.lfx.linuxfoundation.org/project/391edda7-239d-4471-a36a-c03c24e024cb\\n\\n### 3. KCL IDE automatically loads KCL third-party dependencies\\n\\nKCL IDE is the most direct interface for KCL users. It often fails to find third-party dependencies. Currently, KCL\'s package management tool kpm has provided the ability to automatically download and update third-party dependencies, but users still need to update third-party libraries through the command line, which affects the user\'s development experience. Therefore, KCL IDE needs to be integrated with KCL\'s package management tool kpm to provide the ability to automatically download and update third-party libraries for the IDE.\\n\\nIn this project, you need to use the ability of kpm to implement common functions in the IDE, such as automatically downloading third-party dependencies, automatically updating third-party dependencies when kcl.mod changes, and Quick Fix triggering third-party dependencies automatic download, to ensure that KCL IDE can provide a more complete development experience with the support of package management tools.\\n\\n- More Details: https://github.com/kcl-lang/kcl/issues/998\\n- Pretest: https://github.com/kcl-lang/kcl/issues/1031\\n- Apply Link: https://mentorship.lfx.linuxfoundation.org/project/59d5fb6c-153d-4e46-9d1f-2948641b0471\\n\\n### 4. How to Apply\\n\\nApply for your favorite project on the LFX mentorship platform. You can visit the LFX mentorship platform through the following link. The application starts on January 29, 2024, and ends on February 13, 2024.\\n\\n- https://mentorship.lfx.linuxfoundation.org/\\n\\nIf you have any questions, please feel free to get more information directly from the corresponding issue or discuss with us:\\n\\n- KCL package version management https://github.com/kcl-lang/kpm/issues/246\\n\\n- KCL Quick Fix https://github.com/kcl-lang/kcl/issues/997\\n\\n- KCL IDE dependency update https://github.com/kcl-lang/kcl/issues/998\\n\\n### 5. Project Timeline\\n\\n| Event                                                                                                      | Start Date                    | End Date                 |\\n| ---------------------------------------------------------------------------------------------------------- | ----------------------------- | ------------------------ |\\n| Mentee Applications Open                                                                                   | January 29                    | February 13, 5:00 PM PDT |\\n| Application Review/Admission Decisions/HR Paperwork                                                        | February 13                   | February 27, 5:00 PM PDT |\\n| Mentorship Program Begins with Initial Work Assignments                                                    | March 4 (Week 1)              |                          |\\n| Midterm Mentee Evaluations / First Stipend Payments                                                        | April 10 (Week 6)             |                          |\\n| Final Mentee Evaluations Due / Mentee Feedback Submission Due / Second and Final Stipend Payment Approvals | May 22, 5:00 PM PST (Week 12) |                          |\\n| Last Day of Term                                                                                           | May 31                        |                          |"},{"id":"2024-02-01-biweekly-newsletter","metadata":{"permalink":"/blog/2024-02-01-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-02-01-biweekly-newsletter/index.md","source":"@site/blog/2024-02-01-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2024 01.19 - 2024.02.01) | KCL v0.7.5 Released and Flux Integration","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2024-02-01T00:00:00.000Z","formattedDate":"February 1, 2024","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":7.515,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-02-01-biweekly-newsletter","title":"KCL Biweekly Newsletter (2024 01.19 - 2024.02.01) | KCL v0.7.5 Released and Flux Integration","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"2024 LFX Mentorship Internship Launch:KCL Open Source Community Welcomes Your Participation!!!","permalink":"/blog/2024-02-05-lfs-guide"},"nextItem":{"title":"KCL Biweekly Newsletter (2024 01.04 - 2024.01.18) | KCL v0.7.4 Released!","permalink":"/blog/2024-01-18-biweekly-newsletter"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThanks to to all contributors for their outstanding work over the past two weeks (01.19 2024 - 02.01 2024). Here is an overview of the key content:\\n\\n**\ud83d\udce6 Module Updates**\\n\\n- Added the `podinfo` application configuration module, supporting the setting of external dynamic parameters such as `replicas`. You can directly render Kubernetes manifests with a single command, and customize KCL templates based on this module.\\n\\n```shell\\nkcl run oci://ghcr.io/kcl-lang/podinfo -D replicas=2\\n```\\n\\n**\ud83c\udfc4 Language Updates**\\n\\n- Improved error messages when object attribute are not found at compile time.\\n- Fixed the recursive check error for mandatory attribute of schema objects.\\n- Enhanced the robustness of type-checking for schema index signatures.\\n\\n**\ud83d\udd27 Toolchain Updates**\\n\\n- **Documentation Tools Updates**: Added support for HTML escaping of multiline strings in generated Markdown documentation.\\n- **CodeQL KCL Tools**: Preliminary support for the CodeQL KCL dbschema definition and data extraction from KCL syntax and semantics, enabling static analysis and scanning of KCL code through CodeQL queries to improve code security.\\n\\n**\ud83d\udcbb IDE Updates**\\n\\n- **Semantic Highlighting**\\n\\n  - KCL IDE optimized semantic highlighting.\\n\\n- **Enhancement for Completion Features**\\n  - Fixed the issue with erroneous completions after strings followed by comments.\\n  - Fixed the issue where internal property symbols in Schema could not be navigated.\\n\\n**\ud83c\udf81 API Updates**\\n\\n- Added syntax and semantic analysis APIs for analyzing KCL code.\\n- Added APIs to build binary artifacts for caching compilation results.\\n- Added APIs to run binary artifacts directly, avoiding recompilation and improving performance.\\n- Added code generation APIs to programmatically implement KCL code generation instead of writing complex templates.\\n\\n**\ud83d\ude80 SDK Updates**\\n\\n- Updated KCL Go SDK to version 0.7.5.\\n- Updated KCL Python SDK to version 0.7.5.\\n- Updated KCL Rust SDK to version 0.7.5.\\n- Added definitions for syntax trees, scopes, symbols, and other syntactic and semantic structures to the KCL Java SDK, along with related query APIs.\\n\\nFor more details, visit: https://github.com/kcl-lang/lib\\n\\n**\ud83d\udea2 Integration Updates**\\n\\n- In addition to the ArgoCD KCL plugin, KCL now supports GitOps for KCL configurations stored in Git/OCI repositories using the KCL Flux Controller. For more details, visit [https://github.com/kcl-lang/flux-kcl-controller](https://github.com/kcl-lang/flux-kcl-controller). Contributions are welcome \ud83d\udc4f.\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @octonawish-akcodes for contributions to KCL code cleanup and FAQ documents. \ud83d\ude4c\\n- Thanks to @satyazzz123 for contributions to the KRM KCL\'s support for reading environment variables. \ud83d\ude4c\\n- Thanks to @AkashKumar7902 for contributions to the KCL package management tool functionality. \ud83d\ude4c\\n- Thanks to @UtkarshUmre for contributions to the KCL linux-arm64 build CI scripts. \ud83d\ude4c\\n- Thanks to @steeling, @rozaliev, @CloudZero357, @martingreber, @az, @Art3mK, @AdmiralNemo, and @Erick for valuable suggestions and feedback during the past two weeks of using KCL. \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### Flux KCL Integration\\n\\nUsing KCL together with GitOps tools like Flux has the following benefits:\\n\\n- The abstraction and programmability capabilities of KCL can help simplify complex Kubernetes deployment configurations, reducing the error rate of manually writing YAML files. It allows for configuration constraint checks at compile-time, making it easier to detect errors. Additionally, it eliminates redundant configuration templates, improves the scalability of configurations across multiple environments and tenants, and enhances configurability and maintainability.\\n- KCL allows developers to define the required resources for an application in a declarative manner. Combining KCL with Flux enables better implementation of Infrastructure as Code (IaC), improving deployment efficiency and simplifying application configuration management.\\n- With Flux, developers and operations teams can manage the deployment of applications by separately modifying application and configuration code. The Flux Controller automatically synchronizes changes to the configuration, enabling continuous deployment and ensuring consistency. In case of issues, quick rollbacks can be achieved.\\n\\n#### Workflow\\n\\nIn this example, we use a Python Flask application and GitHub Actions as a CI example. The Flux KCL Controller is deployed in the cluster as a CD example. KCL is used to define the Kubernetes resources that need to be deployed.\\n\\n> Note: You can use any containerized application and different CI/CD systems like GitLab CI, Jenkins CI, or ArgoCD in this scenario.\\n\\nWe divide the Python Flask application code and configuration code into two repositories to separate the concerns of different roles such as developers and operations teams.\\n\\n- Business code repository: https://github.com/kcl-lang/flask-demo\\n- Manifests repository: https://github.com/kcl-lang/flask-demo-kcl-manifests\\n\\nThe overall workflow is as follows:\\n\\n1. Pull the application code from GitHub.\\n2. Develop the application code and commit it to the GitHub repository.\\n3. Trigger GitHub Actions to compile the application code, generate a container image, and push the container image to the Docker Hub container registry.\\n4. Trigger GitHub Actions to update the Kubernetes manifest deployment files defined by KCL based on the version of the container image in the docker.io container registry.\\n5. The Flux KCL Controller retrieves the changes to the Kubernetes manifest defined by KCL and updates the deployment to the Kubernetes cluster.\\n\\n#### Specific Steps\\n\\n##### 1. Prepare a Kubernetes Cluster\\n\\n- Install [K3d](https://github.com/k3d-io/k3d) and create a cluster:\\n\\n```shell\\nk3d cluster create\\n```\\n\\n> Note: You can use other methods to create your own Kubernetes cluster, such as kind, minikube, etc.\\n\\n- Install kubectl\\n- Install kustomize\\n\\n##### 2. Install Flux KCL Controller\\n\\n![flux-kcl-workflow](/img/blog/2024-02-01-biweekly-newsletter/flux-kcl-workflow.png)\\n\\n```shell\\ngit clone https://github.com/kcl-lang/flux-kcl-controller.git && cd flux-kcl-controller && make deploy\\n```\\n\\n##### 3. Configure the Git Repository for Continuous Delivery\\n\\nDefine the `GitRepository` and `KCLRun` objects in the `gitrepo.yaml` file to configure the Git repository to be monitored for continuous delivery and additional parameters required for running KCL configurations.\\n\\n```yaml\\napiVersion: source.toolkit.fluxcd.io/v1\\nkind: GitRepository\\nmetadata:\\n  name: kcl-deployment\\n  namespace: default\\nspec:\\n  interval: 10s # Check the repository every 10s\\n  url: https://github.com/kcl-lang/flask-demo-kcl-manifests.git\\n  ref:\\n    branch: main # Monitor the main branch\\n---\\napiVersion: krm.kcl.dev.fluxcd/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: kcl-git-controller\\n  namespace: default\\nspec:\\n  sourceRef:\\n    kind: GitRepository\\n    name: kcl-deployment\\n```\\n\\nDeploy the objects to the cluster using the command `kubectl apply -f gitrepo.yaml`.\\n\\n> If you are using a private repository, you need to configure private repository access credentials using private key credentials. Refer to here for more details.\\n\\n> Note: You can also use [OCIRepository](https://fluxcd.io/flux/components/source/ocirepositories/) in this scenario to continuously deliver the `oci://ghcr.io/kcl-lang/podinfo` configuration package mentioned at the beginning of the article. For example, the following configuration:\\n\\n```yaml\\napiVersion: source.toolkit.fluxcd.io/v1beta2\\nkind: OCIRepository\\nmetadata:\\n  name: podinfo\\n  namespace: default\\nspec:\\n  interval: 5m0s\\n  url: oci://ghcr.io/kcl-lang/podinfo\\n  ref:\\n    tag: latest\\n---\\napiVersion: krm.kcl.dev.fluxcd/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: kcl-git-controller\\n  namespace: default\\nspec:\\n  sourceRef:\\n    kind: OCIRepository\\n    name: podinfo\\n```\\n\\n##### 4. Commit the Application Code\\n\\nAfter submitting in the `flask-demo` repository, Github will automatically build a container image and push it to the Docker hub. It will also then trigger the Action of the `flask-demo-kcl-manifest` repository and modify the image value in the deployment manifest repository through [KCL Automation API](/docs/user_docs/guides/automation). Now let\'s create a submission in the `flask-demo` repository, and we can see that the code submission triggers the Github CI process for the application repository.\\n\\n![](/img/docs/user_docs/guides/ci-integration/app-ci.png)\\n\\n##### 5. Configuration Automatic Update\\n\\nAfter the Github CI process in the application repository is completed, an automatic update configuration CI will be triggered in the repository where the KCL configuration is stored and submitted to the main branch of the `flask-demo-kcl-manifests` repository. The commit information is as follows\\n\\n![](/img/docs/user_docs/guides/ci-integration/image-auto-update.png)\\n\\n- We can obtain the deployment manifest source code for compilation and validation\\n\\n```shell\\ngit clone https://github.com/kcl-lang/flask-demo-kcl-manifests.git/\\ncd flask-demo-kcl-manifests\\ngit checkout main && git pull && kcl\\n```\\n\\nThe output YAML is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: flask_demo\\n  template:\\n    metadata:\\n      labels:\\n        app: flask_demo\\n    spec:\\n      containers:\\n        - name: flask_demo\\n          image: \\"kcllang/flask_demo:6428cff4309afc8c1c40ad180bb9cfd82546be3e\\"\\n          ports:\\n            - protocol: TCP\\n              containerPort: 5000\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  type: NodePort\\n  selector:\\n    app: flask_demo\\n  ports:\\n    - port: 5000\\n      protocol: TCP\\n      targetPort: 5000\\n```\\n\\nFrom the above configuration, it can be seen that the image of the resource is indeed automatically updated to the newly constructed image value.\\n\\nAt the same time, the Flux KCL Controller will automatically pull the configuration and update it to the cluster. This achieves an end-to-end automation process for submitting business code and deploying Kubernetes, where only the business code needs to be submitted. Of course, it can be further combined with Flagger to implement various deployment strategies such as canary releases, blue-green deployments, etc.\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.8.0 Milestone](https://github.com/kcl-lang/kcl/milestone/8)"},{"id":"2024-01-18-biweekly-newsletter","metadata":{"permalink":"/blog/2024-01-18-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-01-18-biweekly-newsletter/index.md","source":"@site/blog/2024-01-18-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2024 01.04 - 2024.01.18) | KCL v0.7.4 Released!","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2024-01-18T00:00:00.000Z","formattedDate":"January 18, 2024","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.615,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-01-18-biweekly-newsletter","title":"KCL Biweekly Newsletter (2024 01.04 - 2024.01.18) | KCL v0.7.4 Released!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"KCL Biweekly Newsletter (2024 01.19 - 2024.02.01) | KCL v0.7.5 Released and Flux Integration","permalink":"/blog/2024-02-01-biweekly-newsletter"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 12.22 - 2024.01.04) | Crossplane KCL Integration","permalink":"/blog/2024-01-04-biweekly-newsletter"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (01.04 2024 - 01.18 2024). Here is an overview of the key content:\\n\\n**\ud83c\udf1e KCL Update**\\n\\n- v0.7.4 released, adding support for Linux arm64.\\n\\n**\ud83c\udf81 API Update**\\n\\n- Added APIs for syntax and semantic analysis\\n\\n**\ud83d\udd27 Toolchain Update**\\n\\n- **kcl-go sdk update**\\n\\n  - KCL Doc tool supports output in OpenAPI format.\\n  - Added Parsing related APIs.\\n\\n- **Import tool update**\\n\\n  - Optimized the user experience of the import tool to generate KCL, and added support for keywords oneOf and allOf.\\n\\n- **KCL Package Management Tool**\\n  - Released v0.6.0, which supports adding dependencies via git commit.\\n\\n**\ud83d\udcbb IDE Update**\\n\\n- **Semantic Highlighting**\\n\\n  - KCL IDE optimized semantic highlighting.\\n\\n- **Enhancement for Completion Features**\\n  - Fixed the completion error in nested schema definitions\\n  - Fixed the missing hover information\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @jakezhu9 for his continuous contribution to the kcl import tool \ud83e\udd1d\\n- Thanks to @AdmiralNemo, @Phillip Neumann, @Naxe, @steeling, etc. for their valuable feedback and suggestions in the use of KCL \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### KCL IDE Semantic Highlighting Enhancement\\n\\nKCL IDE previously only supported KCL syntax highlighting, as shown in the figure below:\\n\\n![](/img/blog/2024-01-18-biweekly-newsletter/old-ide.png)\\n\\nThis year, we gradually enabled the new KCL semantic architecture model. With the support of the new semantic architecture, KCL IDE supports semantic-level highlighting, and the code related to semantics will be highlighted in the same way.\\n\\n![](/img/blog/2024-01-18-biweekly-newsletter/new-ide.png)\\n\\nFor more information about the KCL semantic architecture model, please refer to:\\n\\n[Unlocking Advanced Code Intelligence with the KCL Semantic Model](https://kcl-lang.io/blog/2023-12-09-kcl-new-semantic-model)\\n\\n### KCL Package Management Tool Supports Adding Git Dependencies via Commit\\n\\nKCL Package Management Tool supports adding git dependencies via commit.\\nTake https://github.com/KusionStack/catalog as an example, add commit a29e3db as a dependency. You can add it directly through the dependency in the kcl.mod file or the command line.\\n\\nEdit the kcl.mod file as follows:\\n\\n```\\n[dependencies]\\ncatalog = { git = \\"https://github.com/KusionStack/catalog.git\\", commit = \\"a29e3db\\" }\\n```\\n\\nOr add it via the command line:\\n\\n```\\nkcl mod add --git https://github.com/KusionStack/catalog.git --commit a29e3db\\n```\\n\\n### KCL Import Tool Enhancement\\n\\nThe import tool supports the generation with oneOf and allOf keywords. Take the oneOf keyword as an example, save the following content in the file oneof.json.\\n\\n```json\\n{\\n  \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\",\\n  \\"$id\\": \\"https://example.com/schemas/book.json\\",\\n  \\"type\\": \\"object\\",\\n  \\"properties\\": {\\n    \\"title\\": {\\n      \\"type\\": \\"string\\"\\n    },\\n    \\"author\\": {\\n      \\"$comment\\": \\"oneOf for types\\",\\n      \\"oneOf\\": [\\n        {\\n          \\"type\\": \\"string\\"\\n        },\\n        {\\n          \\"type\\": \\"array\\",\\n          \\"items\\": {\\n            \\"type\\": \\"string\\"\\n          }\\n        },\\n        {\\n          \\"type\\": \\"integer\\"\\n        }\\n      ]\\n    },\\n    \\"category\\": {\\n      \\"$comment\\": \\"oneOf for objects\\",\\n      \\"oneOf\\": [\\n        {\\n          \\"type\\": \\"object\\",\\n          \\"properties\\": {\\n            \\"name\\": {\\n              \\"type\\": \\"string\\"\\n            }\\n          }\\n        },\\n        {\\n          \\"type\\": \\"object\\",\\n          \\"properties\\": {\\n            \\"title\\": {\\n              \\"type\\": \\"string\\"\\n            }\\n          }\\n        }\\n      ]\\n    }\\n  }\\n}\\n```\\n\\nThrough the import command, you can generate the corresponding KCL file.\\n\\n```\\nkcl import oneof.json\\n```\\n\\nYou can see that the generated oneof.k file content is as follows.\\n\\n```kcl\\n\\"\\"\\"\\nThis file was generated by the KCL auto-gen tool. DO NOT EDIT.\\nEditing this file might prove futile when you re-run the KCL auto-gen generate command.\\n\\"\\"\\"\\n\\nschema Book:\\n    r\\"\\"\\"\\n    Book\\n\\n    Attributes\\n    ----------\\n    title : str, optional\\n    author : str | [str] | int, optional\\n    category : BookCategoryOneOf0 | BookCategoryOneOf1, optional\\n    \\"\\"\\"\\n\\n    title?: str\\n    author?: str | [str] | int\\n    category?: BookCategoryOneOf0 | BookCategoryOneOf1\\n\\nschema BookCategoryOneOf0:\\n    r\\"\\"\\"\\n    BookCategoryOneOf0\\n\\n    Attributes\\n    ----------\\n    name : str, optional\\n    \\"\\"\\"\\n\\n    name?: str\\n\\nschema BookCategoryOneOf1:\\n    r\\"\\"\\"\\n    BookCategoryOneOf1\\n\\n    Attributes\\n    ----------\\n    title : str, optional\\n    \\"\\"\\"\\n\\n    title?: str\\n```\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.8.0 Milestone](https://github.com/kcl-lang/kcl/milestone/8)"},{"id":"2024-01-04-biweekly-newsletter","metadata":{"permalink":"/blog/2024-01-04-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2024-01-04-biweekly-newsletter/index.md","source":"@site/blog/2024-01-04-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 12.22 - 2024.01.04) | Crossplane KCL Integration","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2024-01-04T00:00:00.000Z","formattedDate":"January 4, 2024","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":6.09,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2024-01-04-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 12.22 - 2024.01.04) | Crossplane KCL Integration","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"KCL Biweekly Newsletter (2024 01.04 - 2024.01.18) | KCL v0.7.4 Released!","permalink":"/blog/2024-01-18-biweekly-newsletter"},"nextItem":{"title":"10 Ways for Kubernetes Declarative Configuration Management","permalink":"/blog/2023-12-25-ten-ways-for-kubernetes-config-management"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (12.22 2023 - 01.04 2024). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Toolchain Update**\\n\\n**Package Management Tool Update**\\n\\n- Adds support for automatic translation of external package names containing the - symbol to an underscore \\\\_ that KCL recognizes, such as set-annotation -> set_annotation\\n- Fixes a null pointer error caused when kcl mod add encounters a mismatch between the Registry package version and the version of the package already present locally\\n\\n**\ud83d\udcbb IDE Update**\\n\\n**Semantic Highlighting**\\n\\n- KCL IDE now supports semantic-level highlighting, avoiding differences in highlighting across various IDE plugins\\n\\n**Enhancement for Completion Features**\\n\\n- Differentiates between Schema type and instance completion symbols\\n- Unifies the format for Schema comment documentation completion\\n- Fixes inconsistencies in completion symbol types across different syntaxes\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @FLAGLORD, @YiuTerran, @flyinox, @steeling, @Anoop, @Phillip Neumann, and @Even Solberg for their valuable feedback and discussions during the promotion and usage of KCL \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### Using KCL to Write Crossplane Composition Functions\\n\\nCrossplane and its XRs allow developers to create higher-level abstractions that can encapsulate and compose multiple types of cloud resources across different providers and services. Using Composition Functions to render these abstractions can effectively enhance template capabilities for various provider resources while reducing the amount of YAML code needed.\\n\\nCombining KCL with Composition Functions offers several benefits:\\n\\n- **Simplification of Complex Configurations**: KCL provides a more concise syntax and structure as a DSL, reducing the complexity of configurations. When combined with Crossplane\u2019s composite resources, you can create more intuitive and easy-to-understand configuration templates with loop and condition features, simplifying the definition and maintenance of resources instead of duplicate YAML and Go code snippets.\\n- **Reusability and Modularity**: KCL supports modularity and code reuse through OCI Registry, which means you can create reusable configuration components. Combined with Crossplane, this promotes the modularity of composite resources, increases the reuse of configurations, and reduces errors.\\n- **Automation and Policy-Driven**: You can use KCL\u2019s powerful features to write policies and constraints that, combined with Crossplane\u2019s declarative resource management, can be automatically enforced, ensuring compliance within the cloud environment.\\n\\nAdditionally, you can refer to [here](https://kcl-lang.io/docs/user_docs/getting-started/intro#how-to-choose) to learn about the differences between KCL and other configuration formats or DSLs.\\n\\n#### Prerequisites\\n\\n- Prepare a Kubernetes cluster\\n- Install Kubectl\\n- Install [Crossplane and Crossplane CLI 1.14+](https://docs.crossplane.io/)\\n- Install Go 1.21+\\n\\n#### Quick Start\\n\\nLet\u2019s write a KCL function abstraction which generates managed resources `VPC` and `InternetGateway` with an input resource `Network`.\\n\\n##### 1. Install the Crossplane KCL Function\\n\\nInstalling a function creates a function pod. The function logic is processed as a pipeline step in a composition that may create managed resources when triggered through specified parameters.\\n\\nInstall a Function with a Crossplane Function object setting the `spec.package` value to the location of the function package.\\n\\n```bash\\nkubectl apply -f- << EOF\\napiVersion: pkg.crossplane.io/v1beta1\\nkind: Function\\nmetadata:\\n  name: kcl-function\\nspec:\\n  package: docker.io/kcllang/crossplane-kcl\\nEOF\\n```\\n\\n##### 2. Apply the Composition Resource\\n\\nYou can apply the composition resource with the inline KCL code into the cluster.\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: apiextensions.crossplane.io/v1\\nkind: Composition\\nmetadata:\\n  name: xlabels.fn-demo.crossplane.io\\n  labels:\\n    provider: aws\\nspec:\\n  writeConnectionSecretsToNamespace: crossplane-system\\n  compositeTypeRef:\\n    apiVersion: fn-demo.crossplane.io/v1alpha1\\n    kind: XNetwork\\n  mode: Pipeline\\n  pipeline:\\n  - step: normal\\n    functionRef:\\n      name: kcl-function\\n    input:\\n      apiVersion: krm.kcl.dev/v1alpha1\\n      kind: KCLRun\\n      metadata:\\n        name: basic\\n      spec:\\n        # Generate new resources\\n        target: Resources\\n        # OCI, Git or inline source\\n        # source: oci://ghcr.io/kcl-lang/crossplane-xnetwork-kcl-function\\n        # source: github.com/kcl-lang/modules/crossplane-xnetwork-kcl-function\\n        source: |\\n          # Get the XR spec fields\\n          id = option(\\"params\\")?.oxr?.spec.id or \\"\\"\\n          # Render XR to crossplane managed resources\\n          network_id_labels = {\\"networks.meta.fn.crossplane.io/network-id\\" = id} if id else {}\\n          vpc = {\\n              apiVersion = \\"ec2.aws.upbound.io/v1beta1\\"\\n              kind = \\"VPC\\"\\n              metadata.name = \\"vpc\\"\\n              metadata.labels = network_id_labels\\n              spec.forProvider = {\\n                  region = \\"eu-west-1\\"\\n                  cidrBlock = \\"192.168.0.0/16\\"\\n                  enableDnsSupport = True\\n                  enableDnsHostnames = True\\n              }\\n          }\\n          gateway = {\\n              apiVersion = \\"ec2.aws.upbound.io/v1beta1\\"\\n              kind = \\"InternetGateway\\"\\n              metadata.name = \\"gateway\\"\\n              metadata.labels = network_id_labels\\n              spec.forProvider = {\\n                  region = \\"eu-west-1\\"\\n                  vpcIdSelector.matchControllerRef = True\\n              }\\n          }\\n          items = [vpc, gateway]\\nEOF\\n```\\n\\n##### 3. Create Crossplane XRD\\n\\nWe define a schema using the crossplane XRD for the input resource `Network`, it has a field named `id` which denotes the network id.\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: apiextensions.crossplane.io/v1\\nkind: CompositeResourceDefinition\\nmetadata:\\n  name: xnetworks.fn-demo.crossplane.io\\nspec:\\n  group: fn-demo.crossplane.io\\n  names:\\n    kind: XNetwork\\n    plural: xnetworks\\n  claimNames:\\n    kind: Network\\n    plural: networks\\n  versions:\\n    - name: v1alpha1\\n      served: true\\n      referenceable: true\\n      schema:\\n        openAPIV3Schema:\\n          type: object\\n          properties:\\n            spec:\\n              type: object\\n              properties:\\n                id:\\n                  type: string\\n                  description: ID of this Network that other objects will use to refer to it.\\n              required:\\n                - id\\nEOF\\n```\\n\\n##### 4. Apply the Crossplane XR\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: fn-demo.crossplane.io/v1alpha1\\nkind: Network\\nmetadata:\\n  name: network-test-functions\\n  namespace: default\\nspec:\\n  id: network-test-functions\\nEOF\\n```\\n\\n##### 5. Verify the Generated Managed Resources\\n\\n- VPC\\n\\n```shell\\nkubectl get VPC -o yaml | grep network-id\\n      networks.meta.fn.crossplane.io/network-id: network-test-functions\\n```\\n\\n- InternetGateway\\n\\n```shell\\nkubectl get InternetGateway -o yaml | grep network-id\\n      networks.meta.fn.crossplane.io/network-id: network-test-functions\\n```\\n\\nIt can be seen that we have indeed successfully generated `VPC` and `InternetGateway` resources, and their fields meet expectations.\\n\\n##### 6. Debugging KCL Functions Locally\\n\\nSee [here](https://github.com/crossplane-contrib/function-kcl) for more information and examples.\\n\\n#### Client Enhancements\\n\\nIt can be seen that the above abstract code often requires a crossplane as a control plane intermediary, and you can still complete the abstraction in a fully client-side manner and directly generate crossplane managed resources to reduce the burden on the cluster.\\n\\nOn the client side, there are two methods to render managed resources. One method is to use the `crossplane beta render` command, and the other is to render directly using the `kcl run` command. The usage for the former can be found here. For the latter, the usage is as follows.\\n\\n```shell\\nkcl run oci://ghcr.io/kcl-lang/crossplane-xnetwork-kcl-function -S items -D params=\'{\\"oxr\\": {\\"spec\\": {\\"id\\": \\"network-test-functions\\"}}}\'\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: ec2.aws.upbound.io/v1beta1\\nkind: VPC\\nmetadata:\\n  name: vpc\\n  labels:\\n    networks.meta.fn.crossplane.io/network-id: network-test-functions\\nspec:\\n  forProvider:\\n    region: eu-west-1\\n    cidrBlock: 192.168.0.0/16\\n    enableDnsSupport: true\\n    enableDnsHostnames: true\\n---\\napiVersion: ec2.aws.upbound.io/v1beta1\\nkind: InternetGateway\\nmetadata:\\n  name: gateway\\n  labels:\\n    networks.meta.fn.crossplane.io/network-id: network-test-functions\\nspec:\\n  forProvider:\\n    region: eu-west-1\\n    vpcIdSelector:\\n      matchControllerRef: true\\n```\\n\\nBoth methods require a registry (usually docker.io) to assist in completing the work. The ultimate choice between them may depend on your operational habits and environmental costs. Regardless of the method chosen, we recommend maintaining your KCL code in Git to better implement GitOps and obtain a better IDE experience and reusable modules such as the [Crossplane AWS Provider Modules](https://github.com/kcl-lang/modules/tree/main/crossplane-provider-aws).\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.8.0 Milestone](https://github.com/kcl-lang/kcl/milestone/8)"},{"id":"2023-12-25-ten-ways-for-kubernetes-config-management","metadata":{"permalink":"/blog/2023-12-25-ten-ways-for-kubernetes-config-management","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-25-ten-ways-for-kubernetes-config-management/index.md","source":"@site/blog/2023-12-25-ten-ways-for-kubernetes-config-management/index.md","title":"10 Ways for Kubernetes Declarative Configuration Management","description":"Kubernetes has become the de facto standard for managing containerized applications. However, with its widespread adoption, the complexity of managing its configuration has also increased. To address this complexity, Kubernetes\' declarative configuration management model has emerged to simplify this process. In this article, we will explore what Kubernetes declarative configuration is, why it is necessary, and the various ways it can be managed.","date":"2023-12-25T00:00:00.000Z","formattedDate":"December 25, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Landscape","permalink":"/blog/tags/landscape"}],"readingTime":15.36,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-12-25-ten-ways-for-kubernetes-config-management","title":"10 Ways for Kubernetes Declarative Configuration Management","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Configuration","Landscape"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 12.22 - 2024.01.04) | Crossplane KCL Integration","permalink":"/blog/2024-01-04-biweekly-newsletter"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 12.07 - 12.21) | KCL v0.7.2 is released and KubeVela/OAM integration is available now!","permalink":"/blog/2023-12-21-biweekly-newsletter"}},"content":"![](/img/blog/2023-12-25-ten-ways-for-kubernetes-config-management/cover.png)\\n\\nKubernetes has become the de facto standard for managing containerized applications. However, with its widespread adoption, the complexity of managing its configuration has also increased. To address this complexity, Kubernetes\' declarative configuration management model has emerged to simplify this process. In this article, we will explore what Kubernetes declarative configuration is, why it is necessary, and the various ways it can be managed.\\n\\n## What is Kubernetes Declarative Configuration\\n\\nKubernetes declarative configuration refers to the practice of declaring the desired state of applications and their resources in Kubernetes manifest files. Rather than issuing imperative commands to change the state of the cluster, it\'s easier to simply describe the expected state and let Kubernetes strive to match the actual state to the declared state. Specifically, in the declarative API, you describe \\"what\\" you want (for example, a Pod running a specific image) rather than a series of operations to achieve a certain target state (\\"how\\" to achieve it). This model simplifies system interactions because users only need to focus on the end goal without handling the specific steps to achieve it.\\n\\nKubernetes\' declarative APIs are typically utilized through manifest files in YAML or JSON format. These files define the desired state of Kubernetes resources such as Pods, Services, Deployments, ConfigMaps, etc. Users submit these manifest files to the Kubernetes API server, which then has its control plane components, like controllers and schedulers, enforce these specifications and ensure that the actual state of the cluster matches them.\\n\\nDeclarative APIs support version control, automated deployment, rollback, scaling, and self-healing features, which significantly enhance the capability to manage large-scale, distributed systems. For example, if you want to deploy an application, you don\'t need to tell Kubernetes how to create each Pod, how to schedule them on nodes, or how to manage their lifecycle. Instead, you simply create a resource object like a Deployment, define the desired number of replicas and other attributes of the application containers, and then leave it to Kubernetes to handle. Kubernetes will monitor the state of this Deployment and take necessary actions to maintain or restore the desired state.\\n\\nThis declarative model elevates the system\'s level of abstraction, allowing developers and operators to focus on the application\'s behavior and requirements rather than the underlying operational commands and processes. As organizations adopt Kubernetes for large-scale application deployment, managing complex configurations and manifests becomes critical.\\n\\n## What are the Ways to Manage Kubernetes Declarative Configuration\\n\\n### Structured Key-Value Pair\\n\\nStructured key-value pair meets the minimum data declaration requirements (int, string, list, dict, etc.). Declarative API meets the development demands of X as Data with the rapid development and application of cloud-native technology. Machine-readable and writable, human-readable.\\n\\n- Pros.\\n  - Simple syntax, easy to write and read.\\n  - Rich multilingual APIs.\\n  - Various path tools for data query, such as XPath, JsonPath, etc.\\n- Cons.\\n  - Too much redundant information: when the configuration scale is large, it is difficult to maintain the configuration, because important configuration information is hidden in a large number of irrelevant repetitive data details.\\n  - Lack of functionality: constraint, complex logic, test, debug, abstraction, etc.\\n  - [Kustomize](https://kustomize.io/)\'s patches are basically by fixing several patch merge strategies\\n\\nRepresentative technologies of structured KV include:\\n\\n- JSON/YAML: It is very convenient for reading and automation, and has different languages API support.\\n- [Kustomize](https://kustomize.io/): It provides a solution to customize the Kubernetes resource base configuration and differential configuration without **template** and **DSL**. It does not solve the constraint problem itself, but needs to cooperate with a large number of additional tools to check constraints, such as [Kube-linter](https://github.com/stackrox/kube-linter), [Checkov](https://github.com/bridgecrewio/checkov) and [kubescape](https://github.com/kubescape/kubescape).\\n\\n### Templated Key-Value Pair\\n\\nThe Templated KV has the capability of static configuration data and dynamic parameters, and can output different static configuration data with one template+dynamic parameters. The advantages and disadvantages are as follows:\\n\\n- Pros.\\n  - Simple configuration logic and loop support.\\n  - External dynamic parameter support.\\n- Cons.\\n  - It is easy to fall into the trap that all configurations are template parameters.\\n  - When the configuration scale becomes larger, it is difficult for developers and tools to maintain and analyze them.\\n\\nRepresentative technologies of templated KV include:\\n\\n- [Helm](https://helm.sh/): The package management tool of Kubernetes resources, which manages the configuration of Kubernetes resources through the configuration template.\\n- [Helmfile](https://github.com/helmfile/helmfile): Helmfile is a declarative tool used to assist users in configuring and managing Helm charts running in Kubernetes clusters. Besides, Helmfile extends the functionality of Helm, making it easier and more repeatable to manage multiple Helm charts.\\n- Other configuration templates: Java Velocity, Go Template and other text template engines are very suitable for HTML writing templates. However,when used in configuration scenarios, they are difficult for developers and tools to maintain and analyze.\\n\\n### Programmable Key-Value Pair\\n\\n`Configuration as Code (CaC)` uses code to generate configuration, just like engineers only need to write advanced GPL code, rather than manually writing error-prone and difficult-to-understand server binary code.\\n\\n- Configuration changes are treated as seriously as code changes, and unit tests and integration tests can also be executed.\\n- Code modularization is a key reason why maintaining configuration code is easier than manually editing configuration files such as JSON/YAML.\\n\\n- Capability\\n  - Necessary programming language abilities (variable definitions, logical judgments, loops, assertions, etc.).\\n  - Necessary template capability, which supports the definition of data templates and the use of templates to obtain new configuration data.\\n  - Code modularity: structure definition and package management.\\n  - Machine-readable and writable, human-readable and writable.\\n- Pros.\\n  - Necessary programming ability.\\n  - Code modularization and abstraction.\\n  - Configuration template and override ability.\\n- Cons.\\n  - Insufficient type check.\\n  - Insufficient constraint capacity.\\n  - Many runtime errors.\\n\\nRepresentative technologies of programmable KV include:\\n\\n- [GCL](https://github.com/rix0rrr/gcl): A declarative configuration programming language implemented in Python provides the necessary language capabilities to support template abstraction. However, the compiler itself is written in Python, and the language itself is interpreted and executed. For large template instances (such as Kubernetes models), the performance is poor.\\n- [HCL](https://github.com/hashicorp/hcl): A Go implementation structured configuration language. The native syntax of HCL is inspired by libucl and nginx configurations. It is used to create a structured configuration language that is friendly to humans and machines, mainly for DevOps tools, server configurations, and resource configurations as a [Terraform language](https://www.terraform.io/language).\\n- [Jsonnet](https://github.com/google/jsonnet): A data template language implemented in C++, suitable for application and tool developers, can generate configuration data and organize, simplify and manage large configurations without side effects.\\n- [OPA](https://github.com/open-policy-agent/opa): While OPA is an open-source, general-purpose policy engine capable of enforcing unified and context-aware policies throughout the stack, it can also accept and output data in formats such as JSON, effectively functioning as a tool for generating or modifying configurations. Although it does not provide out-of-the-box schema definition support, it allows the integration of JsonSchema definitions.\\n- [Starlark](https://github.com/bazelbuild/starlark): Starlark is a language for describing build transformations, inspired by Python, but with features that make it suitable for embedding in software like Bazel. It can be used for configuration generation due to its capability for deterministic evaluation and expressing complex build transformations.\\n- [CEL](https://kubernetes.io/docs/reference/using-api/cel/): CEL is an expression language designed to be simple, fast, portable, and safe. While it is not directly a configuration language, CEL is used by Kubernetes as the foundation for complex field selection and filtering operations within its API. CEL can serve as a tool for validating and constraining configurations based on specific expressions.\\n\\n### Typed Key-Value Pair\\n\\n- Capability\\n  - Based on programmable K-V, typed K-V has more capabilities of type constraints.\\n- Pros.\\n  - The configuration merge is completely idempotent, which naturally prevents configuration conflicts.\\n  - Rich constraint syntax for writing configuration.\\n  - Abstract the type and value constraints into the same form, which is simple to write.\\n  - Configuration order independent.\\n- Cons.\\n  - The concepts of graph merging and idempotent merging are complex, and the understanding cost is high.\\n  - The mixed definition of type and value improves the degree of abstraction and the cost of understanding. All constraints are checked at runtime, and there is a performance bottleneck for the large-scale configuration code.\\n  - It is difficult to implement multi-tenant and multi-environment scenarios that want to configure coverage and modification.\\n  - For constrained scenarios with conditions, the user interface for writing hybrid definitions of definition and verification is unfriendly.\\n\\nRepresentative technologies of typed KV include:\\n\\n- [CUE](https://github.com/cue-lang/cue): The core problem CUE solves is \\"type checking\\", which is mainly used in configuration constraint verification scenarios and simple cloud native configuration scenarios.\\n- [Dhall](https://github.com/dhall-lang/dhall-lang): Dhall is a programmable configuration language that combines features like JSON, functions, types, and import capabilities. Its style leans towards functional programming, so if you\'re familiar with functional-style languages such as Haskell, you might find Dhall to be quite intuitive.\\n\\n### Modeled Key-Value Pair\\n\\n- Pros.\\n  - High-level language modeling capability as the core description\\n    - Modeling\\n    - Immutability\\n    - Constraints\\n  - High scalability through automatic merge mechanism of isolated config blocks.\\n  - Writing and testing methods like a high-level programming language.\\n  - Machine-readable and writable, human-readable and writable.\\n- Cons.\\n  - The expansion of new models and ecological construction requires certain R&D costs\\n\\nRepresentative technologies of modeled KV include:\\n\\n- [KCL](https://github.com/kcl-lang/kcl): A declarative configuration and policy programming language implemented by Rust, which improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionally.\\n- [Nickel](https://github.com/tweag/nickel)\uff1aNickel is a straightforward configuration language aimed at automatically generating static configuration files. Essentially, it\'s akin to JSON with the addition of functions and types.\\n\\nAdditionally, both KCL and Nickel feature a similar progressive typing system (static + dynamic), merging strategies, functions, and constraint definitions. The difference lies in the fact that KCL is a language similar to Python, whereas Nickel is more akin to JSON. Moreover, KCL offers a schema keyword to differentiate between configuration definitions and configuration data to prevent them from being mixed.\\n\\n### General-Purpose Languages and CDKs\\n\\nIn addition to defining Kubernetes resources using DSLs, we can also employ general-purpose languages for definition. However, general-purpose languages are typically overkill, as they go beyond what needs to be resolved, and they come with a variety of security concerns, such as capability boundaries (initiating local threads, accessing I/O, networking, code infinite loops, etc.), which can be unsafe. For instance, in the domain of music, there are specific musical notes used to represent music, which facilitate learning and communication in ways that cannot be clearly articulated by ordinary language.\\n\\nFurthermore, general-purpose languages, due to their diversity, come with the cost of unified maintenance, management, and automation. They are usually used to write client-side runtime code and are an extension of server-side runtime, making them unsuitable for writing configurations unrelated to runtime. These are ultimately compiled into binaries that start processes, and their stability and scalability are difficult to control. In contrast, configuration languages are typically used to write data, complemented by simple logic to describe the expected final outcome, which is then consumed by compilers or engines.\\n\\nRepresentative technologies for general-purpose languages and CDKs include:\\n\\n- [Pulumi](https://www.pulumi.com/docs/) - Pulumi enables the use of common programming languages such as TypeScript, Python, Go, and .NET to write code that defines and deploys cloud infrastructure and application services. Pulumi also supports YAML or DSLs that can be compiled into YAML, such as KCL.\\n- [CDK8s](https://cdk8s.io/) - CDK8s is used to define Kubernetes resources and applications. CDK8s uses the high-level abstraction concept called constructs to represent various Kubernetes resources such as deployments, services, and configurations. Developers can write code in programming languages like TypeScript, Python, and Java, and CDK8s will translate this code into standard Kubernetes YAML manifests that can be directly applied to a Kubernetes cluster.\\n\\n### Hybrid Structured and Programmable KV\\n\\nSome tools primarily employ structured KV for configuration management but also provide additional extensions to handle complex scenarios, eliminating the need for extensive YAML templating. For instance, some cloud-native tools offer function extensions that can be implemented in general-purpose languages such as Go, TypeScript, or DSLs like KCL.\\n\\n- [YTT](https://github.com/carvel-dev/ytt) - YTT is a templating tool that understands YAML structure. It helps you easily configure complex software via reusable templates and user provided values using the Starlark language.\\n- [KPT](https://kpt.dev/) - KPT and KPT Functions are used to decouple data and logic definitions, using a Git repository as the source of truth for configurations while managing Kubernetes configurations declaratively without losing extensibility.\\n- [Kustomize](https://kustomize.io/) - Similar to KPT, Kustomize and Kustomize Functions can also decouple data and logic definitions.\\n- [Crossplane](https://www.crossplane.io/) - Crossplane and Crossplane Composite Functions are used to decouple XR and Composite resource definitions. XRs allow developers to create higher-level abstractions that can encapsulate and compose multiple types of cloud resources across different providers and services. Using Crossplane Composite Functions to render these abstractions can effectively enhance template capabilities for various provider resources while reducing the amount of YAML code needed.\\n\\n### Client or Runtime Tools including Operators and Kubernetes CRDs\\n\\nKubernetes offers Mutation Webhooks and Validation Webhooks that can modify or validate Kubernetes resource objects at runtime before they are persisted.\\n\\nRepresentative technologies for Operators and Kubernetes CRDs include:\\n\\n- [KusionStack](https://kusionstack) - KusionStack is a modern application delivery and management toolchain that enables developers to specify desired intent in a declarative way and then using a consistent workflow to drive continuous deployment through application lifecycle. Besides, KusionStack provides cloud native operations, observable, and insightful resources that meet the K8s standard through `KusionStack Operation` and `Controller Mesh`\\n- [KubeVela](https://kubevela.io/docs/) - KubeVela is a modern application delivery system based on the Open Application Model (OAM) specification, providing developers and operation teams with a simplified and unified approach to deploying, managing, and operating applications.\\n- [Crossplane](https://www.crossplane.io/) - Crossplane is an open-source multicloud control plane that provides infrastructure as code capabilities on Kubernetes. Crossplane enables you to define XRDs and XRs to manage and compose cloud resources (such as databases, storage, and compute resources) directly from the Kubernetes API.\\n- [Radius](https://github.com/radius-project/radius) - Radius is a cloud-native, portable application platform that makes app development easier for teams building cloud-native apps.\\n- [KCL Operator](https://github.com/kcl-lang/kcl-operator) - KCL Operator brings programming capabilities to Kubernetes resource configurations at runtime based on the KCL language, utilizing the flexibility of DSL to avoid the complexity of developing Webhooks while integrating with KCL\'s existing [modules](https://github.com/kcl-lang/modules).\\n\\n### GitOps Tools\\n\\nGitOps is a system management practice that uses Git as the source of truth, storing the declarative descriptions of application deployment and infrastructure configuration in a Git repository. GitOps tools usually offer automated continuous deployment capabilities and ensure that the real-time state of the Kubernetes cluster matches the configuration in the Git repository. GitOps tools commonly provide native support or plugin integration with various Kubernetes configuration definition methods (structured, templated, programmable key-value pair, such as Kustomize, Helm, Jsonnet, KCL, etc.).\\n\\nRepresentative technologies for GitOps include:\\n\\n- [ArgoCD](https://argo-cd.readthedocs.io/en/stable/) - ArgoCD is a declarative GitOps continuous delivery tool used for automating Kubernetes configuration, monitoring, and management. It automates deployment and updates of applications and configurations by tracking changes in the Git repository. ArgoCD offers a visual interface along with extensive control and security features, and it supports various configuration management tools such as Helm, Kustomize, Jsonnet, etc.\\n- [FluxCD](https://fluxcd.io/) - FluxCD is another popular GitOps tool that allows developers to use a Git repository as the sole source of configuration. Flux automatically ensures that the state of the Kubernetes cluster is synchronized with the configuration in the Git repository. It supports automatic updates, meaning Flux can monitor Docker image repositories for new images and push updates to the cluster.\\n\\n### Infra from Code (IfC) Tools\\n\\nInfra from Code (IfC) is an approach to infrastructure management similar to IaC (Infrastructure as Code), where code defines and manages the underlying infrastructure, typically via code intent deduction rather than explicitly defining infrastructure code.\\n\\n- [Winglang](https://github.com/winglang/wing) - Winglang is a new cloud-oriented programming language that combines infrastructure and runtime code in one language, supporting multiple build targets such as AWS and Kubernetes. Additionally, Winglang provides built-in libraries for direct manipulation of containers and Helm Chart configurations.\\n- [Plutolang](https://github.com/pluto-lang/pluto) - Pluto is a new open-source programming language designed to help developers write cloud applications, making it easier to utilize cloud services. Developers can directly use required resources such as KV databases and message queues in their code based on business needs. Pluto uses static code analysis to obtain the infrastructure resource topology the application depends on and deploys the corresponding resource instances and applications on the specified cloud platform or Kubernetes.\\n\\n## Conclusion\\n\\nEach management approach has its specific advantages and applications. For simple projects, native Kubernetes YAML files and ConfigMaps may be all that\'s needed. For more complex projects that require stronger templating capabilities and package management, options like Helm or Kustomize might be chosen. If you need to handle configuration programmatically or integrate Kubernetes into a broader cloud infrastructure management system, Infrastructure as Code (IaC) tools such as Terraform and Pulumi, or DSLs like KCL and CUE, might be more suitable.\\n\\nGitOps tools offer a method of continuous deployment centered around Git. Meanwhile, Operators and CRDs allow users to customize and extend Kubernetes\' own capabilities to fit the needs of specific applications. These management methods are not mutually exclusive; in fact, in practical configuration management work, they are often complementary, and teams can choose and combine the tools and methods that best suit their specific needs.\\n\\nDo you know of other ways? Feel free to add. \u2764\ufe0f\\n\\n## Reference\\n\\n- Terraform Language: [https://www.terraform.io/language](https://www.terraform.io/language)\\n- Terraform Kubernetes Provider: [https://github.com/hashicorp/terraform-provider-kubernetes](https://github.com/hashicorp/terraform-provider-kubernetes)\\n- Terraform Provider AWS: [https://github.com/hashicorp/terraform-provider-aws](https://github.com/hashicorp/terraform-provider-aws)\\n- Pulumi: [https://www.pulumi.com/docs/](https://www.pulumi.com/docs/)\\n- Pulumi vs. Terraform: [https://www.pulumi.com/docs/intro/vs/terraform/](https://www.pulumi.com/docs/intro/vs/terraform/)\\n- Google SRE Work Book Configuration Design: [https://sre.google/workbook/configuration-design/](https://sre.google/workbook/configuration-design/)\\n- Google Borg Paper: [https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf)\\n- Holistic Configuration Management at Facebook: [https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf](https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf)\\n- JSON Spec: [https://www.json.org/json-en.html](https://www.json.org/json-en.html)\\n- YAML Spec: [https://yaml.org/spec/](https://yaml.org/spec/)\\n- GCL: [https://github.com/rix0rrr/gcl](https://github.com/rix0rrr/gcl)\\n- HCL: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)\\n- CUE: [https://github.com/cue-lang/cue](https://github.com/cue-lang/cue)\\n- KCL: [https://github.com/kcl-lang/kcl](https://github.com/kcl-lang/kcl)\\n- Nickel: [https://github.com/tweag/nickel](https://github.com/tweag/nickel)\\n- Jsonnet: [https://github.com/google/jsonnet](https://github.com/google/jsonnet)\\n- Dhall: [https://github.com/dhall-lang/dhall-lang](https://github.com/dhall-lang/dhall-lang)\\n- Thrift: [https://github.com/Thriftpy/thriftpy2](https://github.com/Thriftpy/thriftpy2)\\n- Kustomize: [https://kustomize.io/](https://kustomize.io/)\\n- YTT: [https://github.com/carvel-dev/ytt](https://github.com/carvel-dev/ytt)\\n- KPT: [https://kpt.dev/](https://kpt.dev/)\\n- Kube-linter: [https://github.com/stackrox/kube-linter](https://github.com/stackrox/kube-linter)\\n- Checkov: [https://github.com/bridgecrewio/checkov](https://github.com/bridgecrewio/checkov)\\n- How Terraform Works: A Visual Intro: [https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067](https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067)\\n- How Terraform Works: Modules Illustrated: [https://awstip.com/terraform-modules-illustrate-26cbc48be83a](https://awstip.com/terraform-modules-illustrate-26cbc48be83a)\\n- TFLint: [https://github.com/terraform-linters/tflint](https://github.com/terraform-linters/tflint)\\n- Helm: [https://helm.sh/](https://helm.sh/)\\n- Helm vs. Kustomize: [https://harness.io/blog/helm-vs-kustomize](https://harness.io/blog/helm-vs-kustomize)\\n- KubeVela: [https://kubevela.io/docs/](https://kubevela.io/docs/)\\n- Radius: [https://github.com/radius-project/radius](https://github.com/radius-project/radius)\\n- Crossplane: [https://www.crossplane.io/](https://www.crossplane.io/)\\n- ArgoCD: [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)\\n- FluxCD: [https://fluxcd.io/](https://fluxcd.io/)\\n- Helmfile: [https://helmfile.readthedocs.io/en/latest/](https://helmfile.readthedocs.io/en/latest/)\\n- CDK8s: [https://cdk8s.io/](https://cdk8s.io/)\\n- [Helm vs. Kustomize in Kubernetes](https://medium.com/@sushantkapare1717/helm-vs-kustomize-in-kubernetes-cc063bbb4b0e)\\n- Winglang: [https://github.com/winglang/wing](https://github.com/winglang/wing)\\n- Plutolang: [https://github.com/pluto-lang/pluto](https://github.com/pluto-lang/pluto)\\n- [Infrastructure as Code Landscape in 2023](https://blog.terramate.io/infrastructure-as-code-landscape-in-2023-e2dad4fb87d3)"},{"id":"2023-12-21-biweekly-newsletter","metadata":{"permalink":"/blog/2023-12-21-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-21-biweekly-newsletter/index.md","source":"@site/blog/2023-12-21-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 12.07 - 12.21) | KCL v0.7.2 is released and KubeVela/OAM integration is available now!","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-12-21T00:00:00.000Z","formattedDate":"December 21, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":4.45,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-12-21-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 12.07 - 12.21) | KCL v0.7.2 is released and KubeVela/OAM integration is available now!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"10 Ways for Kubernetes Declarative Configuration Management","permalink":"/blog/2023-12-25-ten-ways-for-kubernetes-config-management"},"nextItem":{"title":"How to Apply KCL Configuration to Cluster","permalink":"/blog/2023-12-19-how-to-apply-kcl-config-to-cluster"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (11.24 - 12.07 2023). Here is an overview of the key content:\\n\\n**\ud83d\udce6 Model Updates**\\n\\nKCL model quantity increased to **300**, added KCL models for k8s 1.29.\\n\\n**\ud83d\udd27 Toolchain Updates**\\n\\n- **Import Tool Updates**\\n\\n  - Import tool supports OpenAPI allOf keyword validation expression generation\\n  - Import tool supports KCL array and dictionary type all/any validation expression generation\\n  - Import tool fixes JSON Schema array generation KCL code snippet error and string escape error\\n\\n- **\ud83c\udfc4 Package Management Tool Updates**\\n  - Added support for third-party libraries with hyphens in their names.\\n  - Fixed the problem that the update function cannot automatically pass kcl.mod and kcl.mod.lock.\\n\\n**\ud83d\udcbb KCL Updates**\\n\\n- KCL compilation cache path supports using environment variables KCL_CACHE_PATH to specify\\n- Fixed the compilation error that may be caused by the compilation parameter -S of KCL CLI\\n- Fixed the error that kcl fmt tool adds an empty line at the end when formatting lambda expressions.\\n- Fixed Schema Doc completion code snippet error\\n\\n**\ud83d\udcd2 IDE Updates**\\n\\n- Fixed the problem that the variable completion in the check statement is invalid\\n- VSCode Extension updated to version 0.1.3, updated the highlighting and completion of some keywords\\n- Added completion of builtin functions\\n- Optimized the style of function completion\\n\\n## Featured Updates\\n\\n### Efficient Cloud Native Application Deployment - KCL and KubeVela Integration Quick Guide\\n\\n[KCL](https://kcl-lang.io) is a configuration and policy language for cloud-native scenarios, hosted by the CNCF Foundation. It aims to improve the writing of complex configurations, such as cloud-native Kubernetes configurations, using mature programming language techniques and practices. KCL focuses on building better modularity, scalability, and stability around configuration, as well as easier logic writing, automation, and integration with the toolchain.\\n\\nKCL exists in a completely open cloud-native world and is not tied to any orchestration/engine tools or Kubernetes controllers. It can provide API abstraction, composition, and validation capabilities for both Kubernetes clients and runtime.\\n\\n[KubeVela](https://kubevela.net/) is a modern application delivery system hosted by the CNCF Foundation. It is built on the Open Application Model (OAM) specification and aims to abstract the complexity of Kubernetes, providing a set of simple and easy-to-use command-line tools and APIs for developers to deploy and operate cloud-native applications without worrying about the underlying details.\\n\\nUsing KCL with KubeVela has the following benefits:\\n\\n- **Simpler configuration**: KCL provides stronger templating capabilities, such as conditions and loops, for KubeVela OAM configurations at the client level, reducing the need for repetitive YAML writing. At the same time, the reuse of KCL model libraries and toolchains enhances the experience and management efficiency of configuration and policy writing.\\n- **Better maintainability**: KCL provides a configuration file structure that is more conducive to version control and team collaboration, instead of relying solely on YAML. When combined with OAM application models written in KCL, application configurations become easier to maintain and iterate.\\n- **Simplified operations**: By combining the simplicity of KCL configurations with the ease of use of KubeVela, daily operational tasks such as deploying, updating, scaling, or rolling back applications can be simplified. Developers can focus more on the applications themselves rather than the tedious details of the deployment process.\\n- **Improved cross-team collaboration**: By using KCL\'s configuration chunk writing and package management capabilities in conjunction with KubeVela, clearer boundaries can be defined, allowing different teams (such as development, testing, and operations teams) to collaborate systematically. Each team can focus on tasks within their scope of responsibility, delivering, sharing, and reusing their own configurations without worrying about other aspects.\\n\\nTaking the KCL Playground application (written in Go and HTML5) as an example, we use KCL to define the OAM configuration that needs to be deployed. The overall workflow is as follows:\\n\\n- Prepare\\n\\n  - Configure the Kubernetes cluster\\n  - Install KubeVela\\n  - Install KCL\\n\\n- New project and add OAM dependency\\n\\n```\\nkcl mod init kcl-play-svc && cd kcl-play-svc && kcl mod add oam\\n```\\n\\n- Write code in main.k\\n\\n```\\nimport oam\\n\\noam.Application {\\n    metadata.name = \\"kcl-play-svc\\"\\n    spec.components = [{\\n        name = metadata.name\\n        type = \\"webservice\\"\\n        properties = {\\n            image = \\"kcllang/kcl\\"\\n            ports = [{port = 80, expose = True}]\\n            cmd = [\\"kcl\\", \\"play\\"]\\n        }\\n    }]\\n}\\n```\\n\\n- Run command to deploy configuration\\n\\n```\\nkcl run | vela up -f -\\n```\\n\\n- Port forwarding\\n\\n```\\nvela port-forward kcl-play-svc\\n```\\n\\nThen we can see the KCL Playground application running successfully in the browser\\n\\n![kcl-play-svc](/img/blog/2023-12-15-kubevela-integration/kcl-play-svc.png)\\n\\n### IDE Optimized the Style of Function Completion\\n\\n![ide-func](/img/blog/2023-12-21-biweekly-newsletter/ide-func.gif)\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.8.0 Milestone](https://github.com/kcl-lang/kcl/milestone/8)"},{"id":"2023-12-19-how-to-apply-kcl-config-to-cluster","metadata":{"permalink":"/blog/2023-12-19-how-to-apply-kcl-config-to-cluster","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-19-how-to-apply-kcl-config-to-cluster/index.md","source":"@site/blog/2023-12-19-how-to-apply-kcl-config-to-cluster/index.md","title":"How to Apply KCL Configuration to Cluster","description":"What is KCL","date":"2023-12-19T00:00:00.000Z","formattedDate":"December 19, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KubeVela","permalink":"/blog/tags/kube-vela"}],"readingTime":3.085,"hasTruncateMarker":false,"authors":[{"name":"KCL Team Member","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-12-19-how-to-apply-kcl-config-to-cluster","title":"How to Apply KCL Configuration to Cluster","authors":{"name":"KCL Team Member","title":"KCL Team Member"},"tags":["KCL","KubeVela"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 12.07 - 12.21) | KCL v0.7.2 is released and KubeVela/OAM integration is available now!","permalink":"/blog/2023-12-21-biweekly-newsletter"},"nextItem":{"title":"Cloud Native Configuration and Policy Language - KCL","permalink":"/blog/2023-12-18-cloud-native-configuration-language-kcl"}},"content":"## What is KCL\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. It is hosted by the Cloud Native Computing Foundation (CNCF) as a Sandbox Project. With advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\n## Several Ways to Deploy KCL Configuration to a cluster\\n\\n![cloud-native-tool-integration](/img/blog/2023-12-19-how-to-apply-kcl-config-to-cluster/cloud-native-tool-integration.png)\\n\\nSince KCL can output YAML/JSON files, theoretically, any method that supports deploying YAML/JSON configurations to a cluster can be used to deploy KCL configurations. Usually, KCL files are stored in Git or Module Registry for easy sharing among different roles and teams. However, KCL can do much more than that, and the main ways to deploy KCL configurations to a cluster are as follows.\\n\\n- **Using kubectl**: The most basic way to access a Kubernetes cluster is using Kubectl. We can directly deploy the Kubernetes YAML configuration files generated by KCL to the cluster using the kubectl apply command. This method is simple and suitable for deploying a small number of resources.\\n- **Using CI/CD tools**: CI/CD tools (such as Jenkins, GitLab CI, CircleCI, ArgoCD, FluxCD, etc.) can be used to achieve GitOps automation deployment of Kubernetes YAML configuration files to the cluster. By defining CI/CD processes and configuration files, automated building and deployment to the cluster can be achieved.\\n- **Using tools that support KRM Function specification**: Kubernetes Resource Model (KRM) Function allows users to use other languages, including KCL, to enhance YAML template and logic writing capabilities, such as writing conditions, loops, etc. These tools mainly include Kustomize, KPT, Crossplane, etc. Although Helm does not natively support KRM Function, we can combine Helm and Kustomize to achieve it.\\n- **Using client/runtime custom abstract configuration tools for deployment**: KusionStack, KubeVela, etc. Of course, KCL allows you to customize your preferred application configuration model.\\n- **Using KCL Operator** with Kubernetes Mutation Webhook and Validation Webhook support for runtime configuration or policy writing.\\n- **Using configuration management tools**: Combine configuration management tools (such as Puppet, Chef, Ansible, etc.) to automate the deployment of Kubernetes YAML configurations to the cluster. These tools can achieve dynamic configuration deployment by defining KCL templates and variables.\\n\\nThe reasons for KCL supporting multiple deployment methods and cloud-native tool integration are as follows:\\n\\n- **Flexibility**: Different deployment methods are suitable for different scenarios and needs, so providing multiple choices allows users to choose the most suitable way to deploy applications or configurations according to their specific situations.\\n- **Cloud-native tool ecosystem**: Kubernetes is a widely used platform with a large ecosystem of tools and technologies. Supporting multiple deployment methods can provide users with more choices to meet their usage habits and technological preferences.\\n- **Specifications and standards**: The Kubernetes community is working to promote standards and specifications, such as OAM, KRM Function specifications, and Helm Charts. By providing multiple support methods through a unified KRM KCL specification and KCL Module, different specification and standard requirements can be met.\\n- **Automation and integration**: Some deployment methods can be integrated through automation tools and CI/CD pipelines to achieve automated deployment processes. Therefore, providing multiple ways can meet different automation and integration needs.\\n\\nIn conclusion, supporting multiple deployment methods can provide users with greater flexibility and choice, allowing them to deploy applications or configurations according to their needs and preferences. The specific usage of each deployment method is as follows:\\n\\n### Using Kubectl\\n\\nhttps://kcl-lang.io/blog/2023-11-20-search-k8s-module-on-artifacthub\\n\\n### Using CI/CD Tools\\n\\nhttps://kcl-lang.io/blog/2023-07-31-kcl-github-argocd-gitops\\n\\n### Using KRM Function\\n\\nhttps://kcl-lang.io/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec\\n\\n### Using Custom Abstract Configuration Tools\\n\\nhttps://kcl-lang.io/blog/2023-12-15-kubevela-integration\\n\\n### Using KCL Operator\\n\\nhttps://kcl-lang.io/docs/user_docs/guides/working-with-k8s/mutate-manifests/kcl-operator\\n\\n### Using Configuration Management Tools\\n\\nhttps://github.com/kcl-lang/kcl/issues/952"},{"id":"2023-12-18-cloud-native-configuration-language-kcl","metadata":{"permalink":"/blog/2023-12-18-cloud-native-configuration-language-kcl","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-18-cloud-native-configuration-language-kcl/index.md","source":"@site/blog/2023-12-18-cloud-native-configuration-language-kcl/index.md","title":"Cloud Native Configuration and Policy Language - KCL","description":"This blog is a review of the content of the KCL language part of the speech at the 2023 CNCF KCD ShenZhen meeting by KusionStack leader Dayuan Li and KCL project Maintainer Zhe Zong. The main content of this article is a review of the content of the KCL language part of the speech, the activity link//community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-shenzhen-2023/","date":"2023-12-18T00:00:00.000Z","formattedDate":"December 18, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":7.075,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-12-18-cloud-native-configuration-language-kcl","title":"Cloud Native Configuration and Policy Language - KCL","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"How to Apply KCL Configuration to Cluster","permalink":"/blog/2023-12-19-how-to-apply-kcl-config-to-cluster"},"nextItem":{"title":"KCL && KusionStack Introduction at CNCF KCD ShenZhen 2023 Meeting","permalink":"/blog/2023-12-18-kcl-kcd-shenzhen-meeting"}},"content":"> This blog is a review of the content of the KCL language part of the speech at the 2023 CNCF KCD ShenZhen meeting by KusionStack leader Dayuan Li and KCL project Maintainer Zhe Zong. The main content of this article is a review of the content of the KCL language part of the speech, the activity link: [https://community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-shenzhen-2023/](https://community.cncf.io/events/details/cncf-kcd-shenzhen-presents-kcd-shenzhen-2023/)\\n\\n## In the cloud-native era, infrastructure as code (IaC) is the core of developer experience\\n\\nIn today\'s rapidly developing technical world, infrastructure as code (IaC) has become the key to automating and managing cloud resources, and IaC has also become the core part of developer experience, bringing convenience and efficiency, but it also brings a series of challenges.\\n\\n![intro-iac-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/intro-iac-en.png)\\n\\nFirst of all, application developers need to face the complex infrastructure and platform concepts provided by k8s, which has caused a high cognitive burden and affected the software delivery experience of higher-level application developers.\\n\\nTherefore, we urgently need a way to reduce the cognitive burden of developers, provide efficient dynamic configuration management, and ensure the reliability of configuration through standard configuration testing and verification methods to ensure the efficiency and security of infrastructure.\\n\\n## Cloud Native Configuration and Policy Language - KCL\\n\\nSo we tried to design a new configuration language KCL to solve many of the problems mentioned above by designing the language syntax and enhancing the surrounding tools.\\n\\n![intro-kcl-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/intro-kcl-en.png)\\n\\nKCL language starts from the three aspects of **dynamic configuration management**, **configuration reliability verification and testing** and **reducing developer cognitive burden** mentioned above. We propose three main design concepts, **Mutation**, **Validation** and **Abstraction**, and we also use these three design concepts as the core slogan of KCL homepage.\\n\\nAround the three design concepts, KCL has done some design on the language syntax:\\n\\n- To use KCL for dynamic configuration management, the language side needs to provide syntaxes such as flow control and lambda expressions that can describe program behavior.\\n- To do configuration reliability related verification and testing: you need to give this language the ability to check the configuration content through a strong type system, assert, check and other syntaxes to support the testing and verification process.\\n- To reduce developer cognitive burden and development cost: KCL provides a `Schema` model to abstract the data structure. For developers, it shields unnecessary fields, and provides rich third-party library resources through the package management mechanism, reducing the cost of developers directly writing models.\\n\\n## KCL language features\\n\\nI have listed some small code snippets that can reflect the language features in the ppt:\\n\\n![kcl-feature-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-feature-en.png)\\n\\nAt first, the leftmost picture shows the flow control, lambda expression, and python-style loop expression that are similar to general-purpose programming languages. Then, the middle picture shows the assert statement provided for verification and testing, and the check block of the schema. Through the strategy written in check, the fields in the schema can be checked. Finally, the rightmost picture is to use the schema to define the data structure and instantiate the configuration. And you can see that in this example, the strong type system of KCL has also demonstrated the ability to check the configuration type. If the type of a field is written incorrectly in the process of instantiating the configuration using the schema, the error will be checked at the compilation stage. The last picture is to use the third-party library of k8s to create an nginx pod. Some unnecessary fields have been shielded, and the application developer only needs to fill in a few fields to complete the configuration writing.\\n\\n## KCL & KRM & Dynamic Configuration Management\\n\\nKCL provides some dynamic behaviors such as check, assert statements, type system, Schema abstraction, etc. However, when we try to use the above features for configuration management, we find that the language features of KCL alone are not enough. To solve the problems in the IaC field, we must also consider the stock configuration. It is obviously not a suitable way to push down all the stock configurations and use KCL to rebuild them, and it cannot be realized.\\n\\nTherefore, in addition to working on language mechanisms, we also need to have the ability to integrate with the community ecology to make the role of KCL language features play on other configuration languages, so that KCL can truly solve the problems in the IaC field. Under the premise of minimizing the changes to the stock configuration, give full play to the role of KCL language features, and solve the problems of dynamic configuration, reliability verification, and reducing the cognitive burden of developers.\\n\\n![kcl-krm-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-krm-en.png)\\n\\nTherefore, we proposed the [KCL KRM specification](https://github.com/kcl-lang/krm-kcl), based on this specification, we can use the capabilities of the KCL language to dynamically configure, verify and abstract the resources in KRM.\\n\\n## KCL Ecological Integration\\n\\nBased on the KCL & KRM specification, we have developed some peripheral tools to better integrate KCL with the surrounding tool ecology.\\n\\n![kcl-integration-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-integration-en.png)\\n\\n- Data structure import and export: KCL provides import/export tools, which support using KCL to import/export data structures from JsonSchema, Terraform, etc., to reduce the process of duplicating data modeling in the development process, and make KCL effect is applied to stock configuration.\\n- Plugins: KCL provides plugins for tools such as kubectl, kustomize, helm/helmfile, etc. Users can choose the appropriate engine such as Kubectl, KusionStack, KubeVela or Helmfile according to different scenarios to combine with KCL to make the configuration effective to the cluster.\\n- KCL Operator: Developed [KCL Operator](https://github.com/kcl-lang/kcl-operator) to integrate with Kubernetes, and automatically modify the configuration at runtime without the need to repeatedly develop Kubernetes Webhook to write a large amount of configuration processing logic.\\n\\nKCL is built in a completely open cloud-native world. KCL is almost not strongly bound to any orchestration/engineering tools, and can provide API abstraction, combination and verification capabilities for both clients and runtimes at the same time.\\n\\n## KCL Toolchain\\n\\nAlthough KCL is a domain language. KCL also provides a toolchain that is basically equivalent to the capabilities of general programming languages, such as formatting, testing, documentation , package management tools, etc. to help better write, understand and check the written configuration or strategy; through VS Code and other IDE plug-ins and Playground to reduce the cost of configuration writing and sharing; through Rust, Go, and Python multi-language SDK to automate the management and execution of configuration.\\n\\nFor IDE plug-ins, KCL currently mainly provides VS Code, IntelliJ and NeoVim. The three IDE plug-ins are based on the same KCL Language Server to implement the same capabilities such as completion, jump, hover, code refactoring, and formatting.\\n\\n![kcl-tools-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-tools-en.png)\\n\\n## **Artifacthub & KCL**\\n\\nKCL has been integrated with ArtifactHub, which is used as the model market of KCL, providing more than 200+ KCL models, covering multiple aspects such as configuration editing, verification and model abstraction. If you are interested, you can take a look at whether there are models you are interested in, or if you have good ideas to share with everyone, you can also contribute your KCL package to ArtifactHub.\\n\\n![kcl-ah-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-ah-en.png)\\n\\n## Some practical cases\\n\\nFinally, I will show some simple cases to of the use of KCL.\\n\\n![kcl-mut-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-mut-en.png)\\n\\nAt first, if the KCL Operator is installed in the cluster, then the configuration on the right can be mutated through the configuration file on the left. The behavior code is written in KCL in the source field, and the annotation is dynamically added to the configuration file on the right.\\n\\n![kcl-vet-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-vet-en.png)\\n\\nThen, in this case, the configuration content generated by terraform plan is verified using the configuration verification tool kcl-vet provided by KCL.\\n\\n![kcl-abs-en.png](/img/blog/2023-12-18-cloud-native-configuration-language-kcl/kcl-abs-en.png)\\n\\nFinally, in this case, the abstraction of the configuration is demonstrated. We can get the Kubernetes manifests by directly writing the KCL program, or by writing the configuration using KCL & KRM and compiling it into the corresponding Kubernetes manifests.\\n\\n## Summary\\n\\nKCL language is a domain language focusing on cloud-native configuration management. It provides a series of language features, such as strong type system, Schema abstraction, flow control, lambda expression, assert statement, check statement, etc., to solve the problems in the cloud-native configuration management field, such as dynamic configuration management, configuration reliability verification and testing, and reducing developer cognitive burden. At the same time, KCL also provides a series of peripheral tools, such as IDE plug-ins, ArtifactHub integration, KCL Operator, etc., to improve the development experience of developers and reduce development costs.\\n\\n## Other Resources\\n\\nFor more information about KCL, please refer to:\\n\\n- [KCL HomePage](https://kcl-lang.io/)\\n- [KCL GitHub Repo](https://github.com/kcl-lang/)\\n- [KusionStack HomePage](https://kusionstack.io/)\\n- [KusionStack GitHub Repo](https://github.com/KusionStack/)"},{"id":"2023-12-18-kcl-kcd-shenzhen-meeting","metadata":{"permalink":"/blog/2023-12-18-kcl-kcd-shenzhen-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-18-kcl-kcd-shenzhen-meeting/index.md","source":"@site/blog/2023-12-18-kcl-kcd-shenzhen-meeting/index.md","title":"KCL && KusionStack Introduction at CNCF KCD ShenZhen 2023 Meeting","description":"Download PDF (Chinese)","date":"2023-12-18T00:00:00.000Z","formattedDate":"December 18, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-12-18-kcl-kcd-shenzhen-meeting","title":"KCL && KusionStack Introduction at CNCF KCD ShenZhen 2023 Meeting","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"Cloud Native Configuration and Policy Language - KCL","permalink":"/blog/2023-12-18-cloud-native-configuration-language-kcl"},"nextItem":{"title":"Efficient Cloud Native Application Deployment - KCL and KubeVela Integration Quick Guide","permalink":"/blog/2023-12-15-kubevela-integration"}},"content":"[Download PDF (Chinese)](https://kcl-lang.io/talks/kcl-cncf-kcd-shenzhen2023.pdf)\\n\\n![Talk Cover](/img/blog/2023-12-18-kcl-kcd-shenzhen-meeting/talk-cover.png)"},{"id":"2023-12-15-kubevela-integration","metadata":{"permalink":"/blog/2023-12-15-kubevela-integration","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-15-kubevela-integration/index.md","source":"@site/blog/2023-12-15-kubevela-integration/index.md","title":"Efficient Cloud Native Application Deployment - KCL and KubeVela Integration Quick Guide","description":"cover","date":"2023-12-15T00:00:00.000Z","formattedDate":"December 15, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"KubeVela","permalink":"/blog/tags/kube-vela"}],"readingTime":4.425,"hasTruncateMarker":false,"authors":[{"name":"KCL Team Member","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-12-15-kubevela-integration","title":"Efficient Cloud Native Application Deployment - KCL and KubeVela Integration Quick Guide","authors":{"name":"KCL Team Member","title":"KCL Team Member"},"tags":["KCL","KubeVela"]},"prevItem":{"title":"KCL && KusionStack Introduction at CNCF KCD ShenZhen 2023 Meeting","permalink":"/blog/2023-12-18-kcl-kcd-shenzhen-meeting"},"nextItem":{"title":"Unlocking Advanced Code Intelligence with the KCL Semantic Model","permalink":"/blog/2023-12-09-kcl-new-semantic-model"}},"content":"![cover](/img/blog/2023-12-15-kubevela-integration/cover.png)\\n\\n# Introduction\\n\\n[KubeVela](https://kubevela.net/) is a modern application delivery system hosted by the CNCF Foundation. It is built on the Open Application Model (OAM) specification and aims to abstract the complexity of Kubernetes, providing a set of simple and easy-to-use command-line tools and APIs for developers to deploy and operate cloud-native applications without worrying about the underlying details.\\n\\n[KCL](https://kcl-lang.io) is a configuration and policy language for cloud-native scenarios, hosted by the CNCF Foundation. It aims to improve the writing of complex configurations, such as cloud-native Kubernetes configurations, using mature programming language techniques and practices. KCL focuses on building better modularity, scalability, and stability around configuration, as well as easier logic writing, automation, and integration with the toolchain.\\n\\nKCL exists in a completely open cloud-native world and is not tied to any orchestration/engine tools or Kubernetes controllers. It can provide API abstraction, composition, and validation capabilities for both Kubernetes clients and runtime.\\n\\nUsers can choose suitable cloud-native tools such as Kubectl, Helm, Kustomize, KPT, KusionStack, KubeVela, Helmfile, Crossplane, or ArgoCD to combine with KCL and apply configurations to the cluster based on their specific scenarios.\\n\\n![integration](/img/blog/2023-12-15-kubevela-integration/integration.png)\\n\\nThis blog is the first in a series that explores the efficient deployment and operation of cloud-native applications using KCL and KubeVela together. We will share more advanced usage in future articles, so stay tuned.\\n\\n## Using KCL with KubeVela\\n\\nUsing KCL with KubeVela has the following benefits:\\n\\n- **Simpler configuration**: KCL provides stronger templating capabilities, such as conditions and loops, for KubeVela OAM configurations at the client level, reducing the need for repetitive YAML writing. At the same time, the reuse of KCL model libraries and toolchains enhances the experience and management efficiency of configuration and policy writing.\\n- **Better maintainability**: KCL provides a configuration file structure that is more conducive to version control and team collaboration, instead of relying solely on YAML. When combined with OAM application models written in KCL, application configurations become easier to maintain and iterate.\\n- **Simplified operations**: By combining the simplicity of KCL configurations with the ease of use of KubeVela, daily operational tasks such as deploying, updating, scaling, or rolling back applications can be simplified. Developers can focus more on the applications themselves rather than the tedious details of the deployment process.\\n- **Improved cross-team collaboration**: By using KCL\'s configuration chunk writing and package management capabilities in conjunction with KubeVela, clearer boundaries can be defined, allowing different teams (such as development, testing, and operations teams) to collaborate systematically. Each team can focus on tasks within their scope of responsibility, delivering, sharing, and reusing their own configurations without worrying about other aspects.\\n\\n## Workflow\\n\\n![workflow](/img/blog/2023-12-15-kubevela-integration/workflow.png)\\n\\nIn this example, we use the KCL Playground application (written in Go and HTML5) as an example and use KCL to define the OAM configuration that needs to be deployed. The overall workflow is as follows:\\n\\n- Application code development produces a Docker image.\\n- Write OAM configurations using KCL.\\n- Deploy configurations using KubeVela.\\n- Verify the running status of the application.\\n\\n## Specific Steps\\n\\n### 0. Prerequisites\\n\\n- Familiarize yourself with basic Unix/Linux commands.\\n- Familiarize yourself with using Git.\\n- Understand the basics of Kubernetes.\\n- Understand KubeVela.\\n- Understand the basics of KCL.\\n\\n### 1. Configure the Kubernetes Cluster\\n\\nInstall [K3d](https://github.com/k3d-io/k3d) and create a cluster.\\n\\n```shell\\nk3d cluster create\\n```\\n\\n> Note: You can use other methods to create your own Kubernetes cluster, such as kind, minikube, etc., in this scenario.\\n\\n### 2. Install KubeVela\\n\\n- Install the KubeVela CLI.\\n\\n```shell\\ncurl -fsSl https://kubevela.net/script/install.sh | bash\\n```\\n\\n- Install KubeVela Core.\\n\\n```shell\\nvela install\\n```\\n\\n### 3. Write OAM Configurations\\n\\n- Install KCL.\\n\\n```shell\\ncurl -fsSL https://kcl-lang.io/script/install-cli.sh | /bin/bash\\n```\\n\\n- Create a new project and add OAM dependencies.\\n\\n```shell\\nkcl mod init kcl-play-svc && cd kcl-play-svc && kcl mod add oam\\n```\\n\\n- Write the following code in main.k.\\n\\n```python\\nimport oam\\n\\noam.Application {\\n    metadata.name = \\"kcl-play-svc\\"\\n    spec.components = [{\\n        name = metadata.name\\n        type = \\"webservice\\"\\n        properties = {\\n            image = \\"kcllang/kcl\\"\\n            ports = [{port = 80, expose = True}]\\n            cmd = [\\"kcl\\", \\"play\\"]\\n        }\\n    }]\\n}\\n```\\n\\n> Note: You can see documents here: [https://artifacthub.io/packages/kcl/kcl-module/oam](https://artifacthub.io/packages/kcl/kcl-module/oam) or in the IDE extension.\\n\\n![oam-definition-hover](/img/blog/2023-12-15-kubevela-integration/oam-definition-hover.png)\\n\\n### 4. Deploy the application and verify.\\n\\n- Apply the configuration.\\n\\n```shell\\nkcl run | vela up -f -\\n```\\n\\n- Port forward the service.\\n\\n```shell\\nvela port-forward kcl-play-svc\\n```\\n\\nThen we can see the KCL Playground application running successfully in the browser.\\n\\n![kcl-play-svc](/img/blog/2023-12-15-kubevela-integration/kcl-play-svc.png)\\n\\n## Conclusion\\n\\nThrough this guide, we have learned how to deploy cloud-native applications using KubeVela and KCL. In future blogs, we will explain how to further extend the capabilities of KubeVela by using KCL on the client side such as\\n\\n- Using the inheritance, composition, and validation capabilities of KCL to extend the OAM model and define application abstractions that are better suited to your infrastructure or organization.\\n- Using the modularized configuration capabilities of KCL to organize OAM multi-environment configurations with conditions, logic, loops, and modularity. For example, distribute longer App Definitions into different files to reduce boilerplate configurations.\\n- Further integration with projects like KusionStack and ArgoCD to achieve better GitOps.\\n- Incorporate more cloud-native capabilities or Kubernetes Operators such as KubeBlocks and Crossplane to improve database management and provide programmable access to unified cloud APIs and Kubernetes APIs.\\n- And many other use cases..."},{"id":"2023-12-09-kcl-new-semantic-model","metadata":{"permalink":"/blog/2023-12-09-kcl-new-semantic-model","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-09-kcl-new-semantic-model/index.md","source":"@site/blog/2023-12-09-kcl-new-semantic-model/index.md","title":"Unlocking Advanced Code Intelligence with the KCL Semantic Model","description":"What is the KCL semantic model?","date":"2023-12-09T00:00:00.000Z","formattedDate":"December 9, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Semantic","permalink":"/blog/tags/semantic"}],"readingTime":11.195,"hasTruncateMarker":false,"authors":[{"name":"KCL Team Member","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-12-09-kcl-new-semantic-model","title":"Unlocking Advanced Code Intelligence with the KCL Semantic Model","authors":{"name":"KCL Team Member","title":"KCL Team Member"},"tags":["KCL","Semantic"]},"prevItem":{"title":"Efficient Cloud Native Application Deployment - KCL and KubeVela Integration Quick Guide","permalink":"/blog/2023-12-15-kubevela-integration"},"nextItem":{"title":"Exploration of KCL in Engineering Configuration and Policy Scenarios","permalink":"/blog/2023-12-09-engineering-config-policy-with-kcl-meeting"}},"content":"## What is the KCL semantic model?\\n\\n![image.png](/img/blog/2023-12-09-kcl-new-semantic-model/01.png)\\n\\n- \\"Semantic model\\" refers to the in-memory representation of modules, functions, and types that appear in source code. This representation is fully \\"resolved\\": all expressions have types (note that there may be expression types that cannot be deduced in the KCL, they will be defined as any **Type**), and all references are bound to declarations, etc.\\n- The client can submit a small amount of input data (typically changes to a single file) and get a new code model to explain the changes.\\n- The underlying engine ensures that the model is **Lazy (on demand) and incremental** computational and can be updated quickly for small changes.\\n\\n## Why does KCL need a new semantic model?\\n\\nFirst, we can take a brief look at the design of the old semantic model: ![image.png](/img/blog/2023-12-09-kcl-new-semantic-model/02.png) the old semantic model can be simply regarded as a collection of a large number of scopes, in which different scopes store the parent-child nodes between the scopes, as well as the symbol strings and corresponding types contained therein. It can simply meet the requirements of the compiler for type checking and code generation. But a simple structure involving an advanced tool chain, such as an IDE, is not sufficient. A few examples of typical IDE queries:\\n\\n- What is the type of the AST node under the corresponding position?\\n- Where are all the references to the current AST node? \uff08find reference\uff09\\n- Which node is referenced by the current AST node? \uff08find definition\uff09\\n- All symbols accessible at the current position?\\n\\nOnly the old semantic model is used, which requires the IDE to traverse the AST for many times and perform repeated calculations. We can simply analyze the problems of the old semantic model, and we can find that:\\n\\n- The old semantic model was more difficult to query information, and only stored the mapping from character string to symbol\\n- The association between symbols and the weak association between symbols and scopes often leads to the need to traverse all scopes when querying for relevant information\\n- A large amount of intermediate information is discarded in the analysis process and is not cached, resulting in repeated operations for multiple queries.\\n\\nIn short, the old semantic model can not meet the query needs of the advanced tool chain, and a lot of information is missing. On the other hand, the old semantic model does not support incremental compilation, which also reduces the user experience of the tool chain.\\n\\n## Main Idea: Map Reduce\\n\\nThe idea of the Map Reduce architecture is to split the analysis into a relatively simple indexing phase and a separate full analysis phase.\\n\\nThe core constraint of indexing is that it runs on a per-file basis, with the indexer taking the text of a single file, parsing it, and spitting out some data about that file. The indexer cannot touch other files. Full analysis can read other files and use the information in the index to save effort.\\n\\nThis sounds too abstract, so let\'s look at a concrete example-Java. In Java, each file begins with a package declaration. The indexer concatenates the package name with the class name to get the fully qualified name. It also collects the set of methods declared in the class, the list of superclasses and interfaces, and so on.\\n\\nThe data for each file is merged into an index that maps fully qualified names (FQNs) to classes. The index is inexpensive to update, and when a file modification request arrives, the contribution to that file in the index is removed, the text of the file is changed, and the indexer runs on the new text and adds the new contribution. The amount of work to be done is proportional to the number of files changed and is independent of the total number of files.\\n\\nLet\'s see how to use the FQN index to quickly provide completion.\\n\\n```java\\n// File ./mypackage/Foo.java\\npackage mypackage;\\n\\nimport java.util.*;\\n\\npublic class Foo {\\n    public static Bar f() {\\n        return new Bar();\\n    }\\n}\\n\\n// File ./mypackage/Bar.java\\npackage mypackage;\\n\\npublic class Bar {\\n    public void g() {}\\n}\\n\\n// File ./Main.java\\nimport mypackage.Foo;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Foo.f().\\n    }\\n}\\n```\\n\\nThe user just entered `Foo.f().` We need to clarify that the receiver expression type is `Bar` and suggest `g ` as completion.\\n\\nFirstly, when the file `Main.java` is modified, we run the indexer on this individual file without any changes (the file still contains the class `Main` with static `main` methods), so we do not need to update the FQN index.\\n\\nNext, we need to resolve the name `Foo`. We parsed the file `Main.java` and noticed the `import mypackage.Foo` and search for `mypackage.Foo` in the FQN index. In the index, we found that `Foo` has a static method `f`, so we successfully resolved the call to `f()`. The index also stores the return type of `f`, but please note that the index stores the string `Bar` instead of a direct reference to the class `Bar`.\\n\\nThe reason for doing this is that the `import java.util.*` in `Foo.java` can cause the `Bar` to be inferred as either `java.util.Bar\'` or `mypackage.Bar`, the indexer doesn\'t know which one it is because it can only \\"see\\" the text of the file `Foo.java`. In other words, although the index does store the return types of methods, it stores them in an unresolved form.\\n\\nThe next step is to parse the identifier `Bar` in the context of `Foo.java`. This will continue to use FQN indexing and navigate to class `mypackage.Bar`. So in the end, we found the method `g` that we wanted to complete.\\n\\nDuring the completion process, only three files were touched upon in total. The FQN index allows us to completely ignore all other files in the project.\\n\\nOne problem with the methods described so far is that parsing types from indexes requires a lot of work. For example, if `Foo.f\'` is called multiple times, this task may be repeated. The solution is to add a cache. The name resolution result will be remembered, so only one resolution is required. Any changes will cause the cache to completely invalid - the cost of rebuilding the cache using indexes is not that high.\\n\\nTo summarize, the working principle of the first method is as follows:\\n\\n1. Each file is independently and parallelly indexed, generating a \\"stub\\" - a set of visible top-level declarations with unresolved types.\\n2. Merge all stubs into one indexed data structure.\\n3. Name parsing and type inference are mainly based on stubs.\\n4. Name resolution is lazy (we only parse types from stubs when needed) and memory based (each type is parsed only once).\\n5. The cache will be completely invalidated every time a change is made\\n6. The index is incrementally updated:\\n   - If the editor has not changed the stub of the file, there is no need to change the index.\\n   - Otherwise, the old index will be deleted and the new index will be added again\\n\\nThis method is simple enough and has excellent performance. Most of the work is mainly in the indexing phase, and we can execute these tasks in parallel. Two examples of this architecture are [IntelliJ](https://www.jetbrains.com/idea/) And [Sorbet](https://sorbet.org/).\\n\\nThe main drawback of this method is that it is only effective when it is effective - specifically, not every language has a clearly defined concept of FQN. But overall, designing modules and name parsing is always good for languages, and specifically, in the current situation, KCL just meets this condition.\\n\\n## New Semantic Model Pipeline\\n\\nThe overall pipeline of the new semantic model is as follows:\\n![image.png](/img/blog/2023-12-09-kcl-new-semantic-model/03.png)\\n\\n![image.png](/img/blog/2023-12-09-kcl-new-semantic-model/04.png)\\n\\n![image.png](/img/blog/2023-12-09-kcl-new-semantic-model/05.png)\\nCompared with the analysis process of the original semantic model, the new semantic model adds two rounds of pass, namer and advanced \\\\_ resolve, so as to enhance the support for the advanced tool chain without affecting the original compiler process.\\n\\n- The `resolver` is based on file level work, mainly involving the initialization of the `GlobalState`, parsing the source code into AST, and establishing the mapping of AST nodes to types for later stages to use. Therefore, we can cache the output of a single file index to completely skip parsing the file when its content has not changed.\\n- The early stage of `namer` will also be based on file level work, which collects global symbols defined in the file, and then merges the symbols based on FQN to obtain a unique `GlobalState`\\n  - Based on file level, it means we can easily perform incremental compilation in the first two stages\\n- `advanced_resolver` will traverse the AST to resolve local symbols and point symbol references to their definitions, while setting the owner symbol for the local scope, such as `Schema` and `Package`\\n\\n## Semantic Database: GlobalState\\n\\nThe core structure of the new semantic model is `core::GlobalState` that the tool chain mainly uses it to complete the interaction and query with the compiler.\\n\\n```rust\\n/// GlobalState is used to store semantic information of KCL source code\\n#[derive(Default, Debug, Clone)]\\npub struct GlobalState {\\n    // store all allocated symbols\\n    symbols: KCLSymbolData,\\n    // store all allocated scopes\\n    scopes: ScopeData,\\n    // store package infomation for name mapping\\n    packages: PackageDB,\\n    // store semantic information after analysis\\n    pub(crate) sema_db: SemanticDB,\\n}\\n```\\n\\n`GlobalState` is used as a semantic database for the new semantic model and is the final product of semantic analysis, mainly containing four aspects of information:\\n\\n- `SymbolData`: stores all symbols in the AST and their corresponding semantic information, and maintain the reference relationship.\\n- `ScopeData`: stores all scopes involved in the AST, while separating symbols, maintaining symbol visibility and scope nesting relationships\\n- `PackageDB`: stores package information, such as a collection of files for the package, import information, and so on.\\n- `SemanticDB`: stores auxiliary information to speed up queries, such as symbol sorting and position caching.\\n\\n### SymbolData\\n\\n`SymbolData` is responsible for managing the allocation of symbols and storing the allocated symbols and related semantic information. Here we borrow the arena design of rust to access the relevant symbols.\\n\\n```rust\\n#[derive(Default, Debug, Clone)]\\npub struct KCLSymbolData {\\n    pub(crate) values: Arena<ValueSymbol>,\\n    pub(crate) packages: Arena<PackageSymbol>,\\n    pub(crate) attributes: Arena<AttributeSymbol>,\\n    pub(crate) schemas: Arena<SchemaSymbol>,\\n    pub(crate) type_aliases: Arena<TypeAliasSymbol>,\\n    pub(crate) unresolved: Arena<UnresolvedSymbol>,\\n    pub(crate) rules: Arena<RuleSymbol>,\\n\\n    pub(crate) symbols_info: SymbolDB,\\n}\\n```\\n\\nIn the new semantic model, we use `core::SymbolRef` to represent a reference to a symbol, and also use `SymbolRef` to access `SymbolData` for the specific symbol information.\\n\\n```rust\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\\npub struct SymbolRef {\\n    pub(crate) id: generational_arena::Index,\\n    pub(crate) kind: SymbolKind,\\n}\\n```\\n\\nSpecifically, Symbols with different types will be taken out from `SymbolData` according to `SymbolRef::kind` and converted to abstract `trait Symbol`.\\n\\n```rust\\npub type KCLSymbol = dyn Symbol<SymbolData = KCLSymbolData,\\n    SemanticInfo = KCLSymbolSemanticInfo>;\\npub fn get_symbol(&self, id: SymbolRef) -> Option<&KCLSymbol> {\\n        match id.get_kind() {\\n            SymbolKind::Schema => self\\n                .schemas\\n                .get(id.get_id())\\n                .map(|symbol| symbol as &KCLSymbol),\\n            ...\\n        }\\n    }\\n```\\n\\n```rust\\npub trait Symbol {\\n    type SymbolData;\\n    type SemanticInfo;\\n    fn get_sema_info(&self) -> &Self::SemanticInfo;\\n    fn is_global(&self) -> bool;\\n    fn get_range(&self) -> Range;\\n    fn get_owner(&self) -> Option<SymbolRef>;\\n    fn get_definition(&self) -> Option<SymbolRef>;\\n    fn get_name(&self) -> String;\\n    fn get_id(&self) -> Option<SymbolRef>;\\n    fn get_attribute(&self, ...) -> Option<SymbolRef>;\\n    fn has_attribute(&self, ...) -> bool;\\n\\n    fn get_all_attributes(&self, ...) -> Vec<SymbolRef>;\\n\\n    fn simple_dump(&self) -> String;\\n\\n    fn full_dump(&self, data: &Self::SymbolData) -> Option<String>;\\n}\\n```\\n\\nhrough this trait, the tool chain can easily complete the query of symbol semantic information and reference relationship.\\n\\n### ScopeData\\n\\nThe design idea of `ScopeData` is actually similar to `SymbolData`, it stores `Scope` with different types and using `ScopeRef` to access them.\\n\\n```rust\\n#[derive(Default, Debug, Clone)]\\npub struct ScopeData {\\n    /// map pkgpath to root_scope\\n    pub(crate) root_map: IndexMap<String, ScopeRef>,\\n    pub(crate) locals: generational_arena::Arena<LocalSymbolScope>,\\n    pub(crate) roots: generational_arena::Arena<RootSymbolScope>,\\n}\\n```\\n\\n```rust\\npub trait Scope {\\n    type SymbolData;\\n    fn get_filename(&self) -> &str;\\n    fn get_parent(&self) -> Option<ScopeRef>;\\n    fn get_children(&self) -> Vec<ScopeRef>;\\n\\n    fn contains_pos(&self, pos: &Position) -> bool;\\n\\n    fn get_owner(&self) -> Option<SymbolRef>;\\n    fn look_up_def(&self, ...) -> Option<SymbolRef>;\\n\\n    fn get_all_defs(&self, ...) -> HashMap<String, SymbolRef>;\\n\\n    fn dump(&self, scope_data: &ScopeData,\\n            symbol_data: &Self::SymbolData) -> Option<String>;\\n}\\n```\\n\\n### SemanticDB\\n\\n`SemanticDB` is essentially the caching and integration of partial semantic information of semantic objects. Its main function is to accelerate the maintenance and querying of internal information in `GlobalState`.\\n\\n```rust\\n#[derive(Debug, Default, Clone)]\\npub struct SemanticDB {\\n    pub(crate) file_sema_map: IndexMap<String, FileSemanticInfo>,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct FileSemanticInfo {\\n    pub(crate) filename: String,\\n    pub(crate) symbols: Vec<SymbolRef>,\\n    pub(crate) scopes: Vec<ScopeRef>,\\n    pub(crate) symbol_locs: IndexMap<SymbolRef, CachedLocation>,\\n    pub(crate) local_scope_locs: IndexMap<ScopeRef, CachedRange>,\\n}\\n```\\n\\n## Summary\\n\\nThe new semantic model of KCL essentially only does two things, one is to sink the repeated calculation of the tool chain in the application layer to the semantic layer, and design a corresponding mechanism to simplify the information query, and the other is to re-analyze and cache the information lost in the semantic analysis process. There are several main purposes for doing so:\\n\\n- The calculation process is gathered, and the intrusion of the application layer into the semantic core of the compiler is prevented\\n- The cache mechanism is improved, and the implementation of incremental compilation is simplified, so that the query speed is accelerated.\\n- Improve maintainability by simplifying the development of the application layer tool chain and reducing the handling of Corner Cases by the tool chain\\n\\nIn practice, the above objectives are basically achieved. After migration, the code volume of LSP related functions is reduced by about 60%, and the compilation speed is increased by about 500% after incremental compilation."},{"id":"2023-12-09-engineering-config-policy-with-kcl-meeting","metadata":{"permalink":"/blog/2023-12-09-engineering-config-policy-with-kcl-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-09-engineering-config-policy-with-kcl-meeting/index.md","source":"@site/blog/2023-12-09-engineering-config-policy-with-kcl-meeting/index.md","title":"Exploration of KCL in Engineering Configuration and Policy Scenarios","description":"Download Chinese PDF","date":"2023-12-09T00:00:00.000Z","formattedDate":"December 9, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":0.015,"hasTruncateMarker":false,"authors":[{"name":"KCL Team Member","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-12-09-engineering-config-policy-with-kcl-meeting","title":"Exploration of KCL in Engineering Configuration and Policy Scenarios","authors":{"name":"KCL Team Member","title":"KCL Team Member"},"tags":["KCL","Meeting"]},"prevItem":{"title":"Unlocking Advanced Code Intelligence with the KCL Semantic Model","permalink":"/blog/2023-12-09-kcl-new-semantic-model"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 11.24 - 12.07) | How to Use Different Kubernetes Patch Strategies in KCL?","permalink":"/blog/2023-12-07-biweekly-newsletter"}},"content":"[Download Chinese PDF](https://kcl-lang.io/talks/engineering-config-policy-with-kcl.pdf)"},{"id":"2023-12-07-biweekly-newsletter","metadata":{"permalink":"/blog/2023-12-07-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-12-07-biweekly-newsletter/index.md","source":"@site/blog/2023-12-07-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 11.24 - 12.07) | How to Use Different Kubernetes Patch Strategies in KCL?","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-12-07T00:00:00.000Z","formattedDate":"December 7, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":4.67,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-12-07-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 11.24 - 12.07) | How to Use Different Kubernetes Patch Strategies in KCL?","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"Exploration of KCL in Engineering Configuration and Policy Scenarios","permalink":"/blog/2023-12-09-engineering-config-policy-with-kcl-meeting"},"nextItem":{"title":"KCL v0.7.0 Release Blog","permalink":"/blog/2023-11-30-kcl-0.7.0-release"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (11.24 - 12.07 2023). Here is an overview of the key content:\\n\\n**\ud83d\udce6 Module Update**\\n\\nThe number of KCL models has increased to **240**, mainly including models related to Crossplane Provider and libraries related to JSON merging operations.\\n\\n- KCL JSON Patch library:_[https://artifacthub.io/packages/kcl/kcl-module/jsonpatch](https://artifacthub.io/packages/kcl/kcl-module/jsonpatch)_\\n- KCL JSON Merge Patch library: _[https://artifacthub.io/packages/kcl/kcl-module/json_merge_patch](https://artifacthub.io/packages/kcl/kcl-module/json_merge_patch)_\\n- KCL Kubernetes Strategy Merge Patch library: _[https://artifacthub.io/packages/kcl/kcl-module/strategic_merge_patch](https://artifacthub.io/packages/kcl/kcl-module/strategic_merge_patch)_\\n- KCL Crossplane and Crossplane Provider series models: _[https://artifacthub.io/packages/search?org=kcl&sort=relevance&page=1&ts_query_web=crossplane](https://artifacthub.io/packages/search?org=kcl&sort=relevance&page=1&ts_query_web=crossplane)_\\n\\n**\ud83d\udd27 Toolchain Update**\\n\\n- **Documentation Tool Updates**\\n  - Support documentation generation for third-party libraries that models depend on, such as the `k8s` module.\\n- **Validation Tool Updates**\\n  - Support validation results and error localization to YAML/JSON files, outputting error line and column number information.\\n- **Import Tool Updates**\\n  - Support mapping OpenAPI `multiplyOf` specification to KCL `multiplyof` function for validation.\\n  - Support outputting YAML Stream format Kubernetes CRD files into multiple KCL files.\\n  - Optimize KCL code generation by removing empty check statements.\\n\\n**\ud83c\udfc4 SDK Update**\\n\\nIn addition to the existing Go and Python SDKs in KCL, a new Rust SDK has been added (without LLVM dependency), which includes APIs for KCL file compilation, validation, testing, and code formatting.\\n\\n**\ud83d\udcbb IDE Updates**\\n\\n- **Developer Experience**\\n  - Support incremental parsing and asynchronous compilation to enhance performance.\\n- **Bug Fixes**\\n  - Fixed the issue where string interpolation variables in assert statements cannot be navigated.\\n  - Fixed the issue where exceptional triggering of function completion in strings.\\n  - Fixed the issue with alias semantic check and completion in import statements.\\n  - Fixed the issue with check expression completion in schemas.\\n\\n**\ud83d\udcd2 Documentation Updates**\\n\\n- Added index cards for KCL system library documentation for easy navigation: _[https://kcl-lang.io/docs/reference/model/overview](https://kcl-lang.io/docs/reference/model/overview)_\\n- Updated KCL CLI reference documentation: _[https://kcl-lang.io/docs/tools/cli/kcl/overview](https://kcl-lang.io/docs/tools/cli/kcl/overview)_\\n- Updated KCL API reference documentation: _[https://kcl-lang.io/docs/reference/xlang-api/overview](https://kcl-lang.io/docs/reference/xlang-api/overview)_\\n- KCL 2023 & 2024 Roadmap document: _[https://kcl-lang.io/docs/community/release-policy/roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)_\\n- Supplemented project structure introduction and FAQ for Intellij KCL repository: _[https://github.com/kcl-lang/intellij-kcl/pull/18](https://github.com/kcl-lang/intellij-kcl/pull/18)_\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @professorabhay for supporting KCL testing diff function \ud83d\ude4c _[https://github.com/kcl-lang/kcl/issues/940](https://github.com/kcl-lang/kcl/issues/940)_\\n- Thanks to @patrycju, @Callum Lyall, @Even Solberg, @Matt Gowie, and @ShiroDN for their valuable feedback and discussions during the promotion and usage of KCL \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### Using Kubernetes Strategy Merge Patch to Update Configurations in KCL\\n\\nIn the current version of KCL, various **attribute operators** are supported to update and override configurations. However, the capability is relatively atomic and cannot cover the typical configuration strategy scenarios in cloud-native environments.\\n\\nFor Kubernetes configurations, it is common to use the `JSON Merge Patch` and `Strategy Merge Patch` capabilities natively supported by Kubernetes e.g., using tools such as `kubectl patch`, `kustomize`, and other patching capabilities supported by cloud-native configuration and policy tools.\\n\\nTo avoid repeatedly using KCL attribute operators to write configuration patch template codes when dealing with Kubernetes configurations, we provide the **Kubernetes Strategy Merge Patch library** for updating Kubernetes configurations. This library supports all merging strategies defined by native Kubernetes objects, such as overwriting, modifying, and adding items to list objects. Here is how to use it:\\n\\nCreate a new project and add the Strategy Merge Patch library dependency:\\n\\n```shell\\nkcl mod init && kcl mod add strategic_merge_patch\\n```\\n\\nWrite the configuration patch code in `main.k` (using the `labels`, `replicas`, and `container` attributes of a `Deployment` template as an example):\\n\\n```python\\nimport strategic_merge_patch as s\\n\\noriginal = {\\n    apiVersion = \\"apps/v1\\"\\n    kind = \\"Deployment\\"\\n    metadata = {\\n        name = \\"my-deployment\\"\\n        labels.app = \\"my-app\\"\\n    }\\n    spec: {\\n        replicas = 3\\n        template.spec.containers = [\\n            {\\n                name = \\"my-container-1\\"\\n                image = \\"my-image-1\\"\\n            }\\n            {\\n                name = \\"my-container-2\\"\\n                image = \\"my-image-2\\"\\n            }\\n        ]\\n    }\\n}\\npatch = {\\n    apiVersion = \\"apps/v1\\"\\n    kind = \\"Deployment\\"\\n    metadata = {\\n        name = \\"my-deployment\\"\\n        labels.version = \\"v1\\"\\n    }\\n    spec: {\\n        replicas = 4\\n        template.spec.containers = [\\n            {\\n                name = \\"my-container-1\\"\\n                image = \\"my-new-image-1\\"\\n            }\\n            {\\n                name = \\"my-container-3\\"\\n                image = \\"my-image-3\\"\\n            }\\n        ]\\n    }\\n}\\ngot = s.merge(original, patch)\\n```\\n\\nRun the command to get the output:\\n\\n```shell\\nkcl run\\n```\\n\\nThe output will be:\\n\\n```yaml\\noriginal:\\n  apiVersion: apps/v1\\n  kind: Deployment\\n  metadata:\\n    name: my-deployment\\n    labels:\\n      app: my-app\\n  spec:\\n    replicas: 3\\n    template:\\n      spec:\\n        containers:\\n          - name: my-container-1\\n            image: my-image-1\\n          - name: my-container-2\\n            image: my-image-2\\npatch:\\n  apiVersion: apps/v1\\n  kind: Deployment\\n  metadata:\\n    name: my-deployment\\n    labels:\\n      version: v1\\n  spec:\\n    replicas: 4\\n    template:\\n      spec:\\n        containers:\\n          - name: my-container-1\\n            image: my-new-image-1\\n          - name: my-container-3\\n            image: my-image-3\\ngot:\\n  apiVersion: apps/v1\\n  kind: Deployment\\n  metadata:\\n    name: my-deployment\\n    labels:\\n      app: my-app\\n      version: v1\\n  spec:\\n    replicas: 4\\n    template:\\n      spec:\\n        containers:\\n          - name: my-container-1\\n            image: my-new-image-1\\n          - name: my-container-2\\n            image: my-image-2\\n          - name: my-container-3\\n            image: my-image-3\\n```\\n\\nAs seen in the output, the labels, replicas, and container fields of the Deployment template have all been updated with the correct values. For more documentation and usage examples, please refer to [the document](https://artifacthub.io/packages/kcl/kcl-module/strategic_merge_patch).\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.8.0 Milestone](https://github.com/kcl-lang/kcl/milestone/8)"},{"id":"2023-11-30-kcl-0.7.0-release","metadata":{"permalink":"/blog/2023-11-30-kcl-0.7.0-release","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-11-30-kcl-0.7.0-release/index.md","source":"@site/blog/2023-11-30-kcl-0.7.0-release/index.md","title":"KCL v0.7.0 Release Blog","description":"Introduction","date":"2023-11-30T00:00:00.000Z","formattedDate":"November 30, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":8.96,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-11-30-kcl-0.7.0-release","title":"KCL v0.7.0 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 11.24 - 12.07) | How to Use Different Kubernetes Patch Strategies in KCL?","permalink":"/blog/2023-12-07-biweekly-newsletter"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 11.09 - 11.23) | Cloud-Native Modules, Language, and Toolchain Update Express!","permalink":"/blog/2023-11-23-biweekly-newsletter"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.7.0 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n- _Use KCL language, tools and IDE extensions with more complete features and fewer errors to improve code writing experience and efficiency._\\n\\n- _The new KCL CLI integrates KCL package management, doc, test and other peripheral ecosystems._\\n\\n- _The rich KCL third-party library market artifacthub.io provides more than 200 KCL third-party libraries for you to choose from._\\n\\nKCL v0.7.0 is now available for download at [KCL v0.7.0 Release Page](https://github.com/kcl-lang/kcl/releases/tag/v0.7.0) or [KCL Official Website](https://kcl-lang.io).\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF). KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.7.0 and recent developments in the KCL community to readers.\\n\\n## Language Updates\\n\\n### \u2b50\ufe0f New KCL CLI\\n\\nWhen compiling, use `kcl`, when downloading packages, use `kpm`, if you have a KCL model that you want to send to the cluster, you also need to use `kusion`, kcl is the compilation command, `kpm run` can also be compiled, I also found `kusion compile` in the kusion command line, do you have the same confusion, what is the relationship between these tools? How do I use them?\\n\\nFor this reason, we provide you with a new KCL CLI, the goal is to include the KCL ecosystem together, to provide you with a unified and concise operation page, everything, one-click direct.\\n\\nThe new KCL CLI will continue to use `kcl` as the command prefix, and currently provides multiple sub-commands including compilation, package management, and formatting tools.\\n\\n![cli-help](/img/blog/2023-11-30-kcl-0.7.0-release/cli-help.png)\\n\\n### \ud83d\udd27 Diagnostic Information Optimization\\n\\nWe have tried to add repair suggestions in some error messages. If you are frustrated by the KCL compilation failure, you may wish to listen to the compiler\'s suggestions.\\n\\n```python\\nimport sub as s1\\n\\nThe_first_kcl_program = s.The_first_kcl_program\\n```\\n\\nLet\'s listen to what the compiler says. You may have written `s1` as `s` by mistake.\\n\\n![did you mean](/img/blog/2023-11-30-kcl-0.7.0-release/did-you-mean.png)\\n\\nKCL cannot find the third-party library used in the package? Try `kcl mod add`, if it still doesn\'t work, we have prepared more than 200 KCL models for you on artifacthub.io, come and have a look, there is always one that suits you!\\n\\n![try-kcl-mod-add](/img/blog/2023-11-30-kcl-0.7.0-release/try-kcl-mod-add.png)\\n\\n### \ud83d\ude80 Language Writing Experience Optimization\\n\\n#### Removed indentation check in some code blocks\\n\\nIn some code blocks, whether the indentation is aligned has become less important.\\n\\nIf your code is written like this\\n\\n```python\\nschema TestIndent:\\n    name: str\\n    msg: str\\n    id: int\\n\\ntest_indent = TestIndent {\\n                    name = \\"test\\"\\n  msg = \\"test\\"\\n              id = 1\\n}\\n```\\n\\nIn the past, you may have encountered a lot of red errors, but now this is not a mistake, `kcl fmt` will help you tidy it up.\\n\\n![kcl-fmt](/img/blog/2023-11-30-kcl-0.7.0-release/kclfmt.gif)\\n\\n#### Lambda expression type annotation\\n\\nIn the new version of KCL, we have added type annotations for lambda expressions, and you can write lambda with type annotations in the new version of KCL.\\n\\n```python\\nschema Test:\\n    name: str\\n\\nidentity: (Test) -> bool = lambda res: Test -> bool {\\n    res.name == \\"hello\\"\\n}\\n\\nc = identity(Test { name = \\"hello\\" })\\n```\\n\\n### \ud83c\udfc4 API Updates\\n\\n- New KCL unit test API: _[https://github.com/kcl-lang/kcl/pull/904](https://github.com/kcl-lang/kcl/pull/904)_\\n- KCL schema parsing API enhancement version `GetFullSchemaType` supports obtaining KCL package related information with third-party libraries. _[https://github.com/kcl-lang/kcl/pull/906](https://github.com/kcl-lang/kcl/pull/906)_\\n- New KCL symbol renaming API: _[https://github.com/kcl-lang/kcl/pull/890](https://github.com/kcl-lang/kcl/pull/890)_\\n\\n### \ud83d\udc1e Other Updates and Bug Fixes\\n\\n- KCL command-line tool supports compiling input file wildcards e.g., `kcl path/to/*.k`\\n- Fix the type inference error of dictionary types https://github.com/kcl-lang/kcl/pull/900\\n- Fix the check of Schema parameters https://github.com/kcl-lang/kcl/pull/877/files\\n- Fix the problem that the compilation cache of KCL programs with third-party libraries is invalid https://github.com/kcl-lang/kcl/pull/841\\n- In the error message, complete the missing lambda type information https://github.com/kcl-lang/kcl/pull/771\\n- Fix the problem of singular and plural in diagnostic information https://github.com/kcl-lang/kcl/pull/769\\n- Fix the problem that the type check is invalid in the assignment statement with type annotation https://github.com/kcl-lang/kcl/pull/757\\n- Add a check to prohibit duplicate import statements https://github.com/kcl-lang/kcl/pull/727\\n\\n## IDE & Toolchain Updates\\n\\n### IDE Updates\\n\\n#### KCL IDE supports goto reference and renaming of symbols\\n\\nIDE supports goto reference of symbols, using `goto reference` or `find all references`:\\n\\n![find-ref](/img/docs/tools/Ide/vs-code/FindRefs.png)\\n\\nIDE supports renaming of symbols:\\n\\n![rename](/img/docs/tools/Ide/vs-code/Rename.gif)\\n\\n#### IDE supports formatting of import statements and union types\\n\\nWe have optimized the behavior of blank lines between import statements and other code blocks (formatted as one blank line) and the behavior of spaces between union types (formatted as separated by `|`):\\n\\n![fmt](/img/blog/2023-10-25-kcl-biweekly-newsletter/Format.gif)\\n\\n#### KCL IDE has added a lot of completion prompts\\n\\nWe have added a lot of completion prompts for the **configuration definition**, which simplifies the user\'s mind of writing configuration based on the model and improves the efficiency of configuration editing. In addition, the parameter completion when calling the built-in function is enhanced. Talk is cheap, let\'s take a look at the effect directly:\\n\\n![func-completion](/img/blog/2023-11-08-biweekly-newsletter/module-function-completion.gif)\\n\\n![conf-completion](/img/blog/2023-11-08-biweekly-newsletter/config-completion.gif)\\n\\nAnd for the **model design**, we have also added a quick generation of docstring to reduce the boilerplate of typing by hand:\\n\\n![gen-docstring](/img/blog/2023-11-08-biweekly-newsletter/docstring-gen.gif)\\n\\n#### Performance\\n\\n- KCL has designed and restructured a new semantic model, as well as an API that supports nearest symbol search and symbol semantic information query.\\n- The migration of IDE completion, jump, and hover functions to new semantic models significantly reduces the difficulty and code volume of IDE development.\\n- The KCL compiler supports syntax incremental parsing and semantic incremental checking, which improves the performance of KCL compilation, construction, and IDE plugin usage in most scenarios by **5-10 times**.\\n\\n#### KCL IDE other updates and bug fixes\\n\\n- KCL IDE extension for IntelliJ 2023.2+\\n- Fix the problem that the language service virtual file system related bug: the file dimension change will cause the language service to crash and must be restarted to recover, which has now been fixed.\\n- Support import statement completion of external package dependencies introduced by package management tools\\n- Fix the display position of the function parameter undefined type error\\n\\n### Test Tool Updates\\n\\nAre you worried that your KCL program is written incorrectly? Why not come and test it? This update provides a new KCL test tool.\\n\\nThe new KCL test tool supports writing unit tests using KCL lambda and executing tests using the tool.\\n\\nYou can write your test cases through lambda expressions in the file with the suffix `_test.k`.\\n\\n```python\\nimport .app\\n\\n# Convert the `App` model into Kubernetes Deployment and Service Manifests\\ntest_kubernetesRender = lambda {\\n    a = app.App {\\n        name = \\"app\\"\\n        containers.ngnix = {\\n            image = \\"ngnix\\"\\n            ports = [{containerPort = 80}]\\n        }\\n        service.ports = [{ port = 80 }]\\n    }\\n    deployment_got = kubernetesRender(a)\\n    assert deployment_got[0].kind == \\"Deployment\\"\\n    assert deployment_got[1].kind == \\"Service\\"\\n}\\n```\\n\\nYou can run this test case and view the test results through `kcl test`.\\n\\nAfter the test is passed, you will get the following results:\\n\\n![test-pass](/img/blog/2023-11-30-kcl-0.7.0-release/test-pass.png)\\n\\nIf your test fails, `kcl test` will output error information to help you troubleshoot the problem.\\n\\n![test-failed](/img/blog/2023-11-30-kcl-0.7.0-release/test-failed.png)\\n\\n### KCL Package Management\\n\\nThe `update` command is added to the `kcl mod` command. The `update` command is used to automatically update local dependencies. `kcl mod update` will automatically download the missing third-party libraries for you. For details, please refer to: https://github.com/kcl-lang/kpm/pull/212\\n\\n### KCL Import Tool\\n\\nThe KCL Import tool supports one-click generation of KCL configuration/models from YAML/JSON/CRD/Terraform Schema, realizing automated migration.\\n\\nIf you have the following yaml file:\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\n  labels:\\n    app: nginx\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n        - name: nginx\\n          image: nginx:1.14.2\\n          ports:\\n            - containerPort: 80\\n```\\n\\nYou can convert it to a KCL program through the command `kcl import test.yaml`.\\n\\n```python\\n\\"\\"\\"\\nThis file was generated by the KCL auto-gen tool. DO NOT EDIT.\\nEditing this file might prove futile when you re-run the KCL auto-gen generate command.\\n\\"\\"\\"\\n\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"nginx-deployment\\"\\n    labels = {\\n        app = \\"nginx\\"\\n    }\\n}\\nspec = {\\n    replicas = 3\\n    selector = {\\n        matchLabels = {\\n            app = \\"nginx\\"\\n        }\\n    }\\n    template = {\\n        metadata = {\\n            labels = {\\n                app = \\"nginx\\"\\n            }\\n        }\\n        spec = {\\n            containers = [\\n                {\\n                    name = \\"nginx\\"\\n                    image = \\"nginx:1.14.2\\"\\n                    ports = [\\n                        {\\n                            containerPort = 80\\n                        }\\n                    ]\\n                }\\n            ]\\n        }\\n    }\\n}\\n```\\n\\nMore details: https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/adopt-from-kubernetes\\n\\n## Community Integrations & Extensions Updates\\n\\n### KCL Marketplace with ArtifactHub\\n\\nThrough the integration of artifacthub.io, we have built a KCL third-party library market, where you can share your KCL programs with us. You can also choose freely and find the KCL third-party library that suits you!\\n\\nOpen the homepage of artifacthub.io, search for the keyword you need directly, and you can see the relevant content about the KCL third-party library!\\n\\n![artifachub-index](/img/blog/2023-11-30-kcl-0.7.0-release/artifachub-index.png)\\n\\nClick on the third-party library homepage, you can view the detailed content and related documents about the third-party library.\\n\\n![pkg-page](/img/blog/2023-11-30-kcl-0.7.0-release/pkg-page.png)\\n\\nIf you don\'t know how to use these third-party libraries, the button on the right can bring up the installation page for you.\\n\\n![install-pkg](/img/blog/2023-11-30-kcl-0.7.0-release/install-pkg.png)\\n\\nWelcome to contribute your third-party libraries to the KCL community on artifacthub.io and make the KCL community more colorful!\\n\\nContributing to KCL Marketplace: https://kcl-lang.io/docs/user_docs/guides/package-management/how-to/publish_pkg_to_ah\\n\\n## Other Updates\\n\\nThe full update and bugfix List of KCL v0.7.0 can be found at: https://github.com/kcl-lang/kcl/compare/v0.6.0...v0.7.0\\n\\n## Document Updates\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.x, v0.5.x, v0.6.x and v0.7.0 versions are supported.\\n\\n## Community Updates\\n\\n### KCL Officially Becomes CNCF Sandbox Project\\n\\n\ud83c\udf89 \ud83c\udf89 \ud83c\udf89 On September 20, 2023, the KCL project passed the evaluation of the Technical Oversight Committee of the Cloud Native Computing Foundation (CNCF), the world\'s top open source foundation, and officially became a CNCF sandbox project.\\n\\nMore details - https://kcl-lang.io/blog/2023-09-19-kcl-joining-cncf-sandbox/\\n\\n## Next Steps\\n\\nWe expect to release KCL v0.8.0 in February 2024. For more details, please refer to KCL 2024 Roadmap and KCL v0.8.0 Milestone. If you have more ideas and needs, please feel free to raise Issues or Discussions in the KCL Github repository, and welcome to join our community for discussion \ud83d\ude4c \ud83d\ude4c \ud83d\ude4c\\n\\n- KCL 2024 Roadmap: https://github.com/kcl-lang/kcl/issues/882\\n- KCL v0.8.0 Milestone: https://github.com/kcl-lang/kcl/milestone/8\\n- KCL GitHub Issues: https://github.com/kcl-lang/kcl/issues\\n- KCL GitHub Discussion: https://github.com/orgs/kcl-lang/discussions\\n- KCL Community: https://github.com/kcl-lang/community\\n\\n## Additional Resources\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-11-23-biweekly-newsletter","metadata":{"permalink":"/blog/2023-11-23-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-11-23-biweekly-newsletter/index.md","source":"@site/blog/2023-11-23-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 11.09 - 11.23) | Cloud-Native Modules, Language, and Toolchain Update Express!","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-11-23T00:00:00.000Z","formattedDate":"November 23, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.855,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-11-23-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 11.09 - 11.23) | Cloud-Native Modules, Language, and Toolchain Update Express!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"KCL v0.7.0 Release Blog","permalink":"/blog/2023-11-30-kcl-0.7.0-release"},"nextItem":{"title":"Kubernetes Modules Here Are All You Need!","permalink":"/blog/2023-11-20-search-k8s-module-on-artifacthub"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (11.09 - 11.23 2023). Here is an overview of the key content:\\n\\n**\ud83d\udce6 Module Update**\\n\\n- The number of KCL modules has been increased to **200+**, mainly adding validation modules related to `Pod`, `RBAC`, and reference documentation for Kubernetes 1.14-1.28.\\n- Now we can search and browse the documentation and usage of all modules on the `Artifact Hub` website: _[https://artifacthub.io/packages/search?org=kcl&sort=relevance&page=1](https://artifacthub.io/packages/search?org=kcl&sort=relevance&page=1)_\\n\\n**\ud83d\udcac Language Update**\\n\\n- **Developer Experience**\\n  - Optimized syntax indentation check for configuration code blocks, no longer enforced as an error.\\n  - Support for using file path wildcards as compilation entry points.\\n- **Bug Fixes**\\n  - Fixed type inference errors for some scenarios involving dictionary types.\\n  - Fix the check of the number of schema arguments.\\n\\n**\ud83d\udd27 Toolchain Update**\\n\\n- **Testing Tool Release**\\n  - Support writing unit tests using KCL functions and executing tests using the tool.\\n  - Support filtering test cases using regular expressions.\\n  - Support fast failure for unit tests.\\n- **Import Tool Update**\\n  - Fixed the generation of patterns to regular expression matching expressions: _[https://github.com/kcl-lang/kcl-openapi/pull/70](https://github.com/kcl-lang/kcl-openapi/pull/70)_\\n  - Fixed the generation of minItems/maxItems to field length validation rules: _[https://github.com/kcl-lang/kcl-openapi/pull/69](https://github.com/kcl-lang/kcl-openapi/pull/69)_\\n  - Fixed the generation of 0 or empty string as default values: _[https://github.com/kcl-lang/kcl-openapi/pull/69](https://github.com/kcl-lang/kcl-openapi/pull/69)_\\n  - Fixed the generation of package names in the conversion from Kubernetes CRD to KCL Package: `${apiVersion}_${kind}`: _[https://github.com/kcl-lang/kcl-openapi/pull/68](https://github.com/kcl-lang/kcl-openapi/pull/68)_\\n- **Package Manage Tool Update**\\n  - Added the update command to automatically update local dependencies: _[https://github.com/kcl-lang/kpm/pull/212](https://github.com/kcl-lang/kpm/pull/212)_\\n\\n**\ud83d\udcbb IDE Update**\\n\\n- **Developer Experience**\\n  - Support the completion of external package dependency import statements added by package management tools.\\n- **Bug Fixes**\\n  - Fixed the display position of undefined type errors for function parameters.\\n\\n**\ud83c\udfc4 API Update**\\n\\n- Added KCL Unit Testing API: _[https://github.com/kcl-lang/kcl/pull/904](https://github.com/kcl-lang/kcl/pull/904)_\\n- Added KCL Symbol Renaming API: _[https://github.com/kcl-lang/kcl/pull/890](https://github.com/kcl-lang/kcl/pull/890)_\\n\\n**\ud83d\udd25 Architecture Upgrade**\\n\\n- KCL has designed and reconstructed a new semantic model, as well as APIs that support nearest symbol lookup and symbol semantic information query.\\n- IDE features such as autocomplete, definition, and hover have been migrated to the new semantic model, significantly reducing the difficulty and amount of code for IDE feature development.\\n\\n**\ud83d\ude80 Performance Improvement**\\n\\n- The KCL compiler supports incremental parsing of syntax and incremental checking of semantics, significantly improving the performance of KCL compilation, build, and IDE plugin usage in most scenarios by **5-10 times**.\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @cr7258 for his contributions to the KCL model library and KCL documentation \ud83d\ude4c\\n  - _[https://github.com/kcl-lang/kcl-lang.io/pull/203](https://github.com/kcl-lang/kcl-lang.io/pull/203)_\\n  - _[https://github.com/kcl-lang/kcl-lang.io/pull/209](https://github.com/kcl-lang/kcl-lang.io/pull/209)_\\n  - _[https://github.com/kcl-lang/kcl-lang.io/pull/210](https://github.com/kcl-lang/kcl-lang.io/pull/210)_\\n  - _[https://github.com/kcl-lang/kcl-lang.io/pull/211](https://github.com/kcl-lang/kcl-lang.io/pull/211)_\\n  - _[https://github.com/kcl-lang/modules/pull/67](https://github.com/kcl-lang/modules/pull/67)_\\n\\n* Thanks to @XiaoK29 for his contributions to the code architecture refactoring of hover and reference lookup features in the KCL IDE, as well as the KCL documentation \ud83d\ude4c\\n  - _[https://github.com/kcl-lang/kcl/pull/887](https://github.com/kcl-lang/kcl/pull/887)_\\n  - _[https://github.com/kcl-lang/kcl/pull/899](https://github.com/kcl-lang/kcl/pull/899)_\\n  - _[https://github.com/kcl-lang/kcl-lang.io/pull/205](https://github.com/kcl-lang/kcl-lang.io/pull/205)_\\n* Thanks to @MeenuyD, @negz for their discussions and support regarding the integration of Crossplane KCL Composition Functions \ud83d\ude4c\\n  - _[https://github.com/kcl-lang/kcl/issues/885](https://github.com/kcl-lang/kcl/issues/885)_\\n* Thanks to @kolloch for his valuable feedback on the Bazel KCL build rule script \ud83d\ude4c\\n  - _[https://github.com/kcl-lang/rules_kcl/pull/2](https://github.com/kcl-lang/rules_kcl/pull/2)_\\n* Thanks to @Yun Lu, @Even Solberg, @Prahalad Ramji, @Matt Gowie, @ddh, and @mouuii for their valuable feedback and discussions during the promotion and usage of KCL \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### Search KCL Code and Cloud-Native Models on Artifact Hub\\n\\n- Write or validate Kubernetes configurations using KCL k8s module.\\n\\n![](/img/blog/2023-11-23-biweekly-newsletter/k8s-module.png)\\n\\n- Application delivery and and operation using the KCL Open Application Model (OAM) and the KubeVela controller.\\n\\n![](/img/blog/2023-11-23-biweekly-newsletter/oam-module.png)\\n\\n- Do configuration operations using KCL code libraries like `jsonpatch`.\\n\\n![](/img/blog/2023-11-23-biweekly-newsletter/jsonpatch-module.png)\\n\\n- Enhance application delivery experience through the [Kusion Modules ecosystem](https://github.com/KusionStack/catalog) at the client side.\\n\\nIn the future, we will explain the specific use cases and workflows of each module through a series of blogs. The source code for these modules is located at _[https://github.com/kcl-lang/modules](https://github.com/kcl-lang/modules)_. We welcome contributions from the community. \u2764\ufe0f\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. See [here](https://github.com/kcl-lang/community) to join us!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KCL v0.7.0 Milestone](https://github.com/kcl-lang/kcl/milestone/7)\\n- [KCL v0.8.0 Milestone](https://github.com/kcl-lang/kcl/milestone/8)"},{"id":"2023-11-20-search-k8s-module-on-artifacthub","metadata":{"permalink":"/blog/2023-11-20-search-k8s-module-on-artifacthub","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-11-20-search-k8s-module-on-artifacthub/index.md","source":"@site/blog/2023-11-20-search-k8s-module-on-artifacthub/index.md","title":"Kubernetes Modules Here Are All You Need!","description":"Introduction","date":"2023-11-20T00:00:00.000Z","formattedDate":"November 20, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Kubernetes","permalink":"/blog/tags/kubernetes"},{"label":"Modules","permalink":"/blog/tags/modules"},{"label":"ArtifactHub","permalink":"/blog/tags/artifact-hub"}],"readingTime":5.125,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-11-20-search-k8s-module-on-artifacthub","title":"Kubernetes Modules Here Are All You Need!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Kubernetes","Modules","ArtifactHub"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 11.09 - 11.23) | Cloud-Native Modules, Language, and Toolchain Update Express!","permalink":"/blog/2023-11-23-biweekly-newsletter"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 10.26 - 11.08) | Better IDE Experience Enhancements and More Cloud-Native Modules","permalink":"/blog/2023-11-08-biweekly-newsletter"}},"content":"## Introduction\\n\\nIn previous updates, we have added package management capability to the KCL language, solving the issue of how to obtain and publish third-party libraries. However, a new problem arises during the development process where teammates are often unsure which library to use to address their specific problem. Before using a third-party library through the package management tool, it is necessary to select the appropriate library based on the specific requirements of the cloud-native operations and the capabilities of various third-party libraries.\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nTherefore, we have leveraged the [ArtifactHub](https://artifacthub.io/) project under CNCF to build a marketplace for KCL third-party libraries. In this marketplace, users with specific needs can freely choose the third-party libraries they require, while those who have ideas and are willing to share can also contribute and share their libraries in this marketplace. Next, we will use a simple example of publishing an application to familiarize ourselves with how to retrieve KCL third-party libraries on ArtifactHub and develop KCL programs based on the library documentation.\\n\\n## Prerequisites\\n\\n- Install KCL: *https://kcl-lang.io/docs/user_docs/getting-started/install/*\\n\\n* Install kubectl: *https://kubernetes.io/docs/tasks/tools/#kubectl*\\n* Install minikube: *https://minikube.sigs.k8s.io/docs/start/*\\n\\nStart minikube using the following command:\\n\\n```shell\\nminikube start --cache-images=true\\n```\\n\\nIf the Ingress controller is not installed in your minikube, you can use the following command to install it:\\n\\n```shell\\nminikube addons enable ingress\\n```\\n\\n## HelloWorld Example\\n\\nFirst, let\'s prepare a simple JavaScript application:\\n\\n```js\\nconst express = require(\\"express\\");\\nconst app = express();\\nconst port = 8080;\\n\\n// Define a route that responds to GET requests\\napp.get(\\"/\\", (req, res) => {\\n  res.send(\\"Welcome to my web application!\\");\\n});\\n\\n// Start the server\\napp.listen(port, () => {\\n  console.log(`Web app listening at http://localhost:${port}`);\\n});\\n```\\n\\nPrepare an image for this application and upload it to the image registry:\\n\\n```dockerfile\\nFROM node:14\\nWORKDIR /usr/src/app\\nCOPY package*.json ./\\nRUN npm install\\nCOPY . .\\nEXPOSE 8080\\nCMD [ \\"node\\", \\"app.js\\" ]\\n```\\n\\nIn this example, we will use the image `ghcr.io/test/my-web-app:1.0` to demonstrate the specific content. With the preparation work completed, we can now use KCL to write the corresponding release code.\\n\\n## Use ArtifactHub to search for the modules you need\\n\\nFirst, I want to publish my my-web-app application, and I need to use a third-party library for Kubernetes to accomplish my task. By searching for the keyword `k8s` on ArtifactHub, you can see the currently available third-party libraries for `k8s`.\\n\\n![index-page](/img/blog/2023-11-20-search-k8s-module-on-artifacthub/index-page.png)\\n\\nOn the homepage of the `k8s` module, you can find the documentation and more detailed information about the `k8s` module.\\n\\n![k8s-page](/img/blog/2023-11-20-search-k8s-module-on-artifacthub/k8s-page.png)\\n\\nThe `INSTALL` button on the right provides you with the installation method for the `k8s` third-party library.\\n\\n![k8s-install-page](/img/blog/2023-11-20-search-k8s-module-on-artifacthub/k8s-install-page.png)\\n\\nSince we are using `k8s` as a dependency for our package, we can install it using the following command:\\n\\n```shell\\nkcl mod init my-kubernetes-config && cd my-kubernetes-config && kcl mod add k8s:1.28\\n```\\n\\nNext, we need to write the `deployment`, `service`, and `ingress` sections for the application release. We will use the `Deployment`, `Service`, and `Ingress` schemas from the `k8s` module we just added. For more information about schemas, you can refer to: https://kcl-lang.io/docs/next/reference/lang/tour#schema\\n\\nIf you are not familiar with these three contents, you can directly search in the details page of the model. Taking `Deployment` as an example, you can find more detailed information in the documentation.\\n\\n![deployment](/img/blog/2023-11-20-search-k8s-module-on-artifacthub/deployment.png)\\n\\nBased on the documentation, we can write the following deployment config in the `main.k` file:\\n\\n```python\\nimport k8s.api.apps.v1 as d\\n\\ndeployment = d.Deployment {\\n    metadata.name = \\"web-app-deployment\\"\\n    spec = {\\n        selector.matchLabels = {app = \\"web-app\\"}\\n        template = {\\n            metadata.labels = {app = \\"web-app\\"}\\n            spec.containers = [{\\n                name = \\"web-app\\"\\n                image = \\"ghcr.io/test/my-web-app:1.0\\"\\n                ports = [{containerPort = 80}]\\n            }]\\n        }\\n    }\\n}\\n```\\n\\nFor the `Service` section, we can find related documentation.\\n\\n![service](/img/blog/2023-11-20-search-k8s-module-on-artifacthub/service.png)\\n\\nThe corresponding `service` content is as follows:\\n\\n```shell\\nimport k8s.api.core.v1 as s\\nservice = s.Service {\\n    metadata.name = \\"web-app-service\\"\\n    spec.selector = {\\"app\\": \\"web-app\\"}\\n    spec.ports = [{\\n        port: 80\\n        targetPort: 8080\\n    }]\\n}\\n```\\n\\nAbout `Ingress`, you can find related documentation.\\n\\n![ingress](/img/blog/2023-11-20-search-k8s-module-on-artifacthub/ingress.png)\\n\\nThe corresponding `ingress` content is as follows:\\n\\n```python\\nimport k8s.api.networking.v1 as i\\n\\ningress = i.Ingress {\\n    metadata.name = \\"web-app-ingress\\"\\n    spec.rules = [\\n        {\\n            host: \\"web-app.example.com\\"\\n            http.paths = [\\n                {\\n                    path: \\"/\\"\\n                    pathType: \\"Prefix\\"\\n                    backend.service.name: \\"web-app-service\\"\\n                    backend.service.port: {\\n                        number: 8080\\n                    }\\n                }\\n            ]\\n        }\\n    ]\\n}\\n```\\n\\nFinally, add the following content to the `main.k` file to render the `deployment`, `service`, and `ingress` as the YAML stream format.\\n\\n```shell\\nmanifests.yaml_stream([\\n    deployment\\n    service\\n    ingress\\n])\\n```\\n\\nYou can compile the corresponding KCL program and apply it to the cluster using the following command.\\n\\n```shell\\nkcl run main.k | kubectl apply -f -\\n```\\n\\nAt this point, we have successfully deployed the application `my-web-app` with the help of `ArtifactHub`. Finally, let\'s take a look at the deployment effect through kubectl port forwarding. Use the following command to forward the port.\\n\\n```shell\\nkubectl port-forward service/web-app-service 8080:80\\n```\\n\\nThen use the following command or directly access `http://localhost:8080` in the browser to access our deployed application.\\n\\n```shell\\n$ curl http://localhost:8080\\n\\nWelcome to my web application!\\n```\\n\\n## Summary\\n\\nIn this blog, we demonstrated how to select the appropriate KCL third-party library on ArtifactHub through a simple application deployment. Currently, there are more than 150+ KCL third-party libraries available on ArtifactHub for you to choose from. Come and check if there is a KCL model you need!\\n\\nIn the example provided in this blog, we used KCL to write the program for deploying the application. In future updates, we will further abstract the KCL program in this blog with features such as dynamic parameters and introduce more application models such as Open Application Model (OAM), and package them into a separate module for release on ArtifactHub. If you also have KCL modules that you want to share with others, we will continue to update detailed steps and guides to help you successfully publish your package. Stay tuned!"},{"id":"2023-11-08-biweekly-newsletter","metadata":{"permalink":"/blog/2023-11-08-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-11-08-biweekly-newsletter/index.md","source":"@site/blog/2023-11-08-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 10.26 - 11.08) | Better IDE Experience Enhancements and More Cloud-Native Modules","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-11-08T00:00:00.000Z","formattedDate":"November 8, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.81,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-11-08-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 10.26 - 11.08) | Better IDE Experience Enhancements and More Cloud-Native Modules","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"Kubernetes Modules Here Are All You Need!","permalink":"/blog/2023-11-20-search-k8s-module-on-artifacthub"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 10.12 - 10.25) | FindReferences and Rename in IDE, ArtifactHub integration in KPM!","permalink":"/blog/2023-10-25-biweekly-newsletter"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation (CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (10.26 - 10.08 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL IDE Updates** - Supports for symbol find-references and rename; Optimized the formatting output for import statements and union types; Fixed the bug where file changes caused the language server to crash.\\n- **KCL Package Management Tool KPM Updates** - kpm is integrating with ArtifactHub, enabling KCL packages publishing to ArtifactHub.\\n- **KCL Language Updates** - Optimized error messages for mismatched parameter types in methods, providing clearer indications of the mismatch.\\n- **Unified Interface of KCL Command-Line** - Redesigned the command-line interface and workflow for KCL tools to achieve a unified experience.\\n\\n- **KCL IDE Update** - More intelligent configuration value completion, property list completion, function parameter completion, built-in package reference completion, and docstring completion, etc.\\n- **KCL Package Manage Tool Update** - More smooth workflow for creating and publishing KCL packages: supports automated processes for package updates and releases based on versioning systems; additionally, custom configuration of metadata for KCL packages is now allowed.\\n- **KCL Module Update** - Out-of-the-box inclusion of over 120 KCL models: [https://github.com/kcl-lang/artifacthub](https://github.com/kcl-lang/artifacthub)\\n- **KCL Language Update** - Improved error messages for schema attribute type mismatches, support for lambda type annotations, and fixes for individual compilation issues and more system libraries support e.g., validation, serialization, and deserialization of JSON/YAML strings.\\n- **KCL Import Tool Release**: Supports one-click generation of KCL configurations/models from YAML/JSON/CRD/Terraform Schema, enabling automated migration.\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @jakezhu9 for the improvement of KCL benchmark from single-threaded Rc to Arc, and for fixing the bug related to reference paths in the KCL import tool. \ud83d\ude4c https://github.com/kcl-lang/kcl-go/pull/170, etc.\\n- Thanks to @liangyuanpeng for contributing the `karmada` model package to KCL models, welcome! \ud83d\ude4c https://github.com/kcl-lang/artifacthub/pull/48/files\\n- Additionally, thanks to @Matt Gowie, @ddh for their attention to KCL and valuable feedback. \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### IDE Extension Updates\\n\\nThe KCL IDE extension has added a large number of completion suggestions, focusing on the core aspect of configuration definition, simplifying the mental process of users when writing configurations based on models, and improving the efficiency of configuration editing. Additionally, parameter completion when invoking built-in functions has been enhanced. Talk is cheap, let\'s directly see the results:\\n\\n![](/img/blog/2023-11-08-biweekly-newsletter/module-function-completion.gif)\\n\\n![](/img/blog/2023-11-08-biweekly-newsletter/config-completion.gif)\\n\\nFor the model design phase, quick generation of document strings has also been added, reducing the need for manual boilerplate typing:\\n\\n![](/img/blog/2023-11-08-biweekly-newsletter/docstring-gen.gif)\\n\\n### KCL Package Manager Updates\\n\\nThe package management tool has now interconnected the core workflow of KCL package creation, update, code review, and release. Based on this, over 120+ out-of-the-box KCL model packages have been added. Users can refer to the [Writing and Publishing Kubernetes KCL Code Packages guide](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/publish-modules/) to start using them immediately.\\n\\n### KCL Language Updates\\n\\nThe optimization of error message output in the KCL compilation command continues to progress, aiming to provide clear and understandable guidance to help developers quickly locate and fix issues and write correct code. Recently, KCL has optimized the error messages for schema field type mismatches:\\n\\n- before:\\n  ![](/img/blog/2023-11-08-biweekly-newsletter/schema-expr-type-error-before.png)\\n\\n- after:\\n  ![](/img/blog/2023-11-08-biweekly-newsletter/schema-expr-type-error-after.png)\\n\\nAdditionally, support has been added for adding type annotations in lambda expressions, and system libraries now support validation, serialization, and deserialization of JSON/YAML strings. The following issues have been fixed: cache invalidation for KCL programs with third-party libraries, path conflicts when compiling imported files across kcl.mod, and semantic checks for default value of KCL functions.\\n\\n### KCL Import Tool\\n\\nSupport for one-click generation of KCL configurations/models from YAML/JSON/CRD/Terraform Schema enables automated migration. Please refer to the [One-click Migration from Kubernetes Ecosystem to KCL guide](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/adopt-from-kubernetes) for more information.\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community.\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.7.0 Milestone](https://github.com/kcl-lang/kcl/milestone/7)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-10-25-biweekly-newsletter","metadata":{"permalink":"/blog/2023-10-25-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-25-biweekly-newsletter/index.md","source":"@site/blog/2023-10-25-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 10.12 - 10.25) | FindReferences and Rename in IDE, ArtifactHub integration in KPM!","description":"KCL is a constraint-based record and functional language hosted by Cloud Native Computing Foundation(CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-10-25T00:00:00.000Z","formattedDate":"October 25, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.36,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-25-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 10.12 - 10.25) | FindReferences and Rename in IDE, ArtifactHub integration in KPM!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"KCL Biweekly Newsletter (2023 10.26 - 11.08) | Better IDE Experience Enhancements and More Cloud-Native Modules","permalink":"/blog/2023-11-08-biweekly-newsletter"},"nextItem":{"title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","permalink":"/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is a constraint-based record and functional language hosted by Cloud Native Computing Foundation(CNCF) that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (10.12 - 10.25 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL IDE Updates** - Supports for symbol find-references and rename; Optimized the formatting output for import statements and union types; Fixed the bug where file changes caused the language server to crash.\\n- **KCL Package Management Tool KPM Updates** - kpm is integrating with ArtifactHub, enabling KCL packages publishing to ArtifactHub.\\n- **KCL Language Updates** - Optimized error messages for mismatched parameter types in methods, providing clearer indications of the mismatch.\\n- **Unified Interface of KCL Command-Line** - Redesigned the command-line interface and workflow for KCL tools to achieve a unified experience.\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @jakezhu9 for enhancing the KCL syntax parsing unit tests, migrating some test cases to the snaptest framework \ud83d\ude4c [https://github.com/kcl-lang/kcl/pull/794](https://github.com/kcl-lang/kcl/pull/794)\\n- Thanks to @opsnull for correcting code examples in kcl-lang.io website \ud83d\ude4c [https://github.com/kcl-lang/kcl-lang.io/pull/182](https://github.com/kcl-lang/kcl-lang.io/pull/182)\\n- Thanks to @prahaladramji for fixing and optimizing the formatting functionality in the KCL IntelliJ plugin \ud83d\ude4c [https://github.com/kcl-lang/intellij-kcl/pull/15](https://github.com/kcl-lang/intellij-kcl/pull/15), etc.\\n- Thanks to @steeling, @prahaladramji, @liangyuanpen, @Kory Taborn, and others for valuable feedback and discussions while using KCL and the toolchain \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### IDE Extension Updates\\n\\nIn the upcoming release, the KCL IDE extension will support find/go-to references navigation, symbol renaming, and some optimizations for formatting import statements and union types. Additionally, virtual file system-related bugs causing language service crashes have been fixed.\\n\\nGo-to references:\\n![](/img/docs/tools/Ide/vs-code/FindRefs.png)\\n\\nRename symbols:\\n![](/img/docs/tools/Ide/vs-code/Rename.gif)\\n\\nFormatting improvements for import statements and union types: optimized behavior for newlines between reference statements and other code blocks (formatted as a single newline) and spacing between union types (formatted with `|` as separators):\\n![](/img/blog/2023-10-25-kcl-biweekly-newsletter/Format.gif)\\n\\n### KCL Package Manager Updates\\n\\nIn the upcoming release, KPM will support integration with [ArtifactHub](https://artifacthub.io/). You can now submit a PR to the [kcl-lang Registry repository](https://github.com/kcl-lang/artifacthub) to publish your KCL packages on ArtifactHub. The pre-uploaded KCL Kubernetes package can be seen on the [ArtifactHub staging page](https://staging.artifacthub.io/packages/search?ts_query_web=kcl&sort=relevance&page=1). The functionality will be released in version v0.6.1:\\n\\n![](/img/docs/tools/kpm/artifacthubStaging.png)\\n\\n### KCL Language Updates\\n\\nThe compilation command of KCL continues to improve error message output, aiming to provide clear and understandable guidance to help developers quickly identify and fix errors while writing correct code. Recently, error messages related to method parameter type mismatches have been optimized, clearly indicating parameter type mismatches:\\n\\n![](/img/blog/2023-10-25-kcl-biweekly-newsletter/error-msg.png)\\n\\nAdditionally, a fix addressed the issue of lazy evaluation in property assignments, deferring the computation and constraint validation of property assignments until after configuration merging to avoid unnecessary compilation errors.\\n\\n### Unified Interface of KCL Command-Line\\n\\nWe are redesigning the command-line interface of KCL tools to achieve a unified user workflow, seamless integration with related tools and multi-language APIs, and command-line tool extensibility. Welcome to join the discussion if anyone are insterested: https://github.com/kcl-lang/kcl/issues/756.\\n\\n### Community Updates\\n\\nWith the inclusion in CNCF Sandbox, we are glad to announce that the CNCF KCL Slack channel is now available for KCL-related discussions. Feel free to join:\\n\\n1. Join the CNCF workspace by providing your email address: https://communityinviter.com/apps/cloud-native/cncf\\n2. Join the CNCF KCL channel: https://cloud-native.slack.com/archives/C05TC96NWN8\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community.\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.7.0 Milestone](https://github.com/kcl-lang/kcl/milestone/7)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-10-23-cloud-native-supply-chain-krm-kcl-spec","metadata":{"permalink":"/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/index.md","source":"@site/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/index.md","title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","description":"This blog is a review of the content of the KCL speech at the 2023 CNCF KCD Hangzhou Conference. Activity link//community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-hangzhou-2023/","date":"2023-10-23T00:00:00.000Z","formattedDate":"October 23, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":14.12,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-23-cloud-native-supply-chain-krm-kcl-spec","title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 10.12 - 10.25) | FindReferences and Rename in IDE, ArtifactHub integration in KPM!","permalink":"/blog/2023-10-25-biweekly-newsletter"},"nextItem":{"title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","permalink":"/blog/2023-10-21-kcl-kcd-hangzhou-meeting"}},"content":"> This blog is a review of the content of the KCL speech at the 2023 CNCF KCD Hangzhou Conference. Activity link: [https://community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-hangzhou-2023/](https://community.cncf.io/events/details/cncf-kcd-hangzhou-presents-kcd-hangzhou-2023/)\\n\\n## Background\\n\\n> With the development of cloud-native technology, we are increasingly shifting towards cloud infrastructure. Infrastructure as code (IaC) tools like Kubernetes and Terraform have become increasingly popular for managing and deploying cloud API-based applications. However, this popularity has also brought about complexity and cognitive burden issues that have reached their peak in recent years.\\n\\n![cognitive-loading](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/cognitive-loading-en.jpg)\\n\\nFor Kubernetes, as the most widely used container orchestration system, Gartner predicts that by 2022, over 75% of organizations globally will be running containerized applications in production. The container management market is estimated to be around 300 million dollars, projected to surpass 1 billion dollars by 2025. Additionally, Kubernetes is steadily moving out of its troubled phase towards maturity and wider adoption<sup>[1]</sup>.\\n\\nFor Terraform, as the most widely used IaC tool, as of the time of writing this article, the Terraform VS Code plugin has an installation count of around 3.2 million, roughly one-third of the installation count of the Go VS Code plugin (around 10 million), and even surpasses the installation count of many general-purpose programming languages. For example, the Rust VS Code plugin has an installation count of around 2.3 million. Furthermore, HCL is the fastest-growing programming language on GitHub in 2022, surpassing all other general-purpose and domain-specific programming languages, forming a wide developer ecosystem<sup>[2]</sup>.\\n\\nFrom this, it can be seen that Kubernetes and Terraform are becoming indispensable infrastructure projects in the cloud-native field and will continue to grow in the coming years. Although the nature of these two projects is not entirely the same, they are converging and becoming increasingly complex.\\n\\nThe increasing complexity of the cloud API represented by Kubernetes and Terraform can be attributed to several factors<sup>[3]</sup><sup>[4]</sup><sup>[5]</sup>:\\n\\n- **Increasing capabilities**: Kubernetes and cloud APIs are constantly evolving to meet the growing demands of applications and cloud computing. To meet user demands, they continuously introduce new features and capabilities such as auto-scaling, service discovery, load balancing, and permission management. The introduction of these new features increases the complexity of the system. Although we already have various automation methods, over time, the number of different resource types, potential settings for these resource types, and the complexity of relationships between these resource types grow exponentially.\\n- **Complex configuration management requirements**: As the scale of applications grows, configuring and managing Kubernetes and cloud APIs becomes increasingly complex. For example, managing a large number of container instances and resources, configuring complex networking and storage, implementing high availability and load balancing, and repeatedly performing configurations for different environments and topologies. These complex configuration and management requirements increase the complexity of Kubernetes and cloud APIs, often resulting in the emergence of \\"YAML engineers\\" or \\"markup language human-editing engineers\\" in the Kubernetes field.\\n\\nFor cloud APIs, we can leverage IaC tools like Terraform to obtain a large number of pre-written module configurations and providers. However, for Kubernetes, there is still a lack of lightweight client-side configuration composition and abstraction solutions. Existing solutions or specifications struggle to strike a balance between abstraction capabilities and scalability. In extreme scenarios, developers often write a lot of glue code and scripts to handle configurations, which restricts stability and efficiency.\\n\\nTherefore, we propose the KCL project and the KRM KCL specification, hoping to fill the gap in configuration languages and tools in the lightweight client-side cloud-native dynamic configuration field with more modern declarative configuration languages and tools. We aim to address the following issues:\\n\\n- **Dimension explosion**: Most static configurations, such as Kubernetes YAML configurations in the cloud-native field, need to be configured separately for each environment. In the worst case, it may introduce difficult-to-debug errors involving cross-environment dependencies, leading to poor stability and scalability.\\n- **Configuration drift**: There is often no standardized way to manage the dynamic configurations of applications and infrastructure for different environments. Adopting non-standard methods such as scripting and piecing together glue code can result in exponential complexity and configuration drift.\\n- **Cognitive burden**: Kubernetes and other platform technologies that serve as building platforms excel in unifying infrastructure details at the underlying level. However, they lack higher-level software delivery abstractions, which result in a higher cognitive burden for ordinary developers and affect the software delivery experience of higher-level application developers.\\n\\n## Concepts\\n\\n### KCL\\n\\n![kcl-intro](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/kcl-intro-en.jpg)\\n\\nKCL is a specialized configuration policy language for the cloud-native domain. It was open-sourced in June 2022 and became a CNCF Sandbox project hosted by the CNCF foundation in September 2023. KCL aims to improve the user experience of writing cloud-native configuration policies and programmability at the Kubernetes API layer. The KCL project is currently included in the CNCF foundation\'s Automation & Configuration Landscape. The \\"C\\" in KCL stands for Configuration, the \\"L\\" stands for Language, and the \\"K\\" is derived from the first letter of Kubernetes<sup>[6]</sup>.\\n\\nUnlike general-purpose programming languages, KCL is a domain-specific programming language that solves nearly infinite variations of business scenarios and complexities with a convergent set of syntax and semantics. For example, within the Kubernetes domain alone, there are thousands of resources and a fragmented Operator ecosystem in the community. KCL encapsulates the thought process and approach of writing complex configurations and policies into its language features, avoiding the security risks and side effects associated with using general-purpose languages for configuration.\\n\\nAs a configuration language, KCL provides the most important functionality for application and platform developers/SREs, which is **dynamic configuration management**. Through code abstraction, we can build an application-centric model that shields developers from the complexities of infrastructure and platform concepts and provides them with an interface that is centered around the application and easy to understand. Additionally, KCL allows platform engineers to quickly extend and define their own models, and it provides rich manageability capabilities, including out-of-the-box KCL code libraries, semantic versioning, OCI Registry, language toolchains, and automation support.\\n\\nFurthermore, KCL operates within a completely open cloud-native ecosystem and is not tightly coupled to any orchestration/engineering tools or Kubernetes controllers. In cloud-native supply chain scenarios and large-scale operational scenarios, KCL can provide API abstraction, composition, and validation capabilities for both the client and runtime. Users can choose suitable engines such as Kubectl<sup>[7]</sup>, KusionStack<sup>[8]</sup>, KubeVela<sup>[9]</sup>, or Helmfile<sup>[10]</sup> to combine with KCL and apply configurations to the cluster.\\n\\n![kcl-concept](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/kcl-concept-en.jpg)\\n\\nIn addition, KCL itself is a modern, high-level domain-specific programming language, which is a compiled static and strongly-typed language. KCL provides developers with the core capabilities of **configuration (config)**, **model abstraction (schema)**, **logic (lambda)**, and **policies (rules)** through a record and function-oriented language design.\\n\\nKCL aims to provide programmability independent of the runtime, without providing system functionalities such as threads and IO locally. It strives to offer programming support that is stable, secure, low-noise, low side-effect, high-performance, easy to automate, and easy to manage in order to solve domain-specific problems.\\n\\n### KRM KCL Specification\\n\\n![krm-kcl](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/krm-kcl-en.jpg)\\n\\nThe KRM KCL specification is a configuration specification based on the Kubernetes Resource Model (KRM). KRM is a generic configuration model used to describe and manage various cloud-native resources such as containers, pods, and services. KRM provides a unified way to define and manage these resources, enabling them to be portable and reusable across different environments<sup>[11]</sup>.\\n\\nAs one of the official Kubernetes specifications, the core concept of KRM is KRM functions. The input of KRM functions is a set of Kubernetes resources and the configuration of the KRM function, and the output is a set of Kubernetes resources along with the results of the function execution, such as error messages and debug information. KRM KCL is the implementation of KRM functions using KCL code and extends it with support for various code sources such as OCI Registry, Git, and HTTPS.\\n\\nIn the KRM KCL specification, the behaviors of the KCL configuration model are mainly divided into three categories:\\n\\n- **Mutation**: Takes input KCL parameters `params` and a list of KRM resources and outputs a modified list of KRM resources.\\n- **Validation**: Takes input KCL parameters `params` and a list of KRM resources and outputs the list of KRM resources and resource validation results.\\n- **Abstraction**: Takes input KCL parameters `params` and outputs a list of KRM resources.\\n\\nUsing KCL, we can achieve the following capabilities programmatically:\\n\\n- Modify resources using KCL, such as adding/modifying label tags or annotation comments based on certain conditions or injecting Sidecar container configurations in all Kubernetes Resource Model (KRM) resources containing PodTemplate.\\n- Validate all KRM resources using KCL schema, such as constraining containers to only be launched in a root manner.\\n- Generate KRM resources or abstract/combine different Kubernetes APIs using the abstraction model, for example, instantiating a web application configuration using the \\"web-service\\" model.\\n\\nWith the help of KCL IDE and KCL package management tools, we can write models and upload them to the OCI Registry for model reuse. We can programmatically extend the support for the KRM KCL specification, and these models can be used separately in the client or runtime based on specific scenario requirements.\\n\\n## Developer Experience\\n\\nRegarding the mentioned domain-specific problems and the related concepts of KCL, we primarily provide three aspects of support to users: language, toolchain, and cloud-native integrations.\\n\\n![workspace](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/workspace.png)\\n\\nAlthough KCL is a domain-specific language, it is comprehensive in its capabilities. KCL provides toolchain functionalities that are equivalent to general-purpose languages, such as formatting, testing, documentation, package management, etc., to assist in writing, understanding, and validating configurations or policies. IDE plugins like VS Code and Playground reduce the cost of configuration writing and sharing. Automation of configuration management and execution is achieved through multilingual SDKs in Rust, Go, and Python.\\n\\n![ide](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/ide.png)\\n\\nFor IDE plugins, KCL currently mainly supports VS Code, IntelliJ, and NeoVim. These plugins, based on the same KCL Language Server, offer features like autocompletion, navigation, hover, code refactoring, and formatting<sup>[12]</sup>.\\n\\n![integration](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/integration-en.jpg)\\n\\nAs a CNCF project, KCL is integrated with many other CNCF ecosystem projects. For example, KCL provides plugins for existing CNCF ecosystem configuration management tools like Kubectl, Helm, Kustomize, kpt, helmfile, etc. At runtime, KCL offers the KCL Kubernetes Operator to meet various configuration management needs. Additionally, we provide the following integration support:\\n\\n- **Multilingual Support**: We offer multilingual SDKs to help users work with KCL in different programming languages and integrate it into their own applications.\\n- **Package Management Support**: We provide KCL package management tools that allow distribution and reuse of configurations and policy code through standard OCI supply chain methods like Harbor, Docker Hub, GitHub Packages, etc.\\n- **Schema and Data Migration Support**: We support one-click migration of schema and data from other ecosystems to KCL Schema, including Go/Rust struct definitions, JsonSchema, Protobuf, OpenAPI, Terraform Provider Schema, JSON, YAML, and more.\\n\\n![artifact-hub](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/artifact-hub.png)\\n\\n![artifact-hub-k8s](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/artifact-hub-k8s.png)\\n\\nFurthermore, KCL supports integration with ArtifactHub. You can publish your KCL package to ArtifactHub by submitting a PR to the `kcl-lang/artifacthub` repository. This allows you to see the effects of the uploaded KCL package on the ArtifactHub page, such as the k8s package<sup>[13]</sup>.\\n\\nIn addition to that, KCL provides many out-of-the-box cloud-native models, primarily covering **Kubernetes** and **Terraform** models. Developers can easily add corresponding configuration model dependencies or view the KCL source code with just one line of KCL command.\\n\\n![performance](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/performance.png)\\n\\nIn addition to the external work related to language, toolchain, and cloud-native integration, we have also made significant efforts to ensure stability and performance within KCL. In scenarios with large code bases or high computational requirements, KCL outperforms languages like CUE, Jsonnet, HCL, etc. Furthermore, KCL\'s progressive static typing system, immutability, schema, and validation rules ensure further stability of configurations.\\n\\n## Case Studies\\n\\n### Kubernetes\\n\\nKCL currently focuses on the cloud-native domain, particularly in Kubernetes scenarios.\\n\\n![k8s-mutation](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/k8s-mutation-en.jpg)\\n\\nAs a small programming language within the cloud-native domain, KCL can be directly used to address simple tasks in the environment. For example, the `append-env` model can be used to inject environment variables into Kubernetes resources without the need for scripting. These models are shareable, reusable, and have been tested for code reliability, stability, and scalability.\\n\\n![k8s-validation](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/k8s-validation-en.jpg)\\n\\nIn addition to in-place editing of Kubernetes configurations, KCL offers a variety of out-of-the-box models for Kubernetes configuration validation. These models address security and compliance issues in the cloud-native supply chain. For example, the `disallow-svc-lb` model can be used to validate whether the `Service` resource incorrectly sets the `LoadBalancer` type, and the `https-only` model can verify if the `Ingress` resource contains explicit annotations set to use https.\\n\\nCompared to other policy tools or engines, the advantage of using KCL is that a validation model can be used both on the client side and at runtime. Schema and constraint conditions can be defined simultaneously in the programming language interface, without the need for additional OpenAPI Schema or JSON Schema integration.\\n\\n![kcl-operator](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/kcl-operator-en.jpg)\\n\\nIn addition to abstracting, editing, and verifying configurations on the client side, KCL also provides runtime support. KCL Operator provides Kubernetes cluster integration, allowing Access Webhook to generate, mutate, or validate resources based on KCL configuration when applying Kubernetes resources to the cluster. Webhook will capture creation, application, and editing operations, and `KCLRun` will execute resources on the configuration associated with each operation<sup>[14]</sup>.\\n\\nUsing the KCL Operator, resource configuration management and security verification can be automated in a lightweight manner within the Kubernetes cluster through KCL code in a few steps, without the need to repeatedly develop Webhook Server to dynamically modify and verify configurations at runtime.\\n\\n### Terraform\\n\\nAnother scenario that KCL focuses on is the ecosystem model of Terraform.\\n\\n![tf-validation](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/tf-validation-en.jpg)\\n\\nIn the cloud-native supply chain scenario, apart from the user\'s business code, it is often necessary to verify the security of the Infrastructure as Code (IaC) code. Therefore, KCL also provides validation models related to Terraform. For example, the example shown in the image only requires a few lines of KCL code to enforce the requirement of not deleting resources during automatic scaling operations in an AWS resource group<sup>[15]</sup>.\\n\\nCompared to other policy engines or tools, KCL supports easy conversion from Terraform Provider Schema to KCL Schema, making policy writing more accessible.\\n\\n### IaC & GitOps\\n\\n![gitops](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/gitops-en.jpg)\\n\\nWhether it is the Kubernetes model or the Terraform model, and whether it is using the standalone KCL or KRM KCL configuration format, KCL supports integration with various CI/CD and GitOps tools. KCL allows developers to define the resources required for an application in a declarative manner. By combining KCL with GitOps tools, we can achieve better Infrastructure as Code (IaC) implementation, improve deployment efficiency, and simplify application configuration management<sup>[16]</sup>.\\n\\nWith GitOps, developers and operations teams can manage the deployment of applications by separately modifying application and configuration code. The GitOps toolchain can automatically change configurations based on the automation capabilities of KCL, enabling continuous deployment and ensuring consistency. If any issues arise, the GitOps toolchain allows for quick rollbacks.\\n\\n![app-delivery](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/app-delivery-en.jpg)\\n\\nKCL can also be used in conjunction with various CI/CD and application configuration delivery engines within an enterprise, such as KusionStack, to achieve separation of concerns, application-centric programmable model interfaces, and GitOps workflows. This simplifies the deployment and operations of scalable applications in today\'s hybrid and multi-cloud environments, enhancing release and operations efficiency as well as developer experience.\\n\\n![k8s-abstraction](/img/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec/k8s-abstraction-en.jpg)\\n\\nFurthermore, with the Schema structure and automation API of KCL, we can integrate KCL into external systems and use CLI/API/UI forms to automate the addition, deletion, modification, and retrieval of KCL configurations. This not only enables GitOps and Infrastructure as Code (IaC) but also provides a user-friendly configuration management interface for developers. It supports changes to KCL code in the form of UI forms, improving the efficiency of configuration management and application delivery while avoiding configuration drift and other issues.\\n\\n## Summary\\n\\nThis article mainly reviews the content of the KCL presentation at the CNCF KCD community conference. It discusses the challenges encountered in the cloud-native domain, especially in the Kubernetes and Terraform ecosystems, as well as the concepts, user experiences, and practices of the KRM KCL specification.\\n\\nOf course, the problems that KCL can solve and the scenarios it can be applied to are much broader than what is covered in this article. Due to the limitations of the article length, we will continue to share the best practices of adopters in the community. We also welcome everyone to join our community for further discussions and exchanges \u2764\ufe0f.\\n\\n## More Resources\\n\\nFor more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [KusionStack Website](https://kusionstack.io/)\\n- [KusionStack Repo](https://github.com/KusionStack/kusion)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\\n\\n## Reference\\n\\n- [1] Forecast Analysis: Container Management (Software and Services), Worldwide: [https://www.gartner.com/en/documents/3985796](https://www.gartner.com/en/documents/3985796)\\n- [2] The top programming languages: [https://octoverse.github.com/2022/top-programming-languages](https://octoverse.github.com/2022/top-programming-languages)\\n- [3] Declarative Application Management in Kubernetes: [https://docs.google.com/document/d/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU/edit#](https://docs.google.com/document/d/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU/edit#)\\n- [4] CNCF Platform Engineering Whitepaper: [https://tag-app-delivery.cncf.io/whitepapers/platforms/](https://tag-app-delivery.cncf.io/whitepapers/platforms/)\\n- [5] Google SRE Workbook: Configuration Specifics: [https://sre.google/workbook/configuration-specifics/](https://sre.google/workbook/configuration-specifics/)\\n- [6] KCL Website: [https://kcl-lang.io/](https://kcl-lang.io/)\\n- [7] Kubectl: [https://kubernetes.io/docs/reference/kubectl/](https://kubernetes.io/docs/reference/kubectl/)\\n- [8] KusionStack: [https://kusionstack.io](https://kusionstack.io)\\n- [9] KubeVela: [https://kubevela.net](https://kubevela.net)\\n- [10] Helmfile: [https://github.com/helmfile/helmfile](https://github.com/helmfile/helmfile)\\n- [11] KRM KCL Specification: [https://github.com/kcl-lang/krm-kcl](https://github.com/kcl-lang/krm-kcl)\\n- [12] KCL IDE Extension: [https://kcl-lang.io/docs/tools/Ide/](https://kcl-lang.io/docs/tools/Ide/)\\n- [13] ArtifactHub KCL Integration: [https://artifacthub.io/](https://artifacthub.io/)\\n- [14] KCL Operator: [https://github.com/kcl-lang/kcl-operator](https://github.com/kcl-lang/kcl-operator)\\n- [15] Terraform KCL Policy: [https://kcl-lang.io/docs/user_docs/guides/working-with-terraform/validation](https://kcl-lang.io/docs/user_docs/guides/[]working-with-terraform/validation)\\n- [16] GitOps using KCL: [https://kcl-lang.io/docs/user_docs/guides/gitops/gitops-quick-start](https://kcl-lang.io/docs/user_docs/guides/gitops/gitops-quick-start)"},{"id":"2023-10-21-kcl-kcd-hangzhou-meeting","metadata":{"permalink":"/blog/2023-10-21-kcl-kcd-hangzhou-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-21-kcl-kcd-hangzhou-meeting/index.md","source":"@site/blog/2023-10-21-kcl-kcd-hangzhou-meeting/index.md","title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","description":"Download PDF (Chinese)","date":"2023-10-21T00:00:00.000Z","formattedDate":"October 21, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-21-kcl-kcd-hangzhou-meeting","title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"A New Paradigm for Cloud Native Configuration and Policy Management - KRM KCL Specification","permalink":"/blog/2023-10-23-cloud-native-supply-chain-krm-kcl-spec"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","permalink":"/blog/2023-10-11-biweekly-newsletter"}},"content":"[Download PDF (Chinese)](https://kcl-lang.io/talks/kcl-cncf-kcd-hangzhou2023.pdf)\\n\\n![Talk Cover](/img/blog/2023-10-21-kcl-kcd-hangzhou-meeting/talk-cover.png)"},{"id":"2023-10-11-biweekly-newsletter","metadata":{"permalink":"/blog/2023-10-11-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-10-11-biweekly-newsletter/index.md","source":"@site/blog/2023-10-11-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-10-11T00:00:00.000Z","formattedDate":"October 11, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.985,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-10-11-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"KCL Introduction at CNCF KCD Hangzhou 2023 Meeting","permalink":"/blog/2023-10-21-kcl-kcd-hangzhou-meeting"},"nextItem":{"title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","permalink":"/blog/2023-09-19-kcl-joining-cncf-sandbox"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (09.07 - 10.11 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL v0.6.0 Release on 9/15** - Updates to the language, toolchain, and community integration. Detailed information could be found [here](/blog/2023-09-15-kcl-0.6.0-release/index.md).\\n- **KCL IDE Updates** - Supports for hover tooltips on standard library and built-in functions, and quick fixes for KCL code errors. And a plugin compatible with Intellij IDEA 2023.2 is released.\\n- **KCL Package Management Tool KPM Updates** - `kpm run` now could compile KCL files and embeded with the import tool.\\n- **KCL Documentation Tool Updates** - The docstring Examples section is added to the output documentation.\\n- **KCL Language Updates** - Optimized error message output and added suggestions for fixing some errors.\\n\\n**\ud83d\udcf0 Official Website and Use Case Updates**\\n\\n- KCL website adds v0.6.0 documentation version.\\n- More KCL model examples for containers, services, and Pod Security Policy (PSP): https://github.com/kcl-lang/krm-kcl/tree/main/examples\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @jakezhu9 for contributing the KCL Import tool to convert Terraform Schema to KCL Schema \ud83d\ude4c [https://github.com/kcl-lang/kcl-go/pull/152](https://github.com/kcl-lang/kcl-go/pull/152)\\n- Thanks to @jakezhu9 for contributing the integration of the Import tool to kpm \ud83d\ude4c [https://github.com/kcl-lang/kpm/pull/194](https://github.com/kcl-lang/kpm/pull/194)\\n- Thanks to @zwpaper for contributions to KCL documentation and Tree Sitter Grammar \ud83d\ude4c [https://github.com/kcl-lang/tree-sitter-kcl/pull/1](https://github.com/kcl-lang/tree-sitter-kcl/pull/1), etc.\\n- Thanks to @mrgleeco, @ghpu, @steeling, @prahaladramji, @zwpaper, and others for valuable feedback and discussions while using KCL and the toolchain \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### IDE Extension Updates\\n\\nIn the recent v0.6.0 release, the KCL IDE plugin has enhanced on hover tooltips for the standard library and builtin functions, along with support for quick fixes for KCL code errors. Additionally, end-to-end tests for the language server and integration tests for the konfig repository have been added to ensure the stability and iteration of the IDE plugin. In the upcoming release, a new `kcl-language-server version` subcommand has been added to display version information. Please refer to [https://kcl-lang.io/docs/user_docs/getting-started/install/#2-install-kcl-ide-extension](https://kcl-lang.io/docs/user_docs/getting-started/install/#2-install-kcl-ide-extension) for instructions on how to upgrade and install the KCL IDE extension in various IDE platforms.\\n\\n![](/img/docs/tools/Ide/vs-code/hover-built-in.png)\\n\\n#### IntelliJ Plugin\\n\\nBesides, the IntelliJ plugin is now compatible with version 2023.2+ and can be downloaded from the following link: [https://github.com/kcl-lang/intellij-kcl/releases](https://github.com/kcl-lang/intellij-kcl/releases)\\n\\n### KCL Package Manager Updates\\n\\nThe kpm run command now supports compiling KCL files and has integrated an import tool. Additionally, the `--quiet` option has been added to suppress output logs.\\n\\n![](/img/docs/tools/kpm/kpm-run-file.png)\\n\\n### KCL Language Updates\\n\\nIn the upcoming release, the KCL compilation command has optimized error message output and added repair suggestions on some cases:\\n\\n![](/img/blog/2023-10-11-kcl-biweekly-newsletter/error-suggestion.png)\\n\\n### KCL Models Updates\\n\\nIn the past few weeks, we have provided more usage examples for configuring and validating containers, services, and Pod Security Policy (PSP).\\n\\n- readonly-root-fs\\n- allowed-image-repos\\n- deny-all\\n- deny-endpoint-edit-default-role\\n- disallow-ingress-wildcard\\n- disallow-svc-lb\\n- disallow-svc-node-port\\n- disallowed-image-repos\\n- horizontal-pod-auto-scaler\\n- psp-allow-privilege-escalation\\n- psp-app-armor\\n- psp-capabilities\\n- psp-flexvolume-drivers\\n- required-image-digests\\n- required-probes\\n- validate-auto-mount-service-account-token\\n- validate-container-limits\\n- validate-container-requests\\n- validate-deprecated-api\\n- k8s_manifests_containers\\n\\nYou can refer to the corresponding examples to incorporate the above configurations and validations: [https://github.com/kcl-lang/krm-kcl/tree/main/examples](https://github.com/kcl-lang/krm-kcl/tree/main/examples). Now, let\'s explain using the Kubectl KCL plugin and the disallow-svc-lb model. The purpose of disallow-svc-lb is to validate Service resources and disallow the use of LoadBalancer as the Service type. Write the following YAML file (manifests.yaml):\\n\\n```yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: disallow-svc-lb\\n  annotations:\\n    krm.kcl.dev/version: 0.0.1\\n    krm.kcl.dev/type: validation\\n    documentation: >-\\n      A validation that prevents the creation of Service resources of type `LoadBalancer`\\nspec:\\n  source: oci://ghcr.io/kcl-lang/disallow-svc-lb\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: my-service\\nspec:\\n  selector:\\n    app.kubernetes.io/name: MyApp\\n  ports:\\n    - name: http\\n      protocol: TCP\\n      port: 80\\n  type: LoadBalancer # The service type is incorrectly set to LoadBalancer.\\n```\\n\\nUsing the Kubectl KCL tool for resource validation on the client-side, we will get the following result:\\n\\n```shell\\nkubectl kcl apply -f manifests.yaml\\n```\\n\\nThe output is\\n\\n```\\nA validation that prevents the creation of Service resources of type `LoadBalancer`, for Service: my-service\\n```\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community.\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.7.0 Milestone](https://github.com/kcl-lang/kcl/milestone/7)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-09-19-kcl-joining-cncf-sandbox","metadata":{"permalink":"/blog/2023-09-19-kcl-joining-cncf-sandbox","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-19-kcl-joining-cncf-sandbox/index.md","source":"@site/blog/2023-09-19-kcl-joining-cncf-sandbox/index.md","title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","description":"kcl-joining-cncf-sandbox","date":"2023-09-19T00:00:00.000Z","formattedDate":"September 19, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":9.505,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-19-kcl-joining-cncf-sandbox","title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 09.07 - 10.11) | v0.6.0 Is Out - Enhancement on IDE Extensions and Package Management!","permalink":"/blog/2023-10-11-biweekly-newsletter"},"nextItem":{"title":"KCL v0.6.0 Release Blog","permalink":"/blog/2023-09-15-kcl-0.6.0-release"}},"content":"![kcl-joining-cncf-sandbox](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/kcl-joining-cncf-sandbox-en.png)\\n\\n**On September 20, 2023, the KCL project was approved by the TOC of the Cloud Native Computing Foundation (CNCF) and officially became a CNCF Sandbox project**.\\n\\nThis means that KCL has gained recognition from the cloud native open source community, ensuring the neutrality of the project and facilitating the participation of developers and partners in project construction. It is a significant step towards dynamic configuration management and automation capabilities for cloud native application delivery.\\n\\n\x3c!--TODO: CNCF Sandbox Review Figure--\x3e\\n\\n- _Project Link: https://github.com/kcl-lang/kcl_\\n- _Project Website: https://kcl-lang.io_\\n\\nBy joining CNCF as a sandbox project, the KCL community aims to attract more developers and users to contribute and further promote the mature application of the project in cloud native scenarios. In addition, joining CNCF provides KCL with an enhanced platform for collaboration and innovation. It offers an opportunity to engage with a diverse community of developers, organizations, and industry experts at the forefront of cloud native technology. We look forward to collaborating with other CNCF projects, contributing our technical expertise, and exploring the possibilities of integrating with more CNCF projects.\\n\\n## What is CNCF?\\n\\nCNCF, short for Cloud Native Computing Foundation, is a sub-foundation under the Linux Foundation. CNCF is dedicated to building a sustainable ecosystem for cloud native software, covering areas such as storage, computing, orchestration, scheduling, CI/CD, DevOps, service governance, and service gateways.\\n\\n_Kubernetes is one of the most representative projects of CNCF_.\\n\\n## What is CNCF Sandbox Project?\\n\\n![cncf-sandbox-logo](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/cncf-sandbox-logo.png)\\n\\nThe CNCF community classifies projects into Sandbox, Incubating, and Graduated. Well-known graduated projects include Kubernetes, Prometheus, Istio, ETCD, Containerd, ArgoCD, and Helm. For a complete list of graduated and incubating projects, you can visit [https://www.cncf.io/projects/](https://www.cncf.io/projects/).\\n\\nSandbox is a category created by CNCF to provide a beneficial and neutral home for open source projects to promote collaboration and development. Projects selected for the Sandbox are recognized by the CNCF Technical Oversight Committee (TOC) and have the potential for experimentation and development. You can find the list of Sandbox projects at https://www.cncf.io/sandbox-projects/. To enter the Sandbox, at least 66% of the TOC members (all 11 people listed at https://github.com/cncf/toc#members) need to vote in favor, which means at least 8 people.\\n\\n## What is KCL?\\n\\nKCL is an open-source, constraint-based record and function language. It aims to improve the writing of complex configurations, such as cloud-native Kubernetes configurations, using mature programming language techniques and practices. KCL focuses on modularity, extensibility, and stability around configuration, aiming to create a simpler logic writing experience and build a simpler path for automation and ecosystem integration.\\n\\nKey milestones of the project include:\\n\\n- May 2022: KCL was initiated and officially open-sourced by Ant Group.\\n- June 2023: KCL became an official CNCF Landscape project.\\n- September 2023: KCL was reviewed by the CNCF Application Delivery TAG and approved through TOC voting, officially becoming a CNCF Sandbox project (https://github.com/cncf/sandbox/issues/48).\\n\\n## Why do we need KCL?\\n\\nJust like recording music with a staff and storing time series data in a sequential database, we use specialized configuration and policy languages to write and manage large-scale complex configurations and policies within specific problem domains of cloud native configuration and automation. Unlike high-level general-purpose languages with hybrid writing paradigms and hybrid engineering capabilities, the core logic of specialized languages is to solve domain problems with almost infinite changes and complexity through a converged finite set of syntax and semantics, and to deposit complex configuration and strategy writing ideas and methods into language characteristics.\\n\\nIn addition, KCL hopes to fill the gap in configuration languages and tools in the field of lightweight client cloud native dynamic configuration through more modern declarative configuration languages and tools, and address the following issues:\\n\\n- **Configuration Bloat**: Most static configurations such as Kubernetes YAML in the cloud native domain need to be configured separately for each environment; In the worst-case scenario, it may introduce difficult to debug errors involving environmental cross linking, with poor stability and scalability.\\n- **Configuration Drift**: There is often no standard way to manage the static configuration of applications and infrastructure in different environments. Using non-standard methods such as combining scripts and glue code can lead to exponential complexity growth and configuration drift.\\n- **Cognitive loading**: Kubernetes and others, as platform technology tools for building platforms, excel in the details of the underlying unified infrastructure, but lack higher-level abstraction for application software delivery, which has a high cognitive loading on ordinary developers and affects the software delivery experience of higher-level application developers.\\n\\nIn response to the above issues, KCL expects to provide the following capabilities:\\n\\n- Shielding the details and complexity of infrastructure and platforms through methods such as code **abstraction**, reducing the cognitive loading on developers.\\n- **Mutate** and **Validate** existing inventory configurations or templates to directly solve cloud generated small configuration scenarios such as Helm Chart configuration hard coding issues, but it goes far beyond that.\\n- Improve team collaboration efficiency by **managing large-scale configuration** data across teams without side effects through language configuration.\\n\\nSpecifically, KCL can\\n\\n- Improve the ability of **configuration semantic verification** at the code level, such as schema definition, field optional/mandatory, type, range, and other configuration check and verification capabilities.\\n- Provide the ability to write, combine, and abstract \\\\*\\\\*configuration blocks, such as structural definition, structural inheritance, constraint definition, and configuration policy merging.\\n- Improve configuration flexibility through **modern programming languages** and **writing code**, such as conditional statements, loops, functions, package management, and other features to enhance configuration reuse capabilities.\\n- Provide **comprehensive tool chain support**, rich IDE plugins, languages, and ecological tool chain support to reduce the threshold of getting started and improve the user experience.\\n- By using **package management tools** and **OCI registry**, configurations can be shared, propagated, and delivered in a simpler way among different teams/roles.\\n- Provide **high-performance** compilers to meet the requirements of large-scale configuration scenarios, such as meeting the rendering performance requirements of generating configurations of different environments and topologies based on deployment context from a baseline configuration, as well as the performance requirements of automatic configuration modification.\\n- By enhancing its automation and integration capabilities through means such as **multilingual SDK and KCL language plugin**, it can significantly reduce the learning cost of KCL while leveraging the value of configuration and policy writing.\\n\\n![](/img/docs/user_docs/intro/kcl-overview.png)\\n\\nIn addition to the language itself, KCL also provides many additional tools such as formatting, testing, documentation, etc. to help you use, understand, and check the written configuration or strategy; Reduce the cost of configuration writing and sharing through IDE plugins such as VS Code, package management tools, and Playground; Automatically manage and execute configurations through Rust, Go, and Python multilingual SDKs.\\n\\n## What can KCL do?\\n\\n### Dynamic Configuration Management\\n\\n![standalone-kcl-form](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/standalone-kcl-form.png)\\n\\nAs a configuration language, the most important feature that KCL provides to application and platform developers/SREs is dynamic configuration management. Through code abstraction, we can build an application-centric model that shields complex infrastructure and platform concepts, providing developers with a centralized and easy-to-understand interface. Additionally, KCL allows platform personnel to quickly extend and define their own models, which can be shared and reused through the OCI registry.\\n\\n![krm-kcl-form](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/krm-kcl-form.png)\\n\\nFurthermore, KCL also supports direct integration with the Kubernetes Resource Model (KRM) specification. KRM KCL is a generic configuration model specification used to describe and manage various cloud native resources, such as container, pod, and service configurations and abstractions. The KRM KCL specification provides a unified way to define and manage these resources, enabling them to be portable and reusable across different environments. It operates in a fully open Kubernetes world, with minimal binding to any orchestration/engine tools or Kubernetes controllers. It allows platform personnel to extend their abstractions, configuration editing and validation logic, while providing a developer-friendly configuration management interface based on the separation of concerns.\\n\\n### GitOps\\n\\n![gitops](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/gitops.png)\\n\\nWhether using standalone KCL or KRM KCL configuration forms, we support integration between KCL and various CI/CD and GitOps tools. KCL allows developers to define the resources required by applications in a declarative manner. By combining KCL with GitOps tools, we can better achieve Infrastructure as Code (IaC), improve deployment efficiency, and simplify application configuration management.\\n\\nWith GitOps, developers and operations teams can manage application deployments by separately modifying application and configuration code. The GitOps toolchain can automatically make changes to the configuration based on the automation capabilities of KCL, enabling continuous deployment and ensuring consistency. If any issues arise, the GitOps toolchain can quickly roll back the changes.\\n\\n## Integrations\\n\\n![integration](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/integration.png)\\n\\nIn addition to integrating with GitOps automation tools like ArgoCD, as a CNCF project, KCL has also integrated with many other CNCF ecosystem projects. For example, it provides KCL plugins for existing CNCF ecosystem configuration management tools such as Helm, Kustomize, and kpt. It also provides a KCL Kubernetes Operator at runtime to meet different configuration management needs. Furthermore, we offer the following integration support:\\n\\n- **Multi-language support**: We provide multi-language SDKs to help users operate KCL in different languages and integrate it into their own applications.\\n- **Package management support**: We provide the KPM package management tool to distribute and reuse KCL configurations through Docker Hub, GitHub container registry, etc.\\n- **Schema migration support**: We support one-click migration of schemas from other ecosystems to KCL schemas, such as Go/Rust struct definitions, JsonSchema, Protobuf, OpenAPI, Terraform Provider Schema, etc.\\n\\n## Practices\\n\\n![practice-krm-kcl](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/practice-krm-kcl.png)\\n\\nFirstly, as a small language in the cloud-native field, KCL can be directly used to solve simple problems in scenarios. For example, using the KCL model to directly inject environment variables for Kubernetes resources, and using the KCL model and Helm KCL plugins to non-invasively handle the hard-coded configuration of Helm Charts instead of directly modifying the Helm Chart by forking it.\\n\\n![practice-konfig-gitops](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/practice-konfig-gitops.png)\\n\\nSecondly, KCL can also be used in conjunction with various CI/CD and application configuration delivery engines such as [KusionStack](https://kusionstack.io) within enterprises to achieve separation of concerns, application-centric programmable model interfaces, and GitOps processes. This simplifies the deployment and operation of scaled applications in today\'s hybrid multi-cloud environments, improving release and operation efficiency and developer experience.\\n\\nOf course, KCL can solve more problems and scenarios than mentioned above. We will continue to share best practices from adopters in the community, and we welcome everyone to join our community for further discussions and exchanges \u2764\ufe0f. https://github.com/kcl-lang/community\\n\\n## Community\\n\\n![community](/img/blog/2023-09-19-kcl-joining-cncf-sandbox/community.png)\\n\\nIn just one year of KCL being open source, we have released many versions and built the KCL community in collaboration with contributors and maintainers from all over the world. We have also gained recognition from some adopters, such as Youzan and Huawei. By joining CNCF, our goal is to increase project visibility and drive community adoption and participation, as strong and well-known foundation organizations are crucial for advancing the development of language ecosystems.\\n\\nAdditionally, we have received recognition from companions in the open-source community from all over the world, including China, North America, Europe, and Australia. We thank all the users and community developers who have accompanied KCL on this journey, and we welcome more companions to join our community and build together \u2764\ufe0f.\\n\\n## Conclusion\\n\\nFor KCL, joining CNCF does not mean the end, but a new beginning. We will work together with our community companions to build a better KCL language, toolchain, and IDE experience! Lastly, we welcome everyone to join our community for discussions and contributions \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\\n\\n## Resources\\n\\n- KCL Website: https://kcl-lang.io/\\n- KusionStack Website: https://kusionstack.io/\\n- KCL Community: https://github.com/kcl-lang/community\\n- KCL 2023 Roadmap: https://kcl-lang.io/docs/community/release-policy/roadmap\\n- KCL GitHub Issues: https://github.com/kcl-lang/kcl/issues\\n- KCL GitHub Discussion: https://github.com/orgs/kcl-lang/discussions"},{"id":"2023-09-15-kcl-0.6.0-release","metadata":{"permalink":"/blog/2023-09-15-kcl-0.6.0-release","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-15-kcl-0.6.0-release/index.md","source":"@site/blog/2023-09-15-kcl-0.6.0-release/index.md","title":"KCL v0.6.0 Release Blog","description":"Introduction","date":"2023-09-15T00:00:00.000Z","formattedDate":"September 15, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":14.975,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-15-kcl-0.6.0-release","title":"KCL v0.6.0 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Joining CNCF as a Sandbox Project! \ud83c\udf89","permalink":"/blog/2023-09-19-kcl-joining-cncf-sandbox"},"nextItem":{"title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","permalink":"/blog/2023-09-06-dcm-using-kcl"}},"content":"\x3c!-- KCL v0.6.0 \u91cd\u78c5\u53d1\u5e03 - \u9762\u5411\u4e91\u539f\u751f\u573a\u666f\u66f4\u6613\u7528\u7684\u8bed\u8a00\u3001\u5de5\u5177\u94fe\uff0c\u793e\u533a\u96c6\u6210\u548c\u6269\u5c55\u652f\u6301 --\x3e\\n\\n## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.6.0 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n- _Use KCL language, tools and IDE extensions with more complete features and fewer errors to improve code writing experience and efficiency._\\n- _Use KPM, OCI Registry and other tools to directly use and share your cloud native domain models, reducing learning and hands-on costs._\\n- _Use cloud-native integration extensions such as Helmfile KCL plugin and KCL Operator to simultaneously support in-place mutation and validation of Kubernetes resources on both the client and runtime, avoiding hardcoded configurations._\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.6.0) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.6.0 and recent developments in the KCL community to readers.\\n\\n## Language\\n\\n### \ud83d\udd27 Type system enhancement\\n\\nSupport automatic type inference for KCL configuration block attributes. Prior to version 0.6.0 of KCL, the key1 and key2 attributes in the code snippet below would be inferred as type str | int. With the updated version, we have further improved the precision of type inference for configuration attributes, so key1 and key2 will have more specific and precise corresponding types.\\n\\n```python\\nconfig = {\\n    key1 = \\"value1\\"\\n    key2 = 2\\n}\\nkey1 = config.key1  # The type of key1 is str\\nkey2 = config.key2  # The type of key2 is int\\n```\\n\\nIn addition, we have optimized error messages for schema semantic checking, union type checking, and type checking errors in system library functions.\\n\\nFor more information, please refer to [here](https://github.com/kcl-lang/kcl/pull/678)\\n\\n### \ud83c\udfc4 API Update\\n\\nKCL Schema model parsing: The GetSchemaType API is used to retrieve KCL package-related information and default values for schema attributes.\\n\\n### \ud83d\udc1e Bug Fixes\\n\\n#### Fix schema required/optional attribute check in KCL\\n\\nIn previous versions of KCL, the required/optional attribute check for KCL would miss nested schema attribute checks. In version KCL v0.6.0, we have fixed such similar issues.\\n\\n```python\\nschema S:\\n    a: int\\n    b: str\\nschema L:\\n    # In previous versions, the required attribute check for attributes \'a\' and \'b\' of S in [S] and {str:S} would be missed.\\n    # This issue has been fixed in KCL v0.6.0 and later versions.\\n    ss?: [S]\\n    sss?: {str:S}\\nl = L {\\n    ss = [S {b = \\"b\\"}]\\n}\\n```\\n\\nFor more information, please see [here](https://github.com/kcl-lang/kcl/pull/672)\\n\\n## IDE & Toolchain Updates\\n\\n### IDE Updates\\n\\n#### Features\\n\\n- Performance improvement for all IDE features\\n- Support variable and schema attribute completion for KCL packages\\n- Support KCL schema attribute document attribute hover\\n- Support for quick fix of useless import statements\\n\\n![ide-quick-fix](/img/blog/2023-09-15-kcl-0.6.0-release/ide-quick-fix-en.png)\\n\\n- Support right-click formatting of files and code fragments in VS Code.\\n\\n![ide-format](/img/blog/2023-09-15-kcl-0.6.0-release/ide-format-en.png)\\n\\n- Support hover for built-in functions and function information in system libraries\\n\\n![ide-func-hover](/img/blog/2023-09-15-kcl-0.6.0-release/ide-func-hover.png)\\n\\n#### IDE Extension Updates\\n\\nWe have integrated the KCL language server LSP into NeoVim and Idea, enabling the completion, navigation, and hover features supported by VS Code IDE in NeoVim and IntelliJ IDEA.\\n\\n- NeoVim KCL Extension\\n\\n![kcl.nvim](/img/docs/tools/Ide/neovim/overview.png)\\n\\n- IntelliJ Extension\\n\\n![intellij](/img/docs/tools/Ide/intellij/overview.png)\\n\\nFor more information on downloading, installation, and features of the IDE plugins, please refer to:\\n\\n- [https://kcl-lang.io/docs/user_docs/getting-started/install#neovim](https://kcl-lang.io/docs/user_docs/getting-started/install#neovim)\\n- [https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea](https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea)\\n\\n### KCL Formatting Tool Updates\\n\\nSupport formatting of configuration blocks with incorrect indentation\\n\\n- Before formatting\\n\\n```python\\nconfig = {\\na ={\\nx = 1\\n y =2\\n}\\nb = {\\n x = 1\\n y = 2\\n}\\n}\\n```\\n\\n- After formatting\\n\\n```python\\nconfig = {\\n    a = {\\n        x = 1\\n        y = 2\\n    }\\n    b = {\\n        x = 1\\n        y = 2\\n    }\\n}\\n```\\n\\n### KCL Documentation Tool Updates\\n\\n- Support for exporting Markdown documents\\n- Support for exporting document index pages\\n- Support for exporting documents with custom style templates\\n- Support for HTML escaping in exported documents\\n- Enhanced document generation to parse and render example code snippets in document comments\\n- By tracking model updates in Github workflow and regenerating the documentation, automatic synchronization of the documentation can be achieved. Please refer to [here](https://github.com/KusionStack/catalog/pull/31/files) for more details.\\n\\n#### Generate model document from kpm package\\n\\n1. Create a kpm package and add documentation comments (using docstring) to the `Service` model. The documentation can include explanations, example code, and usage instructions to help other developers quickly get started and use it correctly.\\n\\n```\\n\\n\u279c kpm init demo\\n\\n\u279c cat > demo/server.k << EOF\\nschema Service:\\n    \\"\\"\\"\\n    Service is a kind of workload profile that describes how to run your application code. This\\n    is typically used for long-running web applications that should \\"never\\" go down, and handle\\n    short-lived latency-sensitive web requests, or events.\\n\\n    Attributes\\n    ----------\\n    workloadType : str = \\"Deployment\\" | \\"StatefulSet\\", default is Deployment, required.\\n        workloadType represents the type of workload used by this Service. Currently, it supports several\\n        types, including Deployment and StatefulSet.\\n    image : str, default is Undefined, required.\\n        Image refers to the Docker image name to run for this container.\\n        More info: https://kubernetes.io/docs/concepts/containers/images\\n    replicas : int, default is 2, required.\\n        Number of container replicas based on this configuration that should be ran.\\n\\n    Examples\\n    --------\\n    # Instantiate a long-running service and its image is \\"nginx:v1\\"\\n\\n    svc = Service {\\n        workloadType: \\"Deployment\\"\\n        image: \\"nginx:v1\\"\\n        replica: 2\\n    }\\n    \\"\\"\\"\\n    workloadType: \\"Deployment\\" | \\"StatefulSet\\"\\n    image: str\\n    replica: int\\nEOF\\n\\n```\\n\\n2. Generate the package documentation in Markdown format\\n\\nThe following command will output the demo package documentation to the `doc/` directory in the current working directory:\\n\\n```shell\\nkcl-go doc generate --file-path demo\\n```\\n\\n![docgen](/img/blog/2023-09-15-kcl-0.6.0-release/docgen.png)\\n\\n> For more usage details, please use `kcl-go doc generate -h` to refer to the help information.\\n\\n#### Automatic synchronization of documents through CI pipelines\\n\\nImplement automatic documentation synchronization through a pipeline By tracking model updates in a Github workflow and regenerating the documentation, automatic synchronization of the documentation can be achieved. You can refer to the approach in the `Kusionstack/catalog` repo to generate the documentation and automatically submit change PRs to the documentation repository.\\n\\nBy tracking model updates in Github workflow and regenerating documents, automatic document synchronization can be achieved. Can refer to the approach in the [Kusionstack/catalog](https://github.com/KusionStack/catalog/pull/31/files) repo is to generate documents and automatically submit change PRs to the document repository.\\n\\n### KCL Import Tool Updates\\n\\nThe KCL Import Tool now adds support for converting Terraform Provider Schema to KCL Schema based on Protobuf, JsonSchema OpenAPI models, and Go Structures, such as the following Terraform Provider Json (obtained through the command `terraform providers schema -json > provider.json` , For more details, please refer to [https://developer.hashicorp.com/terraform/cli/commands/providers/schema](https://developer.hashicorp.com/terraform/cli/commands/providers/schema))\\n\\n```json\\n{\\n  \\"format_version\\": \\"0.2\\",\\n  \\"provider_schemas\\": {\\n    \\"registry.terraform.io/aliyun/alicloud\\": {\\n      \\"provider\\": {\\n        \\"version\\": 0,\\n        \\"block\\": {\\n          \\"attributes\\": {},\\n          \\"block_types\\": {},\\n          \\"description_kind\\": \\"plain\\"\\n        }\\n      },\\n      \\"resource_schemas\\": {\\n        \\"alicloud_db_instance\\": {\\n          \\"version\\": 0,\\n          \\"block\\": {\\n            \\"attributes\\": {\\n              \\"db_instance_type\\": {\\n                \\"type\\": \\"string\\",\\n                \\"description_kind\\": \\"plain\\",\\n                \\"computed\\": true\\n              },\\n              \\"engine\\": {\\n                \\"type\\": \\"string\\",\\n                \\"description_kind\\": \\"plain\\",\\n                \\"required\\": true\\n              },\\n              \\"security_group_ids\\": {\\n                \\"type\\": [\\"set\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true,\\n                \\"computed\\": true\\n              },\\n              \\"security_ips\\": {\\n                \\"type\\": [\\"set\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true,\\n                \\"computed\\": true\\n              },\\n              \\"tags\\": {\\n                \\"type\\": [\\"map\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true\\n              }\\n            },\\n            \\"block_types\\": {},\\n            \\"description_kind\\": \\"plain\\"\\n          }\\n        },\\n        \\"alicloud_config_rule\\": {\\n          \\"version\\": 0,\\n          \\"block\\": {\\n            \\"attributes\\": {\\n              \\"compliance\\": {\\n                \\"type\\": [\\n                  \\"list\\",\\n                  [\\n                    \\"object\\",\\n                    {\\n                      \\"compliance_type\\": \\"string\\",\\n                      \\"count\\": \\"number\\"\\n                    }\\n                  ]\\n                ],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"computed\\": true\\n              },\\n              \\"resource_types_scope\\": {\\n                \\"type\\": [\\"list\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true,\\n                \\"computed\\": true\\n              }\\n            }\\n          }\\n        }\\n      },\\n      \\"data_source_schemas\\": {}\\n    }\\n  }\\n}\\n```\\n\\nThen the tool can output the following KCL code\\n\\n```python\\n\\"\\"\\"\\nThis file was generated by the KCL auto-gen tool. DO NOT EDIT.\\nEditing this file might prove futile when you re-run the KCL auto-gen generate command.\\n\\"\\"\\"\\n\\nschema AlicloudConfigRule:\\n    \\"\\"\\"\\n    AlicloudConfigRule\\n\\n    Attributes\\n    ----------\\n    compliance: [ComplianceObject], optional\\n    resource_types_scope: [str], optional\\n    \\"\\"\\"\\n\\n    compliance?: [ComplianceObject]\\n    resource_types_scope?: [str]\\n\\nschema ComplianceObject:\\n    \\"\\"\\"\\n    ComplianceObject\\n\\n    Attributes\\n    ----------\\n    compliance_type: str, optional\\n    count: int, optional\\n    \\"\\"\\"\\n\\n    compliance_type?: str\\n    count?: int\\n\\nschema AlicloudDbInstance:\\n    \\"\\"\\"\\n    AlicloudDbInstance\\n\\n    Attributes\\n    ----------\\n    db_instance_type: str, optional\\n    engine: str, required\\n    security_group_ids: [str], optional\\n    security_ips: [str], optional\\n    tags: {str:str}, optional\\n    \\"\\"\\"\\n\\n    db_instance_type?: str\\n    engine: str\\n    security_group_ids?: [str]\\n    security_ips?: [str]\\n    tags?: {str:str}\\n\\n    check:\\n        isunique(security_group_ids)\\n        isunique(security_ips)\\n```\\n\\n### Package Manage Tool Updates\\n\\n#### kpm pull supports pulling packages by package name\\n\\nkpm supports pulling the corresponding package by using the `kpm pull <package_name>:<package_version>` command.\\n\\nTaking the `k8s` package as an example, you can directly download the package to your local machine using the following commands:\\n\\n```shell\\nkpm pull k8s\\n```\\n\\nor\\n\\n```shell\\nkpm pull k8s:1.27\\n```\\n\\nThe package downloaded with kpm pull will be saved in the directory `<execution_directory>/<oci_registry>/<package_name>`. For example, if you use the default kpm registry and run the kpm pull k8s command, you can find the downloaded content in the directory `<execution_directory>/ghcr.io/kcl-lang/k8s`.\\n\\n```\\n$ tree ghcr.io/kcl-lang/k8s -L 1\\n\\nghcr.io/kcl-lang/k8s\\n\u251c\u2500\u2500 api\\n\u251c\u2500\u2500 apiextensions_apiserver\\n\u251c\u2500\u2500 apimachinery\\n\u251c\u2500\u2500 kcl.mod\\n\u251c\u2500\u2500 kcl.mod.lock\\n\u251c\u2500\u2500 kube_aggregator\\n\u2514\u2500\u2500 vendor\\n\\n6 directories, 2 files\\n```\\n\\n#### kpm supports adding local paths as dependencies\\n\\n\\"Different projects have different KCL packages, and there are dependencies between them. However, they are stored in different directories. I hope that these packages stored in different directories can be managed together, rather than having to put them together for them to compile.\\" If you also have this need, you can try this feature. The kpm add command currently supports adding local paths as dependencies to a KCL package. You just need to run the command `kpm add <local_package_path>`, and your local package will be added as a third-party library dependency to the current package.\\n\\n```shell\\nkpm pull k8s\\n```\\n\\nAfter completion, you can find the downloaded k8s package in the directory `\\"the_directory_where_you_executed_the_command/ghcr.io/kcl-lang/k8s\\"`.\\nCreate a new KCL package using the `kpm init mynginx` command.\\n\\n```shell\\nkpm init mynginx\\n```\\n\\nThen, navigate into this package.\\n\\n```shell\\ncd mynginx\\n```\\n\\nInside this package, you can use the kpm add command to add the k8s package you downloaded locally as a third-party library dependency to `mynginx`.\\n\\n```shell\\nkpm add ../ghcr.io/kcl-lang/k8s/\\n```\\n\\nNext, add the following content to `main.k`.\\n\\n```shell\\nimport k8s.api.core.v1 as k8core\\n\\nk8core.Pod {\\n    metadata.name = \\"web-app\\"\\n    spec.containers = [{\\n        name = \\"main-container\\"\\n        image = \\"nginx\\"\\n        ports = [{containerPort: 80}]\\n    }]\\n}\\n```\\n\\nNormal compilation can be performed through the `kpm run` command.\\n\\n```shell\\nkpm run\\n```\\n\\n#### kpm adds checking for existing package tags\\n\\nWe have added a check for duplicate tags in the `kpm push` command. In order to avoid situations where packages with the same tag have different content, we have added restrictions on the push function in the `kpm`. If the version of the kcl package you push already exists, you will not be able to push the current kcl package. You will receive the following information:\\n\\n```shell\\nkpm: package \'my_package\' will be pushed.\\nkpm: package version \'0.1.0\' already exists\\n```\\n\\nModifying the content of a package that has already been pushed to the registry without changing the tag carries a high risk, as the package may already be in use by others. Therefore, if you need to push your package, we recommend:\\n\\n- Change your tag and follow semantic versioning conventions.\\n- If you must modify the content of a package without changing the tag, you will need to delete the existing tag from the registry.\\n\\n## Integrations\\n\\n### Helmfile KCL Plugin\\n\\nHelmfile is a declarative specification and tool for deploying Helm Charts. With the Helmfile KCL plugin, you can:\\n\\n- Edit or verify Helm Chart through non-invasive hook methods, separating the data and logic parts of Kubernetes configuration management\\n  - Modify resource labels/annotations, inject sidecar container configuration\\n  - Use KCL schema to validate resources\\n  - Define your own abstract application models\\n- Maintain multiple environment and tenant configurations elegantly, rather than simply copying and pasting.\\n\\nHere is a detailed explanation using a simple example. With the Helmfile KCL plugin, you do not need to install any components related to KCL. You only need the latest version of the Helmfile tool on your local device.\\n\\nWe can write a `helmfile.yaml` file as follows:\\n\\n```yaml\\nrepositories:\\n-\xa0name:\xa0prometheus-community\\n\xa0\xa0url:\xa0https://prometheus-community.github.io/helm-charts\\n\\nreleases:\\n-\xa0name:\xa0prom-norbac-ubuntu\\n\xa0\xa0namespace:\xa0prometheus\\n\xa0\xa0chart:\xa0prometheus-community/prometheus\\n\xa0\xa0set:\\n\xa0\xa0-\xa0name:\xa0rbac.create\\n\xa0\xa0\xa0\xa0value:\xa0false\\n\xa0\xa0transformers:\\n\xa0\xa0#\xa0Use\xa0KCL\xa0Plugin\xa0to\xa0mutate\xa0or\xa0validate\xa0Kubernetes\xa0manifests.\\n\xa0\xa0-\xa0apiVersion:\xa0krm.kcl.dev/v1alpha1\\n\xa0\xa0\xa0\xa0kind:\xa0KCLRun\\n\xa0\xa0\xa0\xa0metadata:\\n\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0\\"set-annotation\\"\\n\xa0\xa0\xa0\xa0\xa0\xa0annotations:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0config.kubernetes.io/function:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0container:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0image:\xa0docker.io/kcllang/kustomize-kcl:v0.2.0\\n\xa0\xa0\xa0\xa0spec:\\n\xa0\xa0\xa0\xa0\xa0\xa0source:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[resource\xa0|\xa0{if\xa0resource.kind\xa0==\xa0\\"Deployment\\":\xa0metadata.annotations:\xa0{\\"managed-by\\"\xa0=\xa0\\"helmfile-kcl\\"}}\xa0for\xa0resource\xa0in\xa0option(\\"resource_list\\").items]\\n```\\n\\nIn the above file, we referenced the Prometheus Helm Chart and injected the `managed-by=\\"helmfile-kcl\\"` label into all deployment resources of Prometheus with just one line of KCL code. The following command can be used to deploy the above configuration to the Kubernetes cluster:\\n\\n```shell\\nhelmfile\xa0apply\\n```\\n\\nFor more use cases, please refer to [https://github.com/kcl-lang/krm-kcl](https://github.com/kcl-lang/krm-kcl)\\n\\n### KCL Operator\\n\\nKCL Operator provides cluster integration, allowing you to use Access Webhook to generate, mutate, or validate resources based on KCL configuration when apply resources to the cluster. Webhook will capture creation, application, and editing operations, and execute [KCLRun](https://github.com/kcl-lang/krm-kcl) on the configuration associated with each operation, and the KCL programming language can be used to\\n\\n- Add labels or annotations based on a condition.\\n- Inject a sidecar container in all KRM resources that contain a `PodTemplate`.\\n- Validating all KRM resources using KCL Schema, such as constraints on starting containers only in a root mode.\\n- Generating KRM resources using an abstract model or combining and using different KRM APIs.\\n\\nHere is a simple resource annotation mutation example to introduce the usage of the KCL operator.\\n\\n#### 0. Prerequisites\\n\\nPrepare a Kubernetes cluster like `k3d` the kubectl tool.\\n\\n#### 1. Install KCL Operator\\n\\n```shell\\nkubectl apply -f https://raw.githubusercontent.com/kcl-lang/kcl-operator/main/config/all.yaml\\n```\\n\\nUse the following command to observe and wait for the pod status to be `Running`.\\n\\n```shell\\nkubectl get po\\n```\\n\\n#### 2. Deploy KCL Annotation Setting Model\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  # Set dynamic parameters required for the annotation modification model, here we can add the labels we want to modify/add\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Reference the annotation modification model on OCI\\n  source: oci://ghcr.io/kcl-lang/set-annotation\\nEOF\\n```\\n\\n#### 3. Deploy a Pod to Verify the Model Result\\n\\nExecute the following command to deploy a `Pod` resource:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: nginx\\n  annotations:\\n    app: nginx\\nspec:\\n  containers:\\n  - name: nginx\\n    image: nginx:1.14.2\\n    ports:\\n    - containerPort: 80\\nEOF\\nkubectl get po nginx -o yaml | grep kcl-operator\\n```\\n\\nWe can see the following output:\\n\\n```shell\\n    managed-by: kcl-operator\\n```\\n\\nWe can see that the Nginx Pod automatically added the annotation `managed-by=kcl-operator`.\\n\\nIn addition, besides referencing an existing model for the source field of the `KCLRun` resource, we can directly set KCL code for the source field to achieve the same effect. For example:\\n\\n```yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Resource modification can be achieved with just one line of KCL code\\n  source: |\\n    items = [item | {metadata.annotations: option(\\"params\\").annotations} for item in option(\\"items\\")]\\n```\\n\\n![registry](/img/blog/2023-09-15-kcl-0.6.0-release/registry.png)\\n\\nWe have provided more than 30 built-in models, and you can find more code examples in the following link: [https://github.com/kcl-lang/krm-kcl/tree/main/examples](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\nFor example\\n\\n- Use the `web-service` model to directly instantiate the Kubernetes resources required for a web application\\n- Add annotations to existing k8s resources using the `set-annotation` model\\n- Use the `https-only` model to verify that your `Ingress` configuration can only be set to https, otherwise an error will be reported.\\n\\n### Vault Integration\\n\\nIn just three steps, we can use `Vault` to store and manage sensitive information and use it in KCL.\\n\\nFirstly, we install and use Vault to store `foo` and `bar` information.\\n\\n```shell\\nvault kv put secret/foo foo=foo\\nvault kv put secret/bar bar=bar\\n```\\n\\nThen write the following KCL code (main.k)\\n\\n```python\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"nginx\\"\\n    labels.app = \\"nginx\\"\\n    annotations: {\\n        \\"secret-store\\": \\"vault\\"\\n        # Valid format:\\n        #  \\"ref+vault://PATH/TO/KV_BACKEND#/KEY\\"\\n        \\"foo\\": \\"ref+vault://secret/foo#/foo\\"\\n        \\"bar\\": \\"ref+vault://secret/bar#/bar\\"\\n    }\\n}\\nspec = {\\n    replicas = 3\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"${metadata.name}:1.14.2\\"\\n            ports = [{ containerPort = 80 }]\\n        }\\n    ]\\n}\\n```\\n\\nFinally, the decrypted configuration can be obtained through the `vals` command-line tool\\n\\n```shell\\nkcl main.k | vals eval -f -\\n```\\n\\nFor more details and use cases, please refer to [here](https://kcl-lang.io/docs/user_docs/guides/secret-management/vault)\\n\\n### GitLab CI Integration\\n\\nUsing KCL, we can not only use Github Action as CI for application publishing through GitOps, but also provide GitLab CI integration in this version. Please refer to: _[https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci](https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci)_\\n\\n## Other Updates and Bug Fixes\\n\\nSee [here](https://github.com/kcl-lang/kcl/compare/v0.5.0...v0.6.0) for more updates and bug fixes.\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.x, v0.5.x and v0.6.0 versions are supported.\\n\\n## Community\\n\\n- Thank @jakezhu9 for his contribution to converting KCL Import tools, including Terraform Provider Schema, JsonSchema, JSON, YAML, and other configuration formats/data to KCL schema/configurations \ud83d\ude4c\\n- Thank @xxmao123 for her contribution to connecting KCL LSP language server to the Idea IDE extension \ud83d\ude4c\\n- Thank @starkers for his contribution to the KCL NeoVim extension \ud83d\ude4c\\n- Thank @starkers for adding KCL installation support to mason.nvim registry \ud83d\ude4c\\n- Thank @Ekko for his contribution to the integration of KCL cloud native tools and KCL Operator \ud83d\ude4c\\n- Thank @prahalaramji for the upgrade, update, and contribution to the KCL Homebrew installation script \ud83d\ude4c\\n- Thank @yyxhero for providing assistance and support in the Helmfile KCL plugin support \ud83d\ude4c\\n- Thank @nkabir, @mihaigalos, @prahalaramji, @yamin-oanda, @dhhopen, @magick93, @MirKml, @kolloch, @steeling, and others for their valuable feedback and discussion during the past two months of using KCL. \ud83d\ude4c\\n\\n## Additional Resources\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-09-06-dcm-using-kcl","metadata":{"permalink":"/blog/2023-09-06-dcm-using-kcl","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-08-dcm-using-kcl/index.md","source":"@site/blog/2023-09-08-dcm-using-kcl/index.md","title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","description":"Introduction","date":"2023-09-08T00:00:00.000Z","formattedDate":"September 8, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Kubernetes Resource Model","permalink":"/blog/tags/kubernetes-resource-model"},{"label":"Dynamic Configuration Management","permalink":"/blog/tags/dynamic-configuration-management"}],"readingTime":13.29,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-06-dcm-using-kcl","title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Kubernetes Resource Model","Dynamic Configuration Management"]},"prevItem":{"title":"KCL v0.6.0 Release Blog","permalink":"/blog/2023-09-15-kcl-0.6.0-release"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","permalink":"/blog/2023-09-06-biweekly-newsletter"}},"content":"## Introduction\\n\\n> With the development of cloud-native technologies, we are increasingly shifting towards cloud infrastructure. Tools such as Kubernetes and Terraform have become increasingly popular for managing and deploying applications based on cloud APIs. However, along with this popularity, the complexity and cognitive burden associated with these tools have reached a peak in recent years.\\n\\n![cognitive-loading](/img/blog/2023-09-08-dcm-using-kcl/cognitive-loading.png)\\n\\nThe increasing complexity of Kubernetes and cloud APIs can be attributed to several factors:\\n\\n- **Growing functionality and capabilities**: Kubernetes and cloud APIs continuously evolve to meet the growing demands of applications and the development of cloud computing. To fulfill user requirements, new functionalities and capabilities such as auto-scaling, service discovery, load balancing, and permission management are constantly introduced. The introduction of these new features adds to the complexity of the system. Despite the availability of various automation methods, over time, the exponential growth in the number of different resource types, potential settings for these resource types, and the complex relationships between them pose challenges.\\n- **Complex configuration and management requirements**: As applications scale, configuring and managing Kubernetes and cloud APIs becomes increasingly complex. This includes managing a large number of container instances and resources, configuring intricate networking and storage setups, ensuring high availability and load balancing, and repetitive configurations for different environments and topologies. These complex configuration and management requirements contribute to the overall complexity of Kubernetes and cloud APIs, sometimes leading to the emergence of \\"YAML engineers\\" as a joking reference.\\n\\nDespite the increasing complexity of Kubernetes and cloud APIs, they provide powerful functionalities and flexibility to help organizations effectively manage and scale their applications. By utilizing appropriate tools, engineering practices, and methods, this complexity can be alleviated, enabling efficient utilization of these technologies to meet business needs. Dynamic configuration management techniques are one of the approaches that can help address the complexity of Kubernetes and cloud APIs to a certain extent.\\n\\n## What is Dynamic Configuration Management\\n\\nWe follow the [original definition of Dynamic Configuration Management (DCM)](https://humanitec.com/blog/what-is-dynamic-configuration-management) by its creator Chris Stephenson and extend it to a certain extent.\\n\\n> Dynamic Configuration Management (DCM) is an approach to constructing the configuration of computational workloads. Developers create workload specifications that describe everything necessary for the workload to run successfully. These specifications are used to dynamically generate configurations for deploying the workload in specific environments. With DCM, developers do not need to define or maintain environment-specific configurations for their workloads.\\n\\nDynamic Configuration Management means that developers describe the relationship between their workloads and resources in an **abstract** and **environment-agnostic** manner. They describe this relationship in a format called a workload specification or application-centric specification. The specification is generic and works across environments, which means it doesn\'t provide enough information to configure the workloads and resources themselves. To obtain executable configurations, we need to apply the specification to configuration baselines (for application and infrastructure configurations) and generate them based on the deployment context. For developers, Dynamic Configuration Management requires providing an application-centric configuration interface that they can understand. For platform engineers, Dynamic Configuration Management can help define how to handle configuration resources and workload specifications, leading to improved consistency and compliance within the organization. It also makes it easier to provide a self-service Internal Developer Platform (IDP).\\n\\nIn contrast to dynamic configuration management, static configuration management brings about a series of issues:\\n\\n- **Configuration Bloat**: Most static configurations require separate configurations for each environment, and in the worst case, it can introduce difficult-to-debug errors involving cross-linking between environments, leading to poor stability and scalability.\\n- **Configuration Drift**: Managing application and infrastructure configurations for different environments with static management approaches often lacks standardized methods for handling dynamic variations in configurations across environments. Employing non-standardized approaches can result in exponential complexity and lead to configuration drift.\\n\\n## Why Do We Need a New Paradigm\\n\\nJust as music is recorded on musical sheets and time-series data is stored in time-series databases, a set of configuration and policy languages is used for writing and managing scalable and complex configurations and policies in the specific problem domain of platform engineering. Unlike high-level general-purpose languages with mixed paradigms and mixed engineering capabilities, these domain-specific languages are built upon a converged, finite syntax and semantic set to tackle the near-infinite variations and complexities of the domain\'s problems, consolidating the mindset and approach to writing complex configurations and policies into the language\'s features.\\n\\nFor cloud APIs, we can leverage Infrastructure as Code (IaC) tools like Terraform to obtain a vast library of pre-written module configurations. However, when it comes to Kubernetes, there is still a lack of lightweight client-side configuration composition and abstraction solutions. Existing solutions or specifications struggle to strike a balance between abstraction capabilities and scalability. In extreme scenarios, developers often resort to writing glue code and scripts to handle configuration processing logic, which hinders stability and efficiency. For instance, although tools like Helm Chart provide template programming, the programming experience and efficiency are subpar. Additionally, when users need to dynamically adjust dependencies on `values.yaml` parameters in Helm Charts or encounter upstream Helm Charts that don\'t support the required parameter settings, they often resort to forking and maintaining the upstream Helm Charts in an intrusive manner or supplementing with tools like Kustomize, incurring additional maintenance costs and complexities.\\n\\nTherefore, we contemplate the need for a unified specification that can simultaneously support configuration language capabilities and, with minimal side effects, fulfill the requirements of stability, scalability, and efficiency in the context of scalable configuration scenarios. This specification should also address the problems inherent in static configuration management.\\n\\n- **Abstraction and Composition Capabilities**: By providing a programmable schema, the platform personnel can shield the underlying infrastructure details and platform, while offering developers a better and more stable API abstraction.\\n- **Stability**: By providing stable features out-of-the-box, such as rule writing and static typing, the specification enables risk mitigation and early error detection in version control systems (VCS), allowing for auditing, traceability, and rollback, and facilitating automation.\\n- **Scalability**: Similar to the application software supply chain, infrastructure configuration should be treated as part of the software supply chain. Users can distribute and reuse configurations in a standardized manner, easily accessing commonly used configurations in the open-source world. For internal platforms, we can easily write and extend configuration code.\\n- **High performance**: Since dynamic configuration management advocates generating configurations for different environments and topologies based on a baseline configuration and deployment context, there is a high demand for the rendering performance of the configuration code itself. Developers typically do not want to spend several minutes waiting for the actual configuration output, as it would hinder software iteration and upgrade efficiency.\\n\\n## KRM KCL Specification\\n\\nThe [KRM KCL specification](https://github.com/kcl-lang/krm-kcl) is a configuration specification based on the Kubernetes Resource Model (KRM). KRM is a universal configuration model used to describe and manage various cloud-native resources such as containers, pods, and services. It provides a unified way to define and manage these resources, enabling portability and reuse across different environments. It exists within the open Kubernetes ecosystem, decoupled from any specific orchestration/engine tools or Kubernetes controllers. It allows platform personnel to extend their abstractions, configuration editing, and validation logic, while also enabling direct reuse of existing model abstractions from the community, such as the Open Application Model (OAM), which also complies with the KRM specification.\\n\\nThe [KCL programming language](https://github.com/kcl-lang) is a core component of the KRM KCL specification. KCL is a declarative configuration language that allows users to describe the configuration requirements of their applications and associate them with underlying infrastructure. KCL has a rich syntax and semantics that can flexibly describe various configuration needs, such as environment variables, resource limits, dependencies, and more. KCL aims to hide the details of infrastructure and platforms by defining API abstractions, reducing the burden, and managing large-scale configurations across teams without side effects. It provides capabilities to write, combine, and abstract configuration blocks, such as structural definitions, constraints, and logic. In platform engineering practices, KCL is not just a key-value language but a domain-specific language tailored for the platform engineering field.\\n\\nAnother important feature of the KRM KCL specification is its support for dynamic configuration management. Traditional configuration management tools often rely on static configuration files that require manual modifications and deployments. The KRM KCL specification naturally provides a way to automatically modify configurations, which can be used standalone on the client-side or integrated with Kubernetes through the [KCL Operator](https://github.com/kcl-lang/kcl-operator) to achieve runtime configuration modifications without the need for developing Kubernetes webhooks or writing extensive configuration processing logic.\\n\\nIn addition to dynamic configuration management, the KRM KCL specification offers several other advantages. Firstly, it is based on Kubernetes and seamlessly integrates with the existing Kubernetes ecosystem. Secondly, the KRM KCL specification provides a rich set of tools and libraries that make it easy for developers to create, test, and maintain configurations. Lastly, the KRM KCL specification adopts open standards, allowing for interoperability with other configuration management tools such as Kubectl, Helm, Kustomize, and more. It possesses the following characteristics:\\n\\n- **Declarative**: Configurations are abstracted and organized in code form, allowing users to view and edit them using editors or IDEs. The code clearly describes various aspects of resources, services, networks, and more.\\n- **Final-state oriented**: It is abstracted and implementation-agnostic, with highly abstracted and domain-specific underlying capabilities. The concrete business logic is written by users in a declarative manner. Users can avoid manual operations and non-uniform patterns introduced by private scripts through a unified description code and GitOps workflow, reducing security risks.\\n- **Stability**: Any modification to configuration code can potentially result in unexpected outcomes, exceptions, or failures. By combining version control and the stability features of the language itself, different versions of configuration code can be switched as needed through Git, with audibility, to meet the needs of development, testing, and production stages. For example, rolling back to a verified version in case of anomalies. Code-based version control effectively prevents configuration drift.\\n- **Reusable and extensible**: Configuration code often exhibits the characteristic of \\"write once, reuse multiple times\\". When combined with dynamically parameterized configuration code, the reuse of configurations in different environments and for different users becomes simple. Through integration with standard software supply chains such as OCI, configuration code is treated equally with business code, better achieving Infrastructure as Code (IaC).\\n\\nIn summary, the KRM KCL specification presents a new paradigm for dynamic configuration management. Built upon KRM and KCL, it offers a more efficient and reliable configuration solution for modern software development. With its dynamic configuration management capabilities, flexible syntax and semantics, and integration with Kubernetes, the KRM KCL specification provides developers with an enhanced configuration management experience in cloud-native application development and microservices architectures.\\n\\n## How to\\n\\n![krm-kcl-form](/img/blog/2023-09-08-dcm-using-kcl/krm-kcl-form.png)\\n\\nIn the KRM KCL specification, we categorize the behaviors of the KCL configuration model into three main types:\\n\\n- **Mutation**: Takes input KCL parameters params and a KRM list, and outputs a modified KRM list.\\n- **Validation**: Takes input KCL parameters params and a KRM list, and outputs a KRM list and resource validation results.\\n- **Abstraction**: Takes input KCL parameters params and outputs a KRM list.\\n\\nUsing KCL, we can programmatically achieve the following capabilities:\\n\\n- Modify resources using KCL, such as adding/modifying label tags or annotation comments based on certain conditions, or injecting sidecar container configurations into all Kubernetes Resource Model (KRM) resources that contain PodTemplates.\\n- Validate all KRM resources using KCL schemas, such as constraints for launching containers only in a root manner.\\n- Generate KRM resources using an abstraction model or combine and use different KRM APIs.\\n\\nAdditionally, the configuration model source can reference OCI, Git, filesystem, and the original KCL code. With the help of KCL IDE and KPM package management tool, we can write models and upload them to OCI Registry for model reuse. These models can be used separately on the client-side or at runtime, depending on the specific scenario requirements.\\n\\n### Client-side\\n\\nWe will use a classic web service workload as an example to demonstrate the usage of the KRM KCL specification on the client-side.\\n\\nIn addition, we provide plugin support for Kubernetes community configuration management tools such as Kubectl, Helm, Kustomize, KPT, etc., in a unified programming interface. With just a few lines of configuration code, you can non-invasively edit and validate existing Kustomize YAML files, Helm Charts, define your own abstraction models, and share and reuse them.\\n\\nHere, we will provide a detailed explanation using the integration of KCL with the Kubectl tool as an example. You can find the installation instructions for the Kubectl KCL plugin at [here](https://github.com/kcl-lang/kubectl-kcl).\\n\\nFirst, execute the following command to get a sample configuration:\\n\\n```shell\\ngit clone https://github.com/kcl-lang/kubectl-kcl.git && cd ./kubectl-kcl/examples/\\n```\\n\\nThen, execute the following command to show the configuration:\\n\\n```shell\\n$ cat krm-kcl-abstraction.yaml\\n\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: web-service\\nspec:\\n  params:\\n    name: app\\n    containers:\\n      nginx:\\n        image: nginx\\n        ports:\\n        - containerPort: 80\\n    service:\\n      ports:\\n      - port: 80\\n  source: oci://ghcr.io/kcl-lang/web-service\\n```\\n\\nIn the above configuration, we use a pre-defined Kubernetes web service application abstraction model `oci://ghcr.io/kcl-lang/web-service` on the OCI registry, and configure the required fields for that model through the `params` field. By executing the following command, you can obtain the raw Kubernetes YAML output and deploy it to the cluster:\\n\\n```shell\\n$ kubectl kcl apply -f krm-kcl-abstraction.yaml\\n\\ndeployment.apps/app created\\nservice/app created\\n```\\n\\nIn addition to using YAML as the user input interface, KCL can be used as a DSL for writing configurations and policies. It allows developers and platform personnel to write and maintain configurations on a large scale using a unified KCL writing style on the client-side.\\n\\n![standalone-kcl-form](/img/blog/2023-09-08-dcm-using-kcl/standalone-kcl-form.png)\\n\\n### Runtime\\n\\nAt runtime, we provide Kubernetes cluster integration through the KCL Operator, allowing you to generate, mutate, or validate resources based on KCL configurations using an Access Webhook when applying resources to the cluster. The webhook captures create, apply, and edit operations and executes resources on the configuration associated with each operation using the `KCLRun` resource. With the KCL Operator, you can automate resource configuration management and security validation in a lightweight manner within a Kubernetes cluster using KCL code, without the need to develop a webhook server to dynamically modify and validate configurations at runtime.\\n\\nAdditionally, leveraging the modeling and abstraction capabilities of KCL, we can define functional abstractions/compositions for different resource APIs and expose them in the form of KCL schemas. Moreover, KCL schemas can be further automatically generated into OpenAPI schema definitions for other clients in the cluster to call, without the need for manually maintaining complex OpenAPI schema definitions for API abstractions/compositions.\\n\\nHere is an example of using the KCL Operator to modify resource annotations.\\n\\nInstall the KCL Operator:\\n\\n```shell\\nkubectl apply -f https://raw.githubusercontent.com/kcl-lang/kcl-operator/main/config/all.yaml\\n```\\n\\nUse the following command to observe and wait for the pod status to be `Running`:\\n\\n```shell\\nkubectl get po\\n```\\n\\nDeploy the annotation mutation model:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  source: oci://ghcr.io/kcl-lang/set-annotation\\nEOF\\n```\\n\\nDeploy a Pod resource to validate the model result:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: nginx\\n  annotations:\\n    app: nginx\\nspec:\\n  containers:\\n  - name: nginx\\n    image: nginx:1.14.2\\n    ports:\\n    - containerPort: 80\\nEOF\\nkubectl get po nginx -o yaml | grep kcl-operator\\n```\\n\\nWe can see the following output:\\n\\n```shell\\n    managed-by: kcl-operator\\n```\\n\\nWe can observe that the Nginx Pod automatically added the annotation `managed-by=kcl-operator`.\\n\\n## Summary\\n\\nDynamic configuration management can reduce the complexity of modern cloud-native configurations. With the KRM KCL specification and standard OCI models, we can achieve dynamic configuration management, allowing platform personnel and application developers to easily utilize these settings and reduce cognitive load.\\n\\n## Resources\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n## Reference\\n\\n- Declarative Application Management in Kubernetes: https://docs.google.com/document/d/1cLPGweVEYrVqQvBLJg6sxV-TrE5Rm2MNOBA_cxZP2WU/edit#\\n- CNCF Platforms White Paper: https://tag-app-delivery.cncf.io/whitepapers/platforms/\\n- Google SRE Workbook: https://sre.google/workbook/configuration-specifics/\\n- What is Dynamic Configuration Management: https://humanitec.com/blog/what-is-dynamic-configuration-management\\n- Implementing Dynamic Configuration Management with Score and Humanitec: https://humanitec.com/blog/implementing-dynamic-configuration-management-with-score-and-humanitec\\n- What is Platform Engineering: https://platformengineering.org/blog/what-is-platform-engineering\\n- What is Internal Developer Platform: https://internaldeveloperplatform.org/what-is-an-internal-developer-platform/\\n- What Team Structure is Right for DevOps to Flourish: https://web.devopstopologies.com/#anti-types"},{"id":"2023-09-06-biweekly-newsletter","metadata":{"permalink":"/blog/2023-09-06-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-06-biweekly-newsletter/index.md","source":"@site/blog/2023-09-06-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-09-06T00:00:00.000Z","formattedDate":"September 6, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":4.635,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-06-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"A New Paradigm for Dynamic Configuration Management - KRM KCL Specification","permalink":"/blog/2023-09-06-dcm-using-kcl"},"nextItem":{"title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","permalink":"/blog/2023-09-04-maintainer-jakezhu9-blog"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (08.10-08.23 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL Import Tool Updates** - Supports exporting JSON/YAML data to KCL configuration.\\n- **KCL IDE Updates** - Supports right-click formatting ability, formatting individual files or parts of KCL code.\\n- **KCL Documentation Tool Updates** - Exported documents support HTML escape.\\n- **KCL Package Management Tool KPM Updates** - `kpm run` command execution and error message optimization, supports running KCL packages located in local paths.\\n- **KCL Language Updates** - Optimized system package type check error messages and unified error message codes.\\n\\n**\ud83d\udcf0 Official Website and Use Case Updates**\\n\\n- KCL website adds v0.5.6 documentation version.\\n- Publishing KCL packages to docker.io or ghcr.io registries using Github Actions Example: [https://github.com/kcl-lang/kpm/blob/main/docs/push_by_github_action.md](https://github.com/kcl-lang/kpm/blob/main/docs/push_by_github_action.md)\\n- KCL Operator example: [https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/mutate-manifests/kcl-operator](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/mutate-manifests/kcl-operator)\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @jakezhu9 for the contribution of converting JSON and YAML configuration data to KCL configuration in the KCL Import Tool \ud83d\ude4c [https://github.com/kcl-lang/kcl-go/pull/141](https://github.com/kcl-lang/kcl-go/pull/141)\\n- Thanks to @xxmao123 and @starkers for their contributions to the KCL NeoVim and Idea IDE extensions \ud83d\ude4c [https://github.com/kcl-lang/intellij-kcl/pull/12](https://github.com/kcl-lang/intellij-kcl/pull/12)\\n- Thanks to @kolloch, @prahaladramji, and others for their valuable feedback and discussions during the use of KCL in the past two weeks \ud83d\ude4c\\n\\n**Congratulations @jakezhu9 for becoming a KCL community Maintainer \ud83c\udf89**\\n\\n## Featured Updates\\n\\n### KCL Operator\\n\\nKCL Operator provides cluster integration, allowing you to use Access Webhook to generate, mutate, or validate resources based on KCL configuration when apply resources to the cluster. Webhook will capture creation, application, and editing operations, and execute [KCLRun](https://github.com/kcl-lang/krm-kcl) on the configuration associated with each operation, and the KCL programming language can be used to\\n\\n- Add labels or annotations based on a condition.\\n- Inject a sidecar container in all KRM resources that contain a `PodTemplate`.\\n- Validating all KRM resources using KCL Schema, such as constraints on starting containers only in a root mode.\\n- Generating KRM resources using an abstract model or combining and using different KRM APIs.\\n\\nWith KCL Operator, you can automate resource configuration management and security validation in a Kubernetes cluster using lightweight KCL code, without the need to develop a webhook server to dynamically mutate and validate configurations at runtime.\\n\\nFurthermore, leveraging KCL\'s modeling and abstraction capabilities, we can define functionality abstractions/compositions for different resource APIs and expose them in the form of KCL Schema. We can further generate OpenAPI Schema definitions from KCL Schema for other clients in the cluster to use, without manually maintaining complex OpenAPI Schema definitions for API abstractions/compositions. Here is an example of using KCL Operator to modify resource annotations:\\n\\n#### 0. Prerequisites\\n\\nPrepare a Kubernetes cluster like `k3d` the kubectl tool.\\n\\n#### 1. Install KCL Operator\\n\\n```shell\\nkubectl apply -f https://raw.githubusercontent.com/kcl-lang/kcl-operator/main/config/all.yaml\\n```\\n\\nUse the following command to observe and wait for the pod status to be `Running`.\\n\\n```shell\\nkubectl get po\\n```\\n\\n#### 2. Deploy KCL Annotation Setting Model\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  # Set dynamic parameters required for the annotation modification model, here we can add the labels we want to modify/add\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Reference the annotation modification model on OCI\\n  source: oci://ghcr.io/kcl-lang/set-annotation\\nEOF\\n```\\n\\n#### 3. Deploy a Pod to Verify the Model Result\\n\\nExecute the following command to deploy a `Pod` resource:\\n\\n```shell\\nkubectl apply -f- << EOF\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: nginx\\n  annotations:\\n    app: nginx\\nspec:\\n  containers:\\n  - name: nginx\\n    image: nginx:1.14.2\\n    ports:\\n    - containerPort: 80\\nEOF\\nkubectl get po nginx -o yaml | grep kcl-operator\\n```\\n\\nWe can see the following output:\\n\\n```shell\\n    managed-by: kcl-operator\\n```\\n\\nWe can see that the Nginx Pod automatically added the annotation `managed-by=kcl-operator`.\\n\\nIn addition, besides referencing an existing model for the source field of the `KCLRun` resource, we can directly set KCL code for the source field to achieve the same effect. For example:\\n\\n```yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: set-annotation\\nspec:\\n  params:\\n    annotations:\\n      managed-by: kcl-operator\\n  # Resource modification can be achieved with just one line of KCL code\\n  source: |\\n    items = [item | {metadata.annotations: option(\\"params\\").annotations} for item in option(\\"items\\")]\\n```\\n\\nWe have provided more than 30 built-in models, and you can find more code examples in the following link: [https://github.com/kcl-lang/krm-kcl/tree/main/examples](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\n### IDE Extension Updates\\n\\nIn the past two weeks, we have integrated the KCL language server LSP into NeoVim and Idea, enabling the completion, navigation, and hover features supported by VS Code IDE in NeoVim and IntelliJ IDEA.\\n\\n- NeoVim KCL Extension\\n\\n![kcl.nvim](/img/docs/tools/Ide/neovim/overview.png)\\n\\n- IntelliJ Extension\\n\\n![intellij](/img/docs/tools/Ide/intellij/overview.png)\\n\\nFor more information on downloading, installation, and features of the IDE plugins, please refer to:\\n\\n- [https://kcl-lang.io/docs/user_docs/getting-started/install#neovim](https://kcl-lang.io/docs/user_docs/getting-started/install#neovim)\\n- [https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea](https://kcl-lang.io/docs/user_docs/getting-started/install#intellij-idea)\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community.\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-09-04-maintainer-jakezhu9-blog","metadata":{"permalink":"/blog/2023-09-04-maintainer-jakezhu9-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-04-maintainer-jakezhu9-blog/index.md","source":"@site/blog/2023-09-04-maintainer-jakezhu9-blog/index.md","title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","description":"News Flash","date":"2023-09-04T00:00:00.000Z","formattedDate":"September 4, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":2.195,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-09-04-maintainer-jakezhu9-blog","title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 08.24 - 09.06) | Kubernetes Operator, IDE Extensions and v0.5.6 are out!","permalink":"/blog/2023-09-06-biweekly-newsletter"},"nextItem":{"title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","permalink":"/blog/2023-platform-engineering-tech-summit"}},"content":"## News Flash\\n\\n![jakezhu9](/img/blog/2023-09-04-maintainer-jakezhu9-blog/jakezhu9.png)\\n\\n\ud83c\udf89 Recently, the KCL community welcomed a new member as a Maintainer. **Congratulations to jakezhu9 on successfully being promoted as a community maintainer**.\\n\\nWe would like to express our gratitude for his numerous contributions to the KCL Go SDK and the series of enhanced features he has brought to the KCL Import Tool, providing users with a more convenient and efficient experience in importing data and schemas. Here is a list of his recent significant contributions:\\n\\n- \ud83d\udd27 Support for converting JSON/YAML data to KCL configuration: [https://github.com/kcl-lang/kcl-go/pull/145](https://github.com/kcl-lang/kcl-go/pull/145)\\n- \ud83d\udd27 Support for converting Terraform Provider Schema to KCL Schema: [https://github.com/kcl-lang/kcl-go/pull/141](https://github.com/kcl-lang/kcl-go/pull/141)\\n- \ud83d\udd27 Support for converting JsonSchema to KCL Schema: [https://github.com/kcl-lang/kcl-go/pull/127](https://github.com/kcl-lang/kcl-go/pull/127)\\n\\nThe addition of the new Maintainer not only signifies jakezhu9\'s outstanding technical performance but also reflects the community\'s high recognition and trust in him.\\n\\n## Experience\\n\\nHere are jakezhu9\'s reflections on participating in the KCL community:\\n\\nI feel incredibly fortunate to be a part of the KCL community and contribute to the development and growth of the project. From the initial introduction to the KusionStack and KCL, powerful tools and languages in the cloud-native field, to fixing a simple bug in the project, and gradually designing and developing the conversion and generation aspects of KCL, I have not only improved my technical skills but also gained valuable experience in open-source contributions. I have experienced the joy and sense of accomplishment that comes with continuous progress. Every time I see one of my submitted PRs get merged, I feel a great sense of satisfaction. I am grateful to the KCL community and all the seniors and fellow contributors I have encountered along the way who have provided me with ideas and suggestions that have been incredibly helpful during my development process.\\n\\nThe KCL community is an open, vibrant, and opportune open-source community where developers from different companies and schools with diverse technical backgrounds collaborate and exchange ideas on GitHub and in community meetings. Together, they explore cutting-edge technical solutions and contribute efficient and concise code to the community. Whether you are a novice or an expert in open-source, you can quickly integrate into the community and actively participate. The harmonious and friendly atmosphere in the community makes me feel incredibly welcomed. In the future, I will continue to contribute more to the KCL community, and I warmly welcome interested students to join us and participate in the construction and development of the community together!\\n\\n## Resources\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-platform-engineering-tech-summit","metadata":{"permalink":"/blog/2023-platform-engineering-tech-summit","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-09-01-kcl-platform-engineering-tech-summit/index.md","source":"@site/blog/2023-09-01-kcl-platform-engineering-tech-summit/index.md","title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","description":"Download PDF (Chinese)","date":"2023-09-01T00:00:00.000Z","formattedDate":"September 1, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Meeting","permalink":"/blog/tags/meeting"}],"readingTime":0.03,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-platform-engineering-tech-summit","title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Meeting"]},"prevItem":{"title":"Congratulations to jakezhu9 for becoming a KCL Community Maintainer! KCL Import Tool Welcomes Enhanced Features!","permalink":"/blog/2023-09-04-maintainer-jakezhu9-blog"},"nextItem":{"title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","permalink":"/blog/2023-08-31-helmfile-kcl-plugin"}},"content":"[Download PDF (Chinese)](https://kcl-lang.github.io/talks/kcl-platform-engineering-tech-summit2023.pdf)\\n\\n![KCL Talk Cover](/img/blog/2023-09-01-kcl-platform-engineering-tech-summit/talk-cover.jpg)"},{"id":"2023-08-31-helmfile-kcl-plugin","metadata":{"permalink":"/blog/2023-08-31-helmfile-kcl-plugin","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-08-31-helmfile-kcl-plugin/index.md","source":"@site/blog/2023-08-31-helmfile-kcl-plugin/index.md","title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","description":"What is KCL","date":"2023-08-31T00:00:00.000Z","formattedDate":"August 31, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.755,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-08-31-helmfile-kcl-plugin","title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"]},"prevItem":{"title":"KCL Introduction Platform Engineering Tech Summit 2023 Meeting","permalink":"/blog/2023-platform-engineering-tech-summit"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","permalink":"/blog/2023-08-23-biweekly-newsletter"}},"content":"## What is KCL\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\n## What is Helmfile\\n\\nHelmfile is a declarative specification and tool for simplifying and managing Helm Charts. The Helmfile KCL Plugin provides additional functionality to the Helmfile tool, making it more convenient and efficient to use. With the Helmfile KCL Plugin, you can:\\n\\n- Edit or validate Helm Chart configurations directly on the client-side using non-intrusive hooks. This allows you to separate the data and logic parts of Kubernetes configuration management without needing to fork the upstream Chart to modify internal logic include modifying resource labels/annotations and injecting Sidecar container configurations.\\n- Validate Kubernetes resources using KCL Schema, define your own abstract models, and share them for reusability.\\n\\nIn this blog, we will quickly guide you through getting started with the Helmfile KCL Plugin, enabling you to easily manage your Kubernetes Helm Charts.\\n\\nWe will explain in detail using a simple example. With the Helmfile KCL Plugin, you do not need to install any components related to KCL. You only need the latest version of the Helmfile tool (v0.156.0+) on your local machine.\\n\\n## Using the Helmfile KCL Plugin\\n\\n### 1. Tool Installation\\n\\nFirst, make sure you have installed the Helmfile client tool. You can follow the instructions in the documentation link below.\\n\\nhttps://github.com/helmfile/helmfile\\n\\n### 2. Create the Helmfile Configuration File\\n\\nCreate a file named helmfile.yaml in the root directory of your project and write the configuration using Helmfile syntax. In this file, you can specify the Helm Charts to use, configuration values, and any other functionality supported by Helmfile. Additionally, you can use the features of the KCL Plugin in helmfile.yaml to load configurations and make in-place modifications and validations to the Helm Chart.\\n\\n```yaml\\nrepositories:\\n  - name: prometheus-community\\n    url: https://prometheus-community.github.io/helm-charts\\nreleases:\\n  - name: prom-norbac-ubuntu\\n    namespace: prometheus\\n    chart: prometheus-community/prometheus\\n    set:\\n      - name: rbac.create\\n        value: false\\n    transformers:\\n      # Use KCL Plugin to mutate or validate Kubernetes manifests.\\n      - apiVersion: krm.kcl.dev/v1alpha1\\n        kind: KCLRun\\n        metadata:\\n          name: \\"set-annotation\\"\\n          annotations:\\n            config.kubernetes.io/function: |\\n              container:\\n                image: docker.io/kcllang/kustomize-kcl:v0.2.0\\n        spec:\\n          source: |\\n            # A single line of KCL code can be used to modify workload configurations in-place.\\n            items = [resource | {if resource.kind == \\"Deployment\\": metadata.annotations: {\\"managed-by\\" = \\"helmfile-kcl\\"}} for resource in option(\\"resource_list\\").items]\\n```\\n\\nIn the above configuration, we reference the Prometheus Helm Chart and use a single line of KCL code to inject the label `managed-by=\\"helmfile-kcl\\"` to all the Deployment resources of Prometheus.\\n\\n### 3. Run the Helmfile Tool\\n\\nOnce everything is set up, you can run the Helmfile command to deploy, manage, and maintain your Helm Charts. Use the following command to apply the configuration mentioned above to the cluster.\\n\\n```shell\\nhelmfile apply\\n```\\n\\nYou should see the following output if everything goes well:\\n\\n```shell\\nAdding repo prometheus-community https://prometheus-community.github.io/helm-charts\\n\\"prometheus-community\\" has been added to your repositories...\\n\\n...\\n```\\n\\n## Want More?\\n\\nFor the above helmfile configuration, you can encapsulate it as a reusable logic for configuration modification without constantly writing and copying/pasting KCL code. Additionally, many commonly used Kubernetes configuration editing and validation code snippets are already packaged in the KCL official Registry: https://github.com/orgs/kcl-lang/packages\\n\\n![registry](/img/blog/2023-08-31-helmfile-kcl-plugin/registry.png)\\n\\nIn addition to supporting writing KCL code in configuration files, we also support directly referencing code snippets in Registry, as shown below\\n\\n```yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: https-only\\n  annotations:\\n    krm.kcl.dev/version: 0.0.1\\n    krm.kcl.dev/type: validation\\n    documentation: >-\\n      Requires Ingress resources to be HTTPS only.  Ingress resources must\\n      include the `kubernetes.io/ingress.allow-http` annotation, set to `false`.\\n      By default a valid TLS {} configuration is required, this can be made\\n      optional by setting the `tlsOptional` parameter to `true`.\\n      More info: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls\\nspec:\\n  # Use the OCI source\\n  source: oci://ghcr.io/kcl-lang/https-only\\n```\\n\\nSpecific example codes can be found [here](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\nIf you want to contribute more KCL code repositories, feel free to contact us and refer to the documentation for contribution: https://kcl-lang.io/zh-CN/docs/user_docs/guides/package-management/share_your_pkg/\\n\\n## Conclusion\\n\\nThis blog provided a quick getting started guide to help you master the basics of the Helmfile KCL Plugin in just 5 minutes. Now, you can start using this powerful tool to simplify and optimize your Kubernetes application deployment process!\\n\\n## Resources\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-08-23-biweekly-newsletter","metadata":{"permalink":"/blog/2023-08-23-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-08-23-biweekly-newsletter/index.md","source":"@site/blog/2023-08-23-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-08-23T00:00:00.000Z","formattedDate":"August 23, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":5.31,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-08-23-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"5-Minute Gameplay with Helmfile KCL Plugin for Easy Management of Kubernetes Helm Charts","permalink":"/blog/2023-08-31-helmfile-kcl-plugin"},"nextItem":{"title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","permalink":"/blog/2023-08-09-biweekly-newsletter"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nThank you to all contributors for their outstanding work over the past two weeks (08.10-08.23 2023). Here is an overview of the key content:\\n\\n**\ud83d\udd27 Language and Toolchain Updates**\\n\\n- **KCL Formatting Tool Updates** - Support for formatting code snippets with syntax errors and partial code snippets and automatic correction of indentation errors in configuration blocks.\\n- **KCL Documentation Tool Updates** - Support for exporting document index pages\\n- **KCL Import Tool Updates** - Support for converting Terraform Provider Schema to KCL Schema\\n- **KCL Export Tool Updates** - Support for exporting OpenAPI Spec from KCL Schema, integrating with OpenAPI ecosystem\\n- **KCL IDE Updates** - Support for compilation cache feature to improve performance of some IDE features and providing rich error messages and import statement quick fix capabilities\\n- **KCL Package Management Tool Updates** - Support for output information experience optimization for the `kpm push` command and adding duplicate tag check when pushing KCL package. Adding the `--vendor` parameter for the `kpm push` and `kpm pkg` commands to determine whether to package third-party libraries in KCL packages together\\n- **KCL Language Updates** - Optimize Schema semantic check and union type check error messages and support for exporting type output of configuration blocks.\\n\\n\ud83c\udfc4 **API Updates**\\n\\n- KCL Schema model parsing GetSchemaType API newly added KCL package related information and schema attribute default values.\\n\\n**\ud83d\udcf0 Official Website and Use Case Updates**\\n\\n- KCL package docker.io integration example: _[https://github.com/kcl-lang/kpm/blob/main/docs/publish_to_docker_reg.md](https://github.com/kcl-lang/kpm/blob/main/docs/publish_to_docker_reg.md)_\\n- KCL Gitlab CI integration example: _[https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci](https://kcl-lang.io/docs/user_docs/guides/ci-integration/gitlab-ci)_\\n- KCL Vault and Vals Integration example: _[https://kcl-lang.io/docs/user_docs/guides/secret-management/vault](https://kcl-lang.io/docs/user_docs/guides/secret-management/vault)_\\n\\n## Special Thanks\\n\\nThe following are listed in no particular order:\\n\\n- Thanks to @jakezhu9 for the contribution of the KCL Import Tool Terraform Schema to KCL Schema conversion \ud83d\ude4c [https://github.com/kcl-lang/kcl-go/pull/141](https://github.com/kcl-lang/kcl-go/pull/141)\\n- Thanks to @xxmao123 and @starkers for the discussion and contribution of the NeoVim KCL extension \ud83d\ude4c [https://github.com/kcl-lang/vim-kcl/pull/2](https://github.com/kcl-lang/vim-kcl/pull/2)\\n- Thanks to @starkers for adding KCL installation support to the mason.nvim registry \ud83d\ude4c [https://github.com/mason-org/mason-registry/pull/2425](https://github.com/mason-org/mason-registry/pull/2425)\\n- Thanks to @prahaladramji for upgrading and updating the KCL Homebrew installation script \ud83d\ude4c [https://github.com/kcl-lang/homebrew-tap/pull/1](https://github.com/kcl-lang/homebrew-tap/pull/1)\\n- Thanks to @yamin-oanda for the discussion of Pulumi\'s official KCL support \ud83d\ude4c [https://github.com/pulumi/pulumi/discussions/13722](https://github.com/pulumi/pulumi/discussions/13722)\\n- In addition, thanks to @nkabir, @mihaigalos, @prahaladramji, @yamin-oanda, @magick93, @MirKml, and others for their valuable feedback and discussions while using KCL in the past two weeks. \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### KCL Import Tool Updates\\n\\nThe KCL Import Tool now adds support for converting Terraform Provider Schema to KCL Schema based on Protobuf, JsonSchema OpenAPI models, and Go Structures, such as the following Terraform Provider Json (obtained through the command `terraform providers schema -json > provider.json` , For more details, please refer to [https://developer.hashicorp.com/terraform/cli/commands/providers/schema](https://developer.hashicorp.com/terraform/cli/commands/providers/schema))\\n\\n```json\\n{\\n  \\"format_version\\": \\"0.2\\",\\n  \\"provider_schemas\\": {\\n    \\"registry.terraform.io/aliyun/alicloud\\": {\\n      \\"provider\\": {\\n        \\"version\\": 0,\\n        \\"block\\": {\\n          \\"attributes\\": {},\\n          \\"block_types\\": {},\\n          \\"description_kind\\": \\"plain\\"\\n        }\\n      },\\n      \\"resource_schemas\\": {\\n        \\"alicloud_db_instance\\": {\\n          \\"version\\": 0,\\n          \\"block\\": {\\n            \\"attributes\\": {\\n              \\"db_instance_type\\": {\\n                \\"type\\": \\"string\\",\\n                \\"description_kind\\": \\"plain\\",\\n                \\"computed\\": true\\n              },\\n              \\"engine\\": {\\n                \\"type\\": \\"string\\",\\n                \\"description_kind\\": \\"plain\\",\\n                \\"required\\": true\\n              },\\n              \\"security_group_ids\\": {\\n                \\"type\\": [\\"set\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true,\\n                \\"computed\\": true\\n              },\\n              \\"security_ips\\": {\\n                \\"type\\": [\\"set\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true,\\n                \\"computed\\": true\\n              },\\n              \\"tags\\": {\\n                \\"type\\": [\\"map\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true\\n              }\\n            },\\n            \\"block_types\\": {},\\n            \\"description_kind\\": \\"plain\\"\\n          }\\n        },\\n        \\"alicloud_config_rule\\": {\\n          \\"version\\": 0,\\n          \\"block\\": {\\n            \\"attributes\\": {\\n              \\"compliance\\": {\\n                \\"type\\": [\\n                  \\"list\\",\\n                  [\\n                    \\"object\\",\\n                    {\\n                      \\"compliance_type\\": \\"string\\",\\n                      \\"count\\": \\"number\\"\\n                    }\\n                  ]\\n                ],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"computed\\": true\\n              },\\n              \\"resource_types_scope\\": {\\n                \\"type\\": [\\"list\\", \\"string\\"],\\n                \\"description_kind\\": \\"plain\\",\\n                \\"optional\\": true,\\n                \\"computed\\": true\\n              }\\n            }\\n          }\\n        }\\n      },\\n      \\"data_source_schemas\\": {}\\n    }\\n  }\\n}\\n```\\n\\nThen the tool can output the following KCL code\\n\\n```python\\n\\"\\"\\"\\nThis file was generated by the KCL auto-gen tool. DO NOT EDIT.\\nEditing this file might prove futile when you re-run the KCL auto-gen generate command.\\n\\"\\"\\"\\n\\nschema AlicloudConfigRule:\\n    \\"\\"\\"\\n    AlicloudConfigRule\\n\\n    Attributes\\n    ----------\\n    compliance: [ComplianceObject], optional\\n    resource_types_scope: [str], optional\\n    \\"\\"\\"\\n\\n    compliance?: [ComplianceObject]\\n    resource_types_scope?: [str]\\n\\nschema ComplianceObject:\\n    \\"\\"\\"\\n    ComplianceObject\\n\\n    Attributes\\n    ----------\\n    compliance_type: str, optional\\n    count: int, optional\\n    \\"\\"\\"\\n\\n    compliance_type?: str\\n    count?: int\\n\\nschema AlicloudDbInstance:\\n    \\"\\"\\"\\n    AlicloudDbInstance\\n\\n    Attributes\\n    ----------\\n    db_instance_type: str, optional\\n    engine: str, required\\n    security_group_ids: [str], optional\\n    security_ips: [str], optional\\n    tags: {str:str}, optional\\n    \\"\\"\\"\\n\\n    db_instance_type?: str\\n    engine: str\\n    security_group_ids?: [str]\\n    security_ips?: [str]\\n    tags?: {str:str}\\n\\n    check:\\n        isunique(security_group_ids)\\n        isunique(security_ips)\\n```\\n\\n### KCL Vault Integration\\n\\nIn just three steps, we can use Vault to store and manage sensitive information and use it in KCL.\\n\\nFirstly, we install and use `Vault` to store `foo` and `bar` information\\n\\n```shell\\nvault kv put secret/foo foo=foo\\nvault kv put secret/bar bar=bar\\n```\\n\\nThen write the following KCL code (main.k)\\n\\n```python\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"nginx\\"\\n    labels.app = \\"nginx\\"\\n    annotations: {\\n        \\"secret-store\\": \\"vault\\"\\n        # Valid format:\\n        #  \\"ref+vault://PATH/TO/KV_BACKEND#/KEY\\"\\n        \\"foo\\": \\"ref+vault://secret/foo#/foo\\"\\n        \\"bar\\": \\"ref+vault://secret/bar#/bar\\"\\n    }\\n}\\nspec = {\\n    replicas = 3\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"${metadata.name}:1.14.2\\"\\n            ports = [{ containerPort = 80 }]\\n        }\\n    ]\\n}\\n```\\n\\nFinally, the decrypted configuration can be obtained through the `Vals` command-line tool\\n\\n```shell\\nkcl main.k | vals eval -f -\\n```\\n\\n> For more details and use cases, please refer to [https://kcl-lang.io/docs/user_docs/guides/secret-management/vault](https://kcl-lang.io/docs/user_docs/guides/secret-management/vault)\\n\\n## Community\\n\\n- \ud83c\udf89 Congratulations to Zhu Junxing from Huazhong University of Science and Technology for successfully passing the mid-term assessment of the Gitlink Coding Summer Camp (GLCC) and completing the conversion of KCL Import tool Jsonschema and Terraform Provider Schema to KCL Schema. The community will grant him the KCL Community Maintainer role in the future.\\n- \ud83d\udcbb KCL participated in the CNCF TAG Application Delivery community meeting and reported on the project.\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. We will write more articles on the new features of KCL v0.5.x, so stay tuned!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)"},{"id":"2023-08-09-biweekly-newsletter","metadata":{"permalink":"/blog/2023-08-09-biweekly-newsletter","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-08-09-biweekly-newsletter/index.md","source":"@site/blog/2023-08-09-biweekly-newsletter/index.md","title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","description":"KCL is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.","date":"2023-08-09T00:00:00.000Z","formattedDate":"August 9, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Biweekly-Newsletter","permalink":"/blog/tags/biweekly-newsletter"}],"readingTime":3.655,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-08-09-biweekly-newsletter","title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Biweekly-Newsletter"],"image":"/img/biweekly-newsletter.png"},"prevItem":{"title":"KCL Biweekly Newsletter (2023 08.10 - 08.23) | KCL v0.5.3, v0.5.4 and v0.5.5 are out!","permalink":"/blog/2023-08-23-biweekly-newsletter"},"nextItem":{"title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","permalink":"/blog/2023-07-31-kcl-github-argocd-gitops"}},"content":"![](/img/biweekly-newsletter.png)\\n\\n[KCL](https://github.com/kcl-lang) is an open-source, constraint-based record and functional language that enhances the writing of complex configurations, including those for cloud-native scenarios. With its advanced programming language technology and practices, KCL is dedicated to promoting better modularity, scalability, and stability for configurations. It enables simpler logic writing and offers ease of automation APIs and integration with homegrown systems.\\n\\nThis section will update the KCL language community\'s latest developments every two weeks, including features, website updates, and the latest community news, helping everyone better understand the KCL community!\\n\\n**_KCL Website: [https://kcl-lang.io](https://kcl-lang.io)_**\\n\\n## Overview\\n\\nIn the past two weeks (2023 07.26 to 08.09), a total of 34 PRs were merged in all KCL projects. Thanks to all contributors for their outstanding work. The following is a summary of the merged PRs.\\n\\n- **\ud83d\udd27 Language and toolchain updates**\\n  - KCL document tool update - Markdown document export support\\n  - KCL import tool update - JsonSchema - KCL schema conversion support\\n  - KCL package management tool KPM supports setting compilation parameters in kcl.mod, optimizing command line prompts\\n  - KCL IDE extension autocomplete, jump, hover document display optimization and Vim and NeoVim KCL plugin support\\n- **\ud83c\udfc4 API updates**\\n  - KCL Schema model parsing GetSchemaType API newly added decorator information and package information fields\\n- **\ud83c\udfe0 Community extension updates**\\n  - Helmfile KCL plugin support\\n- **\ud83d\udcf0 Website and case updates**\\n  - KCL website adds v0.5.x document version selection\\n  - Add KCL use case repository: [https://github.com/kcl-lang/examples](https://github.com/kcl-lang/examples)\\n\\n## Special Thanks\\n\\n- Thanks to @jakezhu9 for contributing to the conversion of JsonSchema to KCL Schema in the KCL Import tool \ud83d\ude4c\\n- Thanks to @xxmao123 for contributing to Vim and NeoVim KCL plugins \ud83d\ude4c\\n- Thanks to @yyxhero for the help and support provided in Helmfile KCL plugin support \ud83d\ude4c\\n- Thanks to @nkabir, @mihaigalos, @prahaladramji, @dhhopen, etc. for their valuable suggestions and discussions on using KCL \ud83d\ude4c\\n\\n## Featured Updates\\n\\n### KCL Import Tool Update\\n\\nOn the basis of converting Protobuf, OpenAPI models, and Go structures into KCL Schema, the KCL Import tool adds support for converting JsonSchema to KCL Schema. For example, for the following JsonSchema:\\n\\n```json\\n{\\n  \\"$schema\\": \\"http://json-schema.org/draft-07/schema#\\",\\n  \\"$id\\": \\"https://example.com/schemas/customer.json\\",\\n  \\"type\\": \\"object\\",\\n  \\"$defs\\": {\\n    \\"address\\": {\\n      \\"type\\": \\"object\\",\\n      \\"properties\\": {\\n        \\"city\\": {\\n          \\"type\\": \\"string\\"\\n        },\\n        \\"state\\": {\\n          \\"$ref\\": \\"#/$defs/state\\"\\n        }\\n      }\\n    },\\n    \\"state\\": {\\n      \\"type\\": \\"object\\",\\n      \\"properties\\": {\\n        \\"name\\": {\\n          \\"type\\": \\"string\\"\\n        }\\n      }\\n    }\\n  },\\n  \\"properties\\": {\\n    \\"name\\": {\\n      \\"type\\": \\"string\\"\\n    },\\n    \\"address\\": {\\n      \\"$ref\\": \\"#/$defs/address\\"\\n    }\\n  }\\n}\\n```\\n\\nAfter using the KCL Import tool, the output KCL code is as follows:\\n\\n```python\\nschema\xa0Customer:\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\xa0\xa0\xa0\xa0Customer\\n\\n\xa0\xa0\xa0\xa0Attributes\\n\xa0\xa0\xa0\xa0----------\\n\xa0\xa0\xa0\xa0name:\xa0str,\xa0optional\\n\xa0\xa0\xa0\xa0address:\xa0Address,\xa0optional\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\\n\xa0\xa0\xa0\xa0name?:\xa0str\\n\xa0\xa0\xa0\xa0address?:\xa0Address\\n\\nschema\xa0Address:\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\xa0\xa0\xa0\xa0Address\\n\\n\xa0\xa0\xa0\xa0Attributes\\n\xa0\xa0\xa0\xa0----------\\n\xa0\xa0\xa0\xa0city:\xa0str,\xa0optional\\n\xa0\xa0\xa0\xa0state:\xa0State,\xa0optional\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\\n\xa0\xa0\xa0\xa0city?:\xa0str\\n\xa0\xa0\xa0\xa0state?:\xa0State\\n\\nschema\xa0State:\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\xa0\xa0\xa0\xa0State\\n\\n\xa0\xa0\xa0\xa0Attributes\\n\xa0\xa0\xa0\xa0----------\\n\xa0\xa0\xa0\xa0name:\xa0str,\xa0optional\\n\xa0\xa0\xa0\xa0\\"\\"\\"\\n\\n\xa0\xa0\xa0\xa0name?:\xa0str\\n```\\n\\n### Helmfile KCL Plugin\\n\\nHelmfile is a declarative specification and tool for deploying Helm Charts. With the Helmfile KCL plugin, you can:\\n\\n- Edit or verify Helm Chart through non-invasive hook methods, separating the data and logic parts of Kubernetes configuration management\\n  - Modify resource labels/annotations, inject sidecar container configuration\\n  - Use KCL schema to validate resources\\n  - Define your own abstract application models\\n- Maintain multiple environment and tenant configurations elegantly, rather than simply copying and pasting.\\n\\nHere is a detailed explanation using a simple example. With the Helmfile KCL plugin, you do not need to install any components related to KCL. You only need the latest version of the Helmfile tool on your local device.\\n\\nWe can write a `helmfile.yaml` file as follows:\\n\\n```yaml\\nrepositories:\\n-\xa0name:\xa0prometheus-community\\n\xa0\xa0url:\xa0https://prometheus-community.github.io/helm-charts\\n\\nreleases:\\n-\xa0name:\xa0prom-norbac-ubuntu\\n\xa0\xa0namespace:\xa0prometheus\\n\xa0\xa0chart:\xa0prometheus-community/prometheus\\n\xa0\xa0set:\\n\xa0\xa0-\xa0name:\xa0rbac.create\\n\xa0\xa0\xa0\xa0value:\xa0false\\n\xa0\xa0transformers:\\n\xa0\xa0#\xa0Use\xa0KCL\xa0Plugin\xa0to\xa0mutate\xa0or\xa0validate\xa0Kubernetes\xa0manifests.\\n\xa0\xa0-\xa0apiVersion:\xa0krm.kcl.dev/v1alpha1\\n\xa0\xa0\xa0\xa0kind:\xa0KCLRun\\n\xa0\xa0\xa0\xa0metadata:\\n\xa0\xa0\xa0\xa0\xa0\xa0name:\xa0\\"set-annotation\\"\\n\xa0\xa0\xa0\xa0\xa0\xa0annotations:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0config.kubernetes.io/function:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0container:\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0image:\xa0docker.io/kcllang/kustomize-kcl:v0.2.0\\n\xa0\xa0\xa0\xa0spec:\\n\xa0\xa0\xa0\xa0\xa0\xa0source:\xa0|\\n\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0[resource\xa0|\xa0{if\xa0resource.kind\xa0==\xa0\\"Deployment\\":\xa0metadata.annotations:\xa0{\\"managed-by\\"\xa0=\xa0\\"helmfile-kcl\\"}}\xa0for\xa0resource\xa0in\xa0option(\\"resource_list\\").items]\\n```\\n\\nIn the above file, we referenced the Prometheus Helm Chart and injected the `managed-by=\\"helmfile-kcl\\"` label into all deployment resources of Prometheus with just one line of KCL code. The following command can be used to deploy the above configuration to the Kubernetes cluster:\\n\\n```shell\\nhelmfile\xa0apply\\n```\\n\\nFor more use cases, please refer to [https://github.com/kcl-lang/krm-kcl](https://github.com/kcl-lang/krm-kcl)\\n\\n## Resources\\n\\n\u2764\ufe0f Thanks to all KCL users and community members for their valuable feedback and suggestions in the community. We will write more articles on the new features of KCL v0.5.x, so stay tuned!\\n\\nFor more resources, please refer to\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [KusionStack Website](https://kusionstack.io/)\\n\\n- [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap)\\n- [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6)\\n- [KCL Github Issues](https://github.com/kcl-lang/kcl/issues)\\n- [KCL Github Discussion](https://github.com/orgs/kcl-lang/discussions)\\n- [KCL Community](https://github.com/kcl-lang/community)\\n- [KCL v0.5.0 Release](https://github.com/kcl-lang/kcl/releases/tag/v0.5.0)\\n- [KCL v0.5.1 Release](https://github.com/kcl-lang/kcl/releases/tag/v0.5.1)\\n- [KCL v0.5.2\xa0Release](https://github.com/kcl-lang/kcl/releases/tag/v0.5.2)"},{"id":"2023-07-31-kcl-github-argocd-gitops","metadata":{"permalink":"/blog/2023-07-31-kcl-github-argocd-gitops","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-31-kcl-github-argocd-gitops/index.md","source":"@site/blog/2023-07-31-kcl-github-argocd-gitops/index.md","title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","description":"Introduction","date":"2023-07-31T00:00:00.000Z","formattedDate":"July 31, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Github","permalink":"/blog/tags/github"},{"label":"ArgoCD","permalink":"/blog/tags/argo-cd"},{"label":"GitOps","permalink":"/blog/tags/git-ops"}],"readingTime":8.14,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-07-31-kcl-github-argocd-gitops","title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Github","ArgoCD","GitOps"]},"prevItem":{"title":"KCL Biweekly Newsletter (2023 07.26 - 08.09) | KCL v0.5.1 and v0.5.2 is out!","permalink":"/blog/2023-08-09-biweekly-newsletter"},"nextItem":{"title":"KCL Introduction Slides","permalink":"/blog/2023-07-18-kcl-intro-slides"}},"content":"## Introduction\\n\\nIn modern software development, GitOps, as a single truth automation method for managing infrastructure and applications, plays a key role in improving efficiency and reducing Human error, and is now widely popular in cloud-native and other fields. However, there are not many practical examples related to GitOps. This blog will use KCL, Github and ArgoCD as examples to introduce GitOps in detail, hoping to help everyone practice their own GitOps automation process and simplify DevOps.\\n\\n### What is GitOps\\n\\nGitOps is a modern way to do continuous delivery. Its core idea is to have a Git repository which contains environmental and application configurations. An automated process is also needed for sync the config to cluster.\\n\\nBy changing the files in repository, developers can apply the applications automatically. The benefits of applying GitOps include:\\n\\n- Increased productivity. Continuous delivery can speed up the time of deployment.\\n- Lower the barrier for developer to deploy. By pushing code instead of container configuration, developers can easily deploy Kubernetes without knowing its internal implementation.\\n- Trace the change records. Managing the cluster with Git makes every change traceable, enhancing the audit trail.\\n- Recover the cluster with Git\'s rollback and branch.\\n\\n### GitOps with KCL\\n\\nBenefits of Using KCL and ArgoCD Together:\\n\\n- KCL can help us **simplify complex Kubernetes deployment configuration files**, reduce the error rate of manually writing YAML files, control configuration constraint checking during compilation, and perceive errors immediately upon writing; At the same time, KCL can be used to eliminate redundant configuration templates, enhance the scalability of multi-environment and multi-tenant configurations, and improve the readability and maintainability of configurations.\\n- ArgoCD can **automate** the deployment of Kubernetes applications, achieve continuous deployment, and provide comprehensive monitoring and control functions.\\n- By combining KCL and ArgoCD, deployment efficiency can be improved, errors reduced, and management and monitoring of Kubernetes applications strengthened.\\n- The combination of KCL and ArgoCD can also help us achieve **Infrastructure as Code (IaC)**, simplify application deployment and management, and better implement DevOps principles.\\n\\nWith GitOps, developer and operation teams can manage application deployment and configuration by modifying KCL code and generating YAML files. The GitOps toolchain will automatically synchronize the changes to the Kubernetes cluster, enabling continuous deployment and ensuring consistency. If there are issues, the GitOps toolchain can be used to quickly rollback.\\n\\n## Workflow\\n\\nWe hope to implement the end-to-end application development process by using containers, Continuous Integration (CI) for generation, and GitOps for Continuous Deployment (CD). In this scheme, we use a **Flask application** and **Github Actions** as examples.\\n\\n> Note: You can use any containerized application and different CI systems such as **Gitlab CI**, **Jenkins CI**, etc. in this solution.\\n\\nWe divide the Python Flask application code and configuration code into two repos, _to achieve the separation of concerns of different roles, such as developers and operation and maintenance teams_\\n\\n- App code repo: https://github.com/kcl-lang/flask-demo\\n- Config manifest repo: https://github.com/kcl-lang/flask-demo-kcl-manifests\\n\\nThe overall workflow is as follows:\\n\\n![workflow](/img/blog/2023-07-31-kcl-github-argocd-gitops/workflow.jpg)\\n\\n1. Pull application code from Github.\\n2. Develop and submit application code to the GitHub repository.\\n3. Trigger GitHub Actions to compile the application code, generate container images, and push the container images to the Docker Hub container registry.\\n4. Trigger GitHub Actions to synchronously update the Kubernetes manifest files defined by KCL based on the version of the container image in the `docker.io` container registry.\\n5. ArgoCD obtains Kubernetes manifest changes and updates deployment to Kubernetes cluster.\\n\\n## Steps\\n\\n### 0. Prerequisite\\n\\n- Familiar with the basic commands of Unix/Linux\\n- Familiar with Git and Github Action\\n- Understand the basics of Kubernetes\\n- Understand tools such as ArgoCD\\n- Understand the basic knowledge of KCL\\n\\n### 1. Setup Kubernetes Cluster\\n\\n- Install [K3d](https://github.com/k3d-io/k3d) to create a default cluster.\\n\\n```bash\\nk3d cluster create mycluster\\n```\\n\\n> Note: You can use other methods in this solution to create your own Kubernetes cluster, such as `kind`, `minikube`, etc.\\n\\n### 2. Setup ArgoCD\\n\\n#### Setup ArgoCD Controllers\\n\\n- Install [ArgoCD](https://github.com/argoproj/argo-cd/releases/).\\n\\n```bash\\nkubectl create namespace argocd\\nkubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\\n```\\n\\n- Enable ArgoCD KCL Plugin\\n\\nWrite the patch YAML configuration file and update the ArgoCD configuration:\\n\\n```bash\\ngit clone https://github.com/kcl-lang/kcl-lang.io.git/ && cd ./kcl-lang.io/examples/gitops\\nkubectl apply -f ./install/kcl-cmp.yaml\\n```\\n\\nAfter completing the first step, ArgoCD will recognize the KCL plugin, but the KCL plugin has not been loaded into the ArgoCD image. To implement configuration drift detection, we have to tune the Deployment of argocd-repo-server.\\n\\n```bash\\nkubectl -n argocd patch deploy/argocd-repo-server -p \\"$(cat ./install/patch-argocd-repo-server.yaml)\\"\\n```\\n\\nWait for the init container to complete execution (Running).\\n\\n```bash\\nkubectl get pod -n argocd -l app.kubernetes.io/name=argocd-repo-server\\n```\\n\\n- To access the ArgoCD web UI\\n\\n```bash\\nkubectl port-forward svc/argocd-server -n argocd 8080:443\\n```\\n\\n- Open a browser and go to: `https://localhost:8080`\\n\\n- The username is \\"admin\\" and password get be obtained from the following command:\\n\\n```bash\\nkubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\\"{.data.password}\\" | base64 -d\\n```\\n\\n#### Setup ArgoCD CLI\\n\\n- Install [ArgoCD CLI](https://github.com/argoproj/argo-cd/releases)\\n\\nUse \\"admin\\" and password to login to ArgoCD\\n\\n```bash\\nargocd login localhost:8080\\n```\\n\\nCreate ArgoCD Application\\n\\n```bash\\nargocd app create flaskdemo \\\\\\n--repo https://github.com/kcl-lang/flask-demo-kcl-manifests \\\\\\n--path . \\\\\\n--dest-namespace default \\\\\\n--dest-server https://kubernetes.default.svc \\\\\\n--config-management-plugin kcl-v1.0\\n```\\n\\nAfter successfully creating, you can see the following output:\\n\\n```bash\\napplication \'flaskdemo\' created\\n```\\n\\n> If you are using a private repository, you need to configure the private repository access with private key credentials before executing the create command.Please refer [Private Repositories](https://argo-cd.readthedocs.io/en/stable/user-guide/private-repositories/#ssh-private-key-credential) for more details.\\n\\nThrough the ArgoCD UI, you can see that the created applications have not been synchronized yet. Here, you can manually synchronize or set automatic synchronization.\\n\\n![](/img/docs/user_docs/guides/gitops/argocd-kcl-app.jpg)\\n\\nFor more information on synchronization strategies, see [Sync Options](https://argo-cd.readthedocs.io/en/stable/user-guide/sync-options/)\\n\\n![](/img/docs/user_docs/guides/gitops/argocd-kcl-app-dashboard.jpg)\\n\\n### 3. Get the Application Code\\n\\n```shell\\ngit clone https://github.com/kcl-lang/flask-demo.git/\\ncd flask-demo\\n```\\n\\nThis is a web application written in Python. We can use the `Dockerfile` in the application directory to generate a container image of this application, and also use Github CI to automatically build a image named `flask_demo`, the CI configuration is as follows\\n\\n```yaml\\n# This is a basic workflow to help you get started with Actions\\n\\nname: CI\\n\\n# Controls when the workflow will run\\non:\\n  # Triggers the workflow on push or pull request events but only for the main branch\\n  push:\\n    branches: [main]\\n  pull_request:\\n    branches: [main]\\n\\n  # Allows you to run this workflow manually from the Actions tab\\n  workflow_dispatch:\\n\\n# A workflow run is made up of one or more jobs that can run sequentially or in parallel\\njobs:\\n  # This workflow contains a single job called \\"build\\"\\n  build:\\n    # The type of runner that the job will run on\\n    runs-on: ubuntu-latest\\n\\n    # Steps represent a sequence of tasks that will be executed as part of the job\\n    steps:\\n      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it\\n      - uses: actions/checkout@v2\\n\\n      - name: Docker Login\\n        uses: docker/login-action@v1.10.0\\n        with:\\n          username: ${{ secrets.DOCKER_USERNAME }}\\n          password: ${{ secrets.DOCKER_PASSWORD }}\\n          logout: true\\n\\n      # Runs a set of commands using the runners shell\\n      - name: build image\\n        run: |\\n          make image\\n          docker tag flask_demo:latest ${{ secrets.DOCKER_USERNAME }}/flask_demo:${{ github.sha }}\\n          docker push ${{ secrets.DOCKER_USERNAME }}/flask_demo:${{ github.sha }}\\n\\n      # Trigger KCL manifest\\n      - name: Trigger CI\\n        uses: InformaticsMatters/trigger-ci-action@1.0.1\\n        with:\\n          ci-owner: kcl-lang\\n          ci-repository: flask-demo-kcl-manifests\\n          ci-ref: refs/heads/main\\n          ci-user: kcl-bot\\n          ci-user-token: ${{ secrets.DEPLOY_ACCESS_TOKEN }}\\n          ci-name: CI\\n          ci-inputs: >-\\n            image=${{ secrets.DOCKER_USERNAME }}/flask_demo\\n            sha-tag=${{ github.sha }}\\n```\\n\\nWe need the workflow in the source code repository to automatically trigger the workflow in the deployment manifest repository. At this point, we need to create a `secrets.DEPLOY_ACCESS_TOKEN` with Github CI operation permissions and **Docker Hub** image push account information `secrets.DOCKER_USERNAME` and `secrets.DOCKER_PASSWORD` can be configured in the `Secrets and variables` settings of the Github, as shown in the following figure\\n\\n![](/img/docs/user_docs/guides/ci-integration/github-secrets.png)\\n\\n### 4. Commit the Application Code\\n\\nAfter submitting in the `flask-demo` repository, Github will automatically build a container image and push it to the Docker hub. It will also then trigger the Action of the `flask-demo-kcl-manifest` repository and modify the image value in the deployment manifest repository through [KCL Automation API](/docs/user_docs/guides/automation). Now let\'s create a submission in the `flask-demo` repository, and we can see that the code submission triggers the Github CI process for the application repository.\\n\\n![](/img/docs/user_docs/guides/ci-integration/app-ci.png)\\n\\n### 5. Configuration Automatic Update\\n\\nAfter the Github CI process in the application repository is completed, an automatic update configuration CI will be triggered in the repository where the KCL configuration is stored and submitted to the main branch of the `flask-demo-kcl-manifests` repository. The commit information is as follows\\n\\n![](/img/docs/user_docs/guides/ci-integration/image-auto-update.png)\\n\\n- We can obtain the deployment manifest source code for compilation and validation\\n\\n```shell\\ngit clone https://github.com/kcl-lang/flask-demo-kcl-manifests.git/\\ncd flask-demo-kcl-manifests\\ngit checkout main && git pull && kcl\\n```\\n\\nThe output YAML is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: flask_demo\\n  template:\\n    metadata:\\n      labels:\\n        app: flask_demo\\n    spec:\\n      containers:\\n        - name: flask_demo\\n          image: \\"kcllang/flask_demo:6428cff4309afc8c1c40ad180bb9cfd82546be3e\\"\\n          ports:\\n            - protocol: TCP\\n              containerPort: 5000\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  type: NodePort\\n  selector:\\n    app: flask_demo\\n  ports:\\n    - port: 5000\\n      protocol: TCP\\n      targetPort: 5000\\n```\\n\\nFrom the above configuration, it can be seen that the image of the resource is indeed automatically updated to the newly constructed image value. In addition, we can also use the **Argo CD KCL plugin** to automatically synchronize data from the Git repository and deploy the application to the Kubernetes cluster.\\n\\n## Conclusion\\n\\nThrough the blog, we can use Github, ArgoCD, and KCL to create GitOps automated pipelines, which can efficiently and stably build containerized applications, while automatically updating the latest Dbroker image labels and keeping Git configuration consistent with cluster configuration. In addition, the combination of KCL and ArgoCD can help us better realize Infrastructure as Code (IaC), improve deployment efficiency, achieve the separation of concerns of different roles, and simplify the configuration management of applications."},{"id":"2023-07-18-kcl-intro-slides","metadata":{"permalink":"/blog/2023-07-18-kcl-intro-slides","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-18-kcl-intro-slides/index.md","source":"@site/blog/2023-07-18-kcl-intro-slides/index.md","title":"KCL Introduction Slides","description":"Download PDF","date":"2023-07-18T00:00:00.000Z","formattedDate":"July 18, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.01,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-07-18-kcl-intro-slides","title":"KCL Introduction Slides","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"Implementing GitOps using Github, Argo CD, and KCL to Simplify DevOps","permalink":"/blog/2023-07-31-kcl-github-argocd-gitops"},"nextItem":{"title":"KCL v0.5.0 Release Blog","permalink":"/blog/2022-kcl-0.5.0-release-blog"}},"content":"[Download PDF](https://kcl-lang.github.io/talks/kcl-intro.pdf)"},{"id":"2022-kcl-0.5.0-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.5.0-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-14-kcl-0.5.0-release/index.md","source":"@site/blog/2023-07-14-kcl-0.5.0-release/index.md","title":"KCL v0.5.0 Release Blog","description":"Introduction","date":"2023-07-14T00:00:00.000Z","formattedDate":"July 14, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":12.21,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.5.0-release-blog","title":"KCL v0.5.0 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Introduction Slides","permalink":"/blog/2023-07-18-kcl-intro-slides"},"nextItem":{"title":"Rewrite KCL LSP in Rust","permalink":"/blog/2023/07/10/kcl-LSP"}},"content":"\x3c!-- KCL v0.5.0 is Coming - Better Language, Toolchain, Integrations for Cloud Native --\x3e\\n\\n## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.5.0 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n- _Use KCL language and IDE with more complete features and fewer errors to improve code writing experience and efficiency._\\n- _Use KPM, KCL OpenAPI, OCI Registry and other tools to directly use and share your cloud native domain models, reducing learning and hands-on costs._\\n- _Using community tools such as Github Action, ArgoCD, and Kubectl KCL plugins to integrate and extend support to improve automation efficiency._\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.5.0) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.5.0 and recent developments in the KCL community to readers.\\n\\n## Language\\n\\n### Top-level Variable Output\\n\\nIn previous versions of KCL, running the following KCL code will not output YAML. In KCL v0.5.0, we improved this and supported exporting top-level variables to YAML configuration to reduce additional KCL code and command-line parameters, such as for the following KCL code (main.k)\\n\\n```python\\nschema Nginx:\\n    http: Http\\n\\nschema Http:\\n    server: Server\\n\\nschema Server:\\n    listen: int | str\\n    location?: Location\\n\\nschema Location:\\n    root: str\\n    index: str\\n\\nNginx {  # Nginx will be output\\n    http.server = {\\n        listen = 80\\n        location = {\\n            root = \\"/var/www/html\\"\\n            index = \\"index.html\\"\\n        }\\n    }\\n}\\n```\\n\\nIn the new version, running KCL code can directly obtain the following output\\n\\n```yaml\\n$ kcl main.k\\nhttp:\\n  server:\\n    listen: 80\\n    location:\\n      root: /var/www/html\\n      index: index.html\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/556) for more.\\n\\n### Index Signature\\n\\nIn previous versions of KCL, running the KCL command-line tool once only displayed one error message and warning. In KCL v0.5.0, it supported the ability to display multiple errors and warnings in one compilation and improved error information to improve the efficiency of KCL code error troubleshooting, such as for the following KCL code (main.k).\\n\\n```python\\nschema TeamSpec:\\n    fullName: str\\n    name = id\\n    shortName: str = name\\n\\nschema TeamMap:\\n    [n: str]: TeamSpec = TeamSpec {\\n        name = n  # n is the schema index signature key alias, we can use it directly\\n    }\\n\\nteamMap = TeamMap {\\n    a.fullName = \\"alpha\\"\\n    b.fullName = \\"bravo\\"\\n}\\n```\\n\\nIn the new version, running KCL code can directly obtain the following output.\\n\\n```shell\\n$ kcl main.k\\nteamMap:\\n  b:\\n    fullName: bravo\\n    name: b\\n    shortName: b\\n  a:\\n    fullName: alpha\\n    name: a\\n    shortName: a\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/582) for more.\\n\\n### Runtime Backtrace Output\\n\\nIn previous versions of KCL, when writing the following KCL code, the two schema configurations with the same name were merged and output. In KCL v0.5.0, it was required to explicitly use the attribute merge operator instead of the attribute overlay operator.\\n\\n```python\\nschema Fib:\\n    n1 = n - 1\\n    n2 = n1 - 1\\n    n: int\\n    value: int\\n\\n    if n <= 1:\\n        value = [][n]  # There is a index overflow runtime error.\\n    elif n == 2:\\n        value = 1\\n    else:\\n        value = Fib {n = n1}.value + Fib {n = n2}.value\\n\\nfib8 = Fib {n = 4}.value\\n```\\n\\nAfter execution, we will receive the following error message\\n\\n```shell\\n$ kcl main.k -d\\nerror[E3M38]: EvaluationError\\nEvaluationError\\n --\x3e main.k:8\\n  |\\n8 |         value = [][n]  # There is a index overflow runtime error.\\n  |  list index out of range: 1\\n  |\\nnote: backtrace:\\n        1: __main__.Fib\\n                at main.k:8\\n        2: __main__.Fib\\n                at main.k:12\\n        3: __main__.Fib\\n                at main.k:12\\n        4: main\\n                at main.k:14\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/528) for more.\\n\\n### Bugfix\\n\\n#### Type Error in Filter Expressions\\n\\nBefore KCL v0.5.0, filter expressions returned incorrect types (should return the type of the iterator instead of the type of the iterated object). In KCL v0.5.0, we fixed similar issues.\\n\\n```python\\nschema Student:\\n    name: str\\n    grade: int\\n\\nstudents: [Student] = [\\n    {name = \\"Alice\\", grade = 85}\\n    {name = \\"Bob\\", grade = 70}\\n]\\n\\nstudentsGrade70: [Student] = filter s in students {\\n    s.grade == 70\\n}  # Previously, we received a type mismatch error here. In KCL v0.5.0, we fixed similar issues.\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/546) for more.\\n\\n#### Lambda Closure Error\\n\\nIn previous versions of KCL, for the following KCL code, there was an error where the `versions` attribute was not assigned as expected. In KCL v0.5.0, we fixed similar issues.\\n\\n```python\\nz = 1\\nadd = lambda x { lambda y { x + y + z} }  # `x` is the closure of the inner lambda.\\nres = add(1)(1)  # 3\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/548) for more.\\n\\n#### String Literal Union Type Error Containing UTF-8 Characters\\n\\nIn previous versions of KCL, using string literal union type that contains UTF-8 characters resulted in an unexpected type error. In KCL v0.5.0 version, we fixed similar issues like this.\\n\\n```python\\nmsg: \\"\u65e0\u9700\u5bb9\u707e\\" | \\"\u6807\u51c6\u578b\\" | \\"\u6d41\u6c34\u578b\\" = \\"\u6d41\u6c34\u578b\\"\\n```\\n\\nSee [here](https://github.com/kcl-lang/kcl/pull/600) for more.\\n\\n## Tools & IDE\\n\\n### KCL OpenAPI Tool\\n\\nThe kcl-openapi command-line tool supports conversion from OpenAPI Spec to KCL code. Installation can be obtained through `go install` or `curl`:\\n\\n```bash\\n# go install\\ngo install kcl-lang.io/kcl-openapi@latest\\n\\n# curl install (MacOS & Linux)\\ncurl -fsSL https://kcl-lang.io/script/install-kcl-openapi.sh | /bin/bash\\n```\\n\\n#### Kubernetes KCL Package Conversion Optimization\\n\\nThe v0.5.0 version optimizes the experience of using Kubernetes KCL packages:\\n\\n- Built-in Kubernetes package: KCL provides out of the box KCL packages for Kubernetes 1.14-1.27 versions, which can be obtained through the package management tool `kpm pull k8s:<version>`.\\n- If you need to convert other Kubernetes versions of the KCL model on your own, you can use the following preprocessing script to convert the `swagger.json` file downloaded from the Kubernetes repository into the KCL package. Change 1.27 of the following command to the desired Kubernetes version.\\n\\n```bash\\nversion=1.27\\nspec_path=swagger.json\\nscript_path=main.py\\nwget https://raw.githubusercontent.com/kubernetes/kubernetes/release-${version}/api/openapi-spec/swagger.json -O swagger.json\\nwget https://raw.githubusercontent.com/kcl-lang/kcl-openapi/main/scripts/preprocess/main.py -O main.py\\npython3 ${script_path} ${spec_path} --omit-status --rename=io.k8s=k8s\\nkcl-openapi generate model -f processed-${spec_path}\\n```\\n\\nThe expected execution output of the script is the corresponding version of the KCL Kubernetes model, and the generated path is `<workspace path>/models/k8s`.\\n\\n```shell\\n$ tree models/k8s\\nmodels/k8s\\n\u251c\u2500\u2500 api\\n\u2502   \u251c\u2500\u2500 admissionregistration\\n\u2502   \u2502   \u251c\u2500\u2500 v1\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 match_condition.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mutating_webhook.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mutating_webhook_configuration.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 mutating_webhook_configuration_list.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 rule_with_operations.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 service_reference.k\\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 validating_webhook.k\\n...\\n```\\n\\n#### Bugfix\\n\\n- Escape attribute names with the `-` character as `_` to comply with KCL v0.5.0 syntax, [see details](https://github.com/kcl-lang/kcl-openapi/pull/43)\\n- Automatically recognize and set import as reference aliases to avoid reference conflicts, [see details](https://github.com/kcl-lang/kcl-openapi/pull/45)\\n- Fix the issue of attribute description indentation in docstring, and automatically indent the internal line breaks of attribute descriptions. [See details](https://github.com/kcl-lang/kcl-openapi/pull/46)\\n- Fix the generated reference path to be the full reference path based on the root directory of the package, [see details](https://github.com/kcl-lang/kcl-openapi/pull/51)\\n\\n### Package Management Tool\\n\\nIn the new version of KCL v0.5.0, we have provided a new KCL package management tool, which allows users to access the KCL modules in the community with a few commands.\\n\\n#### Managing KCL Programs through the kpm Tool\\n\\nBefore using kpm, it is necessary to ensure that you are currently working in a KCL package. You can use the command kpm init to create a standard KCL package.\\n\\n```shell\\nkpm init kubernetes_demo && cd kubernetes_demo && kpm add k8s\\n```\\n\\nWrite a KCL code to import the Kubernetes models (main.k).\\n\\n```python\\nimport k8s.api.apps.v1 as apps\\n\\napps.Deployment {\\n    metadata.name = \\"nginx-deployment\\"\\n    spec = {\\n        replicas = 3\\n        selector.matchLabels.app = \\"nginx\\"\\n        template.metadata.labels = selector.matchLabels\\n        template.spec.containers = [\\n            {\\n                name = selector.matchLabels.app\\n                image = \\"nginx:1.14.2\\"\\n                ports = [\\n                    {containerPort = 80}\\n                ]\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nBy combining the `kpm run` and `kubectl` command lines, we can directly distribute resource configurations to the cluster.\\n\\n```shell\\n$ kpm run | kubectl apply -f -\\n\\ndeployment.apps/nginx-deployment configured\\n```\\n\\n#### OCI Registry\\n\\nThe kpm tool supports pushing KCL packages through OCI Registry. The default OCI Registry currently provided by kpm is [https://github.com/orgs/kcl-lang/packages](https://github.com/orgs/kcl-lang/packages).\\n\\nYou can browse the KCL package you need here. We currently provide the KCL package for k8s, which supports all versions of k8s from 1.14 to 1.27. Welcome to open [Issues](https://github.com/kcl-lang/kpm/issues) to co build KCL models.\\n\\nSee [here](https://kcl-lang.io/docs/user_docs/guides/package-management/overview) for more information about the **kpm** tool.\\n\\n## Integrations\\n\\n### CI Integrations\\n\\nIn the new version of KCL, we have provided an example scheme of **Github Actions as the CI integration**. We hope to implement the end-to-end application development process by using containers, Continuous Integration (CI) for configuration generation, and GitOps for Continuous Deployment (CD). The overall workflow is as follows:\\n\\n- Develop application code and submit it to the GitHub repository to trigger CI (using Python Flask web application as an example).\\n\\n![app](/img/blog/2023-07-14-kcl-0.5.0-release/app.png)\\n\\n- GitHub Actions generate container images from application code and push them to the `docker.io` container registry.\\n\\n![app-ci](/img/blog/2023-07-14-kcl-0.5.0-release/app-ci.png)\\n\\n- GitHub Actions automatically synchronizes and updates the KCL manifest deployment file based on the version of the container image in the docker.io container registry.\\n\\n![auto-update](/img/blog/2023-07-14-kcl-0.5.0-release/auto-update.png)\\n\\nWe can obtain the deployment manifest source code for compilation and verification, and the following YAML output will be obtained\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: flask_demo\\n  template:\\n    metadata:\\n      labels:\\n        app: flask_demo\\n    spec:\\n      containers:\\n        - name: flask_demo\\n          image: \\"kcllang/flask_demo:6428cff4309afc8c1c40ad180bb9cfd82546be3e\\"\\n          ports:\\n            - protocol: TCP\\n              containerPort: 5000\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: flask_demo\\n  labels:\\n    app: flask_demo\\nspec:\\n  type: NodePort\\n  selector:\\n    app: flask_demo\\n  ports:\\n    - port: 5000\\n      protocol: TCP\\n      targetPort: 5000\\n```\\n\\nFrom the above configuration, it can be seen that the image of the resource is indeed automatically updated to the newly constructed image content. In addition, we can also use the Argo CD KCL plugin to automatically synchronize data from the Git repository and deploy the application to the Kubernetes cluster.\\n\\nFor more details, please refer to [here](https://kcl-lang.io/docs/user_docs/guides/ci-integration/github-actions)\\n\\n### CD Integrations\\n\\nIn addition, we also provide **ArgoCD as an example solution for CD integration**. Through Github Action CI integration and ArgoCD KCL plugin, we can complete end-to-end GitOps workflow, improve application configuration automatic change and deployment efficiency. The following is an overview and synchronization of Kubernetes configuration using ArgoCD application. By using ArgoCD\'s ability, when application code changes, it is automatically updated and deployed synchronously.\\n\\n- **Application Overview**\\n\\n![argocd-app](/img/blog/2023-07-14-kcl-0.5.0-release/argocd-app.png)\\n\\n- **Configuration Synchronization**\\n\\n![argocd-sync](/img/blog/2023-07-14-kcl-0.5.0-release/argocd-sync.png)\\n\\nFor more details, please refer to [here](https://kcl-lang.io/docs/user_docs/guides/gitops/gitops-quick-start)\\n\\n### Kubernetes Configuration Management Tool Plugin\\n\\nIn KCL v0.5.0, we provide KCL plugin support for configuration management tools such as Kubectl, Helm, Kustomize, and KPT in the Kubernetes community through a unified programming interface. By writing a few lines of configuration code, we can non-invasive edit and validate existing Kustomize YAML and Helm Charts, such as modifying resource labels/annotations, injecting sidecar containers, and validate resources using KCL schema, defining your own abstract models and share them, etc.\\n\\nBelow is a detailed explanation of the integration of Kubectl tool with KCL as an example. You can click [here](https://github.com/kcl-lang/kubectl-kcl) to obtain the installation of Kubectl KCL plugin.\\n\\nFirst, execute the following command to obtain a configuration example\\n\\n```shell\\ngit clone https://github.com/kcl-lang/kubectl-kcl.git && cd ./kubectl-kcl/examples/\\n```\\n\\nThen execute the following command to show the configuration\\n\\n```shell\\n$ cat krm-kcl-abstration.yaml\\napiVersion: krm.kcl.dev/v1alpha1\\nkind: KCLRun\\nmetadata:\\n  name: web-service-abtraction\\nspec:\\n  params:\\n    name: app\\n    containers:\\n      nginx:\\n        image: nginx\\n        ports:\\n        - containerPort: 80\\n    service:\\n      ports:\\n      - port: 80\\n    labels:\\n      name: app\\n  source: oci://ghcr.io/kcl-lang/web-service\\n```\\n\\nIn the above configuration, we used a Kubernetes web service application abstract model that has been predetermined on OCI `oci://ghcr.io/kcl-lang/web-service` and configured the required configuration fields for the model through the `params` field. The original Kubernetes YAML output can be obtained and applied by executing the following command:\\n\\n```shell\\n$ kubectl kcl apply -f krm-kcl-abstration.yaml\\n\\ndeployment.apps/app created\\nservice/app created\\n```\\n\\nMore detailed introductions and use cases of Kubernetes configuration management tools can be found [here](https://github.com/kcl-lang/krm-kcl/tree/main/examples)\\n\\nAt present, the integration of Kubernetes configuration management tools supported by KCL is still in its early stages. If you have more ideas and requirements, welcome to open issues to discuss.\\n\\n## Other Updates and Bug Fixes\\n\\nSee [here](https://github.com/kcl-lang/kcl/compare/v0.4.6...v0.5.0) for more updates and bug fixes.\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, v0.4.5, v0.4.6 and v0.5.0 versions are supported.\\n\\n## Community\\n\\n- Thank @harri2012 for his first contribution to the KCL IDE plugin \ud83d\ude4c\\n- Thank @niconical for his contribution to the KCL command line basic code and CI/CD scripts \ud83d\ude4c\\n- Thank @Ekko for his contribution to the integration of KCL cloud native tools \ud83d\ude4c\\n- Congratulations to Junxing Zhu his successful selection into the GitLink Programming Summer Camp (GLCC) \\"Terraform/JsonSchema to KCL Schema\\" project \ud83c\udf89\\n- Congratulations to Yiming Ren on her successful selection of the topic \\"IDE plug-in enhancement and language server integration\\" in the summer of open source \ud83c\udf89\\n- We have relocated KCL 30+ repos as a whole to the new Github **kcl-lang** organization, keeping the project address in mind [https://github.com/kcl-lang](https://github.com/kcl-lang) \u2764\ufe0f\\n- KCL\'s joining CNCF Landscape is a small encouragement and recognition from the cloud native community. The next step is to strive to join CNCF Sandbox and make more contributions to the cloud native community \ud83d\udcaa\\n\\n## Next\\n\\nIt is expected that in September 2023, we will release **KCL v0.6.0**. The expected key evolution includes:\\n\\n- KCL language is further improved for convenience, the user interface is continuously optimized and experience is improved, user support and pain points are solved.\\n- More IDE extensions, package management tools, Kubernetes scenario integration, feature support, and user experience improvement.\\n- Provide more out-of-box KCL model support for cloud-native scenarios, mainly including containers, services, computing, storage, and networks.\\n- More CI/CD integrations such as Jenkins, Gitlab CI, FluxCD, etc.\\n- Support `helmfile` KCL plugins, directly generating, mutating, and validating Kubernetes resources through the KCL code.\\n- Support for mutating and validating YAML by running KCL code through the admission controller at the Kubernetes runtime.\\n\\nFor more details, please refer to [KCL 2023 Roadmap](https://kcl-lang.io/docs/community/release-policy/roadmap) and [KCL v0.6.0 Milestone](https://github.com/kcl-lang/kcl/milestone/6).\\n\\nIf you have more ideas and needs, welcome to open [Issues](https://github.com/kcl-lang/kcl/issues) and join our community for communication as well \ud83d\ude4c \ud83d\ude4c \ud83d\ude4c\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"/2023/07/10/kcl-LSP","metadata":{"permalink":"/blog/2023/07/10/kcl-LSP","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-10-kcl-LSP/index.md","source":"@site/blog/2023-07-10-kcl-LSP/index.md","title":"Rewrite KCL LSP in Rust","description":"The KCL v0.4.6 version has significant updates in language, toolchain, community integration and IDE extension support. In this blog, we\'ll be discussing the features of the KCL IDE extension and introducing the LSP, as well as talking about the design and implementation of the KCL LSP server and our plans and expectations for the future.","date":"2023-07-10T00:00:00.000Z","formattedDate":"July 10, 2023","tags":[],"readingTime":7.545,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"KCL v0.5.0 Release Blog","permalink":"/blog/2022-kcl-0.5.0-release-blog"},"nextItem":{"title":"KCL Introduction on WAIC 2023 Meeting","permalink":"/blog/2023-07-08-kcl-waic-meeting"}},"content":"The KCL v0.4.6 version has significant updates in language, toolchain, community integration and IDE extension support. In this blog, we\'ll be discussing the features of the KCL IDE extension and introducing the LSP, as well as talking about the design and implementation of the KCL LSP server and our plans and expectations for the future.\\n\\n## New Features\\n\\nIn this update, we have released a new KCL VSCode extension and rewritten the LSP server in Rust. We have provided common code assistance features in the IDE, such as highlight, goto definition, completion, outline, hover, diagnostics, and more.\\n\\n- **Syntax Highlight:**\\n  ![Highlight](/img/docs/tools/Ide/vs-code/Highlight.png)\\n- **Goto Definition:** Goto definition of schema, variable, schema attribute, and import pkg.\\n  ![Goto Definition](/img/docs/tools/Ide/vs-code/GotoDef.gif)\\n- **Completion:** Keywords completions and dot(`.`) completion.\\n  ![Completion](/img/docs/tools/Ide/vs-code/Completion.gif)\\n- **Outline:** Main definition(schema def) and variables in KCL file.\\n  ![Outline](/img/docs/tools/Ide/vs-code/Outline.gif)\\n- **Hover:** Identifier information (type and schema documentation).\\n  ![Hover](/img/docs/tools/Ide/vs-code/Hover.gif)\\n- **Diagnostics:** Warnings and errors in KCL file.\\n  ![Diagnostics](/img/docs/tools/Ide/vs-code/Diagnostics.gif)\\n\\nWelcome to [KCL VSCode extension](https://kcl-lang.io/docs/tools/Ide/vs-code/) to learn more. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\\n\\n## What is LSP?\\n\\nIn this update, we have implemented the above features based on LSP. LSP stands for Language Server Protocol, which is a protocol for programming language tools that was introduced by Microsoft in 2016. It is easy to understand LSP with a picture on the VSCode website.\\n\\n![LSP](/img/blog/2023-07-10-kcl-LSP/lsp.png)\\n\\nBy LSP, IDE can communicate with the language server which runs on the backend through the JSON-RPC protocol. The language server can provide capabilities such as code analysis, completion, syntax highlighting, and goto definition. Based on LSP, developers can migrate between different editors and IDEs, reducing the development of language tools from M (number of languages) \\\\* N (number of editors/IDEs) to M + N.\\n\\n## Why rewrite it in Rust\uff1f\\n\\nThe KCL compiler and other tools were originally implemented in Python, and we rewrote its compiler in Rust for performance reasons. After that, we gradually rewrote other tools of KCL, such as testing and formatting tools. In this update, we also rewrote the LSP in consideration of performance issues.\\n\\nIn the past, when the Python version LSP server was processing some complex scenarios (over 200 files), for a request of goto definition, the server-side took more than about 6 seconds from receiving the request to calculating the result and responding. It is almost unavailable. Since the implementation of the server side is mainly based on the lexical analysis and semantic analysis of the front-end and middle-end of the compiler. After we rewrite it in Rust, the performance of this part has been improved by 20 and 40 times, and the remarkable result is that the response time of the server has been greatly improved. Boost, for the same scenario, the response time is reduced to around 100 milliseconds. For some simple scenarios, the response time is only a few milliseconds, which makes the user feel indifferent.\\n\\n## Design of KCL LSP\\n\\nThe KCL LSP is designed as follows\uff1a\\n![KCL-LSP](/img/blog/2023-07-10-kcl-LSP/kcl-LSP.png)\\n\\nThe main process can be divided into several stages:\\n\\n1. Initiate a connection and set the LSP capability. In IDE, when opening a specific file (e.g., \\\\*.k for KCL), the IDE will run the local kcl_language_server binary. This binary is distributed with KCL and installed in KCL\'s bin directory. After the Server starts, it will start a standard IO Connection and wait for the initialization request sent by the IDE Client. After receiving the initialization request, the server will define the information and capabilities of the server and return it to the client to complete the initial connection of the LSP.\\n2. After the connection is established, the server will start a polling function to continuously receive LSP messages from the client, such as `Notification` (open/close/change/delete files, etc.) and `Request` (goto definition, hover, etc.), as well as messages from the server itself the Task. And uniformly encapsulated into an event (Event) and handed over to the next step for processing.\\n3. For different events, follow the steps below:\\n\\n```Rust\\n/// Handles an event from one of the many sources that the language server subscribes to.\\nfn handle_event(&mut self, event: Event) -> anyhow::Result<()> {\\n    // 1. Process the incoming event\\n    match event {\\n        Event::Task(task) => self.handle_task(task)?,\\n        Event::Lsp(msg) => match msg {\\n            lsp_server::Message::Request(req) => self.on_request(req, start_time)?,\\n            lsp_server::Message::Notification(not) => self.on_notification(not)?,\\n            _ => {}\\n        },\\n    };\\n\\n    // 2. Process changes\\n    let state_changed: bool = self.process_vfs_changes();\\n\\n    // 3. Handle Diagnostics\\n    if state_changed{\\n        let mut snapshot = self.snapshot();\\n        let task_sender = self.task_sender.clone();\\n        // Spawn the diagnostics in the threadpool\\n        self.thread_pool.execute(move || {\\n            handle_diagnostics(snapshot, task_sender)\uff1f;\\n        });\\n    }\\n\\n    Ok(())\\n}\\n```\\n\\n3.1 Task distribution: According to the task type, the Task is distributed to different sub-functions. In the sub-function, it will be further distributed to the final processing function based on the type of request or notification, such as processing file changes, processing goto definition requests, etc. These functions will analyze the semantic model (AST, symbol table, error information, etc.) compiled based on the front-end of the compiler, calculate and generate the Response (such as the target position of the goto definition request).\\n\\n3.2 Change processing: When the user modifies the code or changes the file, the corresponding Notification will be sent. In the previous step of processing, the changes are saved in the virtual file system (VFS). The server side will recompile according to the new source code and save the new semantic model for processing the next request.\\n\\n3.3 Diagnostics: the diagnostics here do not refer to LSP server, but to the grammatical and semantic errors and warnings when compiling KCL code. The IDE/editor does not have a request to get these errors, but the LSP server actively sends Diagnostics. Therefore, after the change, the error information is updated on the client side synchronously\\n\\n## Problems\\n\\n### 1. Why do we need a virtual file system?\\n\\nIn the original design, the use of a virtual file system was not considered. Each time we fetch the source code from the file system, compile and analyze it. For some \\"static\\" tasks, such as goto definition, you can save the code to the file system after changing, and then find some variables definitions. Cooperating with the automatic save of VS Code, there is no obvious gap in user experience. However, for tasks such as completion, the input of `.` on the IDE/editor will trigger a file change notification and a request for completion, but the code has not been saved in the file system. Therefore, the semantic model cannot be analyzed correctly. Therefore, we realized the virtual file system with the creation of Rust Analyzer\'s vfs and changed the compilation entry from the file path to the source code. After the client enters the code, the file change notification will first update the virtual file system, recompile the file, and then process the completion request.\\n\\n### 2. How to deal with incomplete code?\\n\\nAnother big problem we encountered was how to deal with incomplete code. Likewise, for \\"static\\" tasks, e.g., goto definition, the code can be assumed to be complete and correct. But for the request of completion, such as the following code, I hope to complete the function of the string after entering `.`.For the compilation process, the second line is an incomplete code that cannot be compiled into a normal AST tree.\\n\\n```\\ns: str = \\"hello kcl\\"\\nlen = s.\\n```\\n\\nTo this end, we have implemented a variety of syntactic and semantic error recovery in KCL compilation, ensuring that the compilation process can always produce a complete AST and symbol table. In this example, we added an empty AST node as a placeholder, so that the second line can generate a complete AST. When processing the completion request, it will complete the function name, schema attr or the schema name defined in pkg according to the type of `s` and other semantic information.\\n\\n> Rust Analyzer architecture:\\n>\\n> Architecture Invariant: parsing never fails, the parser produces (T, Vec&lt;Error&gt;) rather than Result&lt;T, Error&gt;.\\n\\n## Summary\\n\\nKCL\'s IDE extension has already implemented capabilities such as highlighting, goto definition, completion, outline, hovering, and diagnostics. These features improve the development efficiency of KCL users. However, as an IDE extension, its functionality is not complete enough. In the future, we will continue to improve its capabilities. Future work has the following aspects:\\n\\n- More capabilities: Provide more capabilities, such as code refactoring, error quick fix, code fmt, etc., to further improve capabilities and improve development efficiency\\n- More IDE Integration: At present, although KCL provides LSP, it only integrates with VS Code. In the future, KCL users will be provided with more choices based on the capabilities of LSP.\\n- Integration of AI: At present, ChatGPT is popular all over the Internet. We are also exploring the combination of AI\xd7KCL to provide a more intelligent R&D experience.\\n\\nIn summary, we will continue to improve and optimize KCL\'s IDE extension to make it more powerful and practical. Bring more convenient and efficient development experience to KCL users.\\nIf you have more ideas or needs, welcome to issue or discuss them in the KCL Github repo, and welcome to join our community for communication \ud83d\ude4c \ud83d\ude4c \ud83d\ude4c"},{"id":"2023-07-08-kcl-waic-meeting","metadata":{"permalink":"/blog/2023-07-08-kcl-waic-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-07-08-kcl-waic-meeting/index.md","source":"@site/blog/2023-07-08-kcl-waic-meeting/index.md","title":"KCL Introduction on WAIC 2023 Meeting","description":"KCL Talk Cover","date":"2023-07-08T00:00:00.000Z","formattedDate":"July 8, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-07-08-kcl-waic-meeting","title":"KCL Introduction on WAIC 2023 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"Rewrite KCL LSP in Rust","permalink":"/blog/2023/07/10/kcl-LSP"},"nextItem":{"title":"Talking about the SideCar design pattern in K8S - Part 2","permalink":"/blog/2023-06-29-k8s-sidecar-2"}},"content":"![KCL Talk Cover](/img/blog/2023-07-08-kcl-waic-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-waic2023.pdf)"},{"id":"2023-06-29-k8s-sidecar-2","metadata":{"permalink":"/blog/2023-06-29-k8s-sidecar-2","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-06-29-k8s-sidecar-2/index.md","source":"@site/blog/2023-06-29-k8s-sidecar-2/index.md","title":"Talking about the SideCar design pattern in K8S - Part 2","description":"Introduction","date":"2023-06-29T00:00:00.000Z","formattedDate":"June 29, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"k8s","permalink":"/blog/tags/k-8-s"},{"label":"SideCar","permalink":"/blog/tags/side-car"}],"readingTime":2.435,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-06-29-k8s-sidecar-2","title":"Talking about the SideCar design pattern in K8S - Part 2","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","k8s","SideCar"]},"prevItem":{"title":"KCL Introduction on WAIC 2023 Meeting","permalink":"/blog/2023-07-08-kcl-waic-meeting"},"nextItem":{"title":"Talking about the Sidecar design pattern in K8S - Part 1","permalink":"/blog/2023-06-05-k8s-sidecar-1"}},"content":"## Introduction\\n\\nIn the previous blog [Exploring the Sidecar Design Pattern in K8s - Part 1](/blog/2023-06-05-k8s-sidecar-1/), we introduced the Sidecar design pattern using layman\'s terms. In this blog, we\'ll use KCL, a modern, type-safe configuration language, to showcase the description of Pod resources. In the subsequent blogs, we\'ll use KCL to explore the practical applications of the Sidecar pattern.\\n\\n### 1. OpenAPI Definition for Pods\\n\\nLet\'s go back to the simplest example of Nginx, where the YAML file follows a similar pattern:\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n    - image: nginx\\n      name: main-container\\n      ports:\\n        - containerPort: 80\\n```\\n\\nHere, the Pod data follows the definition of the io.k8s.api.core.v1.Pod model in the Kubernetes specification. The complete OpenAPI definition can be found here. By analyzing it carefully, we can see that the apiVersion and kind information are commonly used default configurations. We need a more modern configuration language to simplify it.\\n\\n### 2. Defining Pod Resources with KCL\\n\\nKCL is a configuration policy language for the cloud-native domain. For more information, please refer to the [official website](https://kcl-lang.io/). Basic KCL configuration programs still follow the `K=V` format, which is similar to YAML. For example, we can rewrite the configuration of the Nginx container using the following KCL code:\\n\\n```python\\nimport k8s.api.core.v1 as k8core\\n\\nk8core.Pod {\\n    metadata.name = \\"web-app\\"\\n    spec.containers = [{\\n        name = \\"main-container\\"\\n        image = \\"nginx\\"\\n        ports = [{containerPort: 80}]\\n    }]\\n}\\n```\\n\\nHere, the `import` statement imports the `k8s/api/core/v1` package from the k8s package, and the `Pod` structure definition corresponds to the `Pod` model. The default values for apiVersion and kind have already been included, so we only need to add the `metadata.name` and `spec.containers` properties (KCL also provides syntax sugar for some multi-level nested properties). We can use the [kpm package management tool](https://kcl-lang.io/docs/user_docs/guides/package-management/installation/) to create a KCL program to define a Pod resource and execute the program to get the corresponding YAML:\\n\\n```shell\\n# 1. Initialize a kcl program package called hello.\\nkpm init hello\\n# 2. Edit the main.k file inside the hello package and add the KCL configuration code mentioned earlier.\\ncat <<EOF > hello/main.k\\nimport k8s.api.core.v1 as k8core\\nk8core.Pod {\\n    metadata.name = \\"web-app\\"\\n    spec.containers = [{\\n        name = \\"main-container\\"\\n        image = \\"nginx\\"\\n        ports = [{containerPort: 80}]\\n    }]\\n}\\nEOF\\n# 3. Navigate to the hello package, add the k8s dependency, and run the hello package.\\ncd hello && kpm add k8s && kpm run\\n```\\n\\nThe following YAML output can be obtained:\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n    - image: nginx\\n      name: main-container\\n      ports:\\n        - containerPort: 80\\n```\\n\\n### 3. Conclusion\\n\\nIn this blog, we briefly introduced how to use KCL to build Pod configurations for more flexible and robust configurations. In the subsequent blogs, we\'ll use KCL to extract and abstract the best Sidecar pattern practices, including using KCL to abstract the Sidecar model and using KCL to inject Sidecars into existing upstream YAML configurations."},{"id":"2023-06-05-k8s-sidecar-1","metadata":{"permalink":"/blog/2023-06-05-k8s-sidecar-1","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-06-05-k8s-sidecar-1/index.md","source":"@site/blog/2023-06-05-k8s-sidecar-1/index.md","title":"Talking about the Sidecar design pattern in K8S - Part 1","description":"Introduction","date":"2023-06-05T00:00:00.000Z","formattedDate":"June 5, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"k8s","permalink":"/blog/tags/k-8-s"},{"label":"Sidecar","permalink":"/blog/tags/sidecar"}],"readingTime":5.265,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-06-05-k8s-sidecar-1","title":"Talking about the Sidecar design pattern in K8S - Part 1","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","k8s","Sidecar"]},"prevItem":{"title":"Talking about the SideCar design pattern in K8S - Part 2","permalink":"/blog/2023-06-29-k8s-sidecar-2"},"nextItem":{"title":"Differences between KCL and Helm","permalink":"/blog/2023-05-30-vs-helm"}},"content":"## Introduction\\n\\nIn `K8S`, there is a design pattern called `Sidecar`, The `Sidecar` pattern deploys application components into a separate process or container to provide isolation and encapsulation. And it also allows applications to be composed of heterogeneous components and technologies.\\n\\nThis pattern is named `Sidecar` because it resembles a Sidecar attached to a motorcycle. The Sidecar connects to a parent application and provides support functions for the application. The Sidecar also shares the same lifecycle as the parent application, being created and retired alongside the parent. The Sidecar pattern is sometimes referred to as the sidepick pattern and is a decomposition pattern.\\n\\nThis series of articles will show the usage of the `Sidecar` pattern and how to use the `Sidecar` pattern by KCL.\\n\\n## A Cloud-Native Minimalist Web Services\\n\\nAt first, we could start a web service in our kubernetes environment. Define a pod with only one `Nginx` service and start a web service on port 80 in the `pod.yaml` file below.\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n    - image: nginx\\n      name: main-container\\n      ports:\\n        - containerPort: 80\\n```\\n\\n`Pod` is a foundational primitive in cloud native. `Pod` wraps multiple containers into a single logical unit, and the kubernetes runtime ensures that the containers in a `Pod` run on a single machine. So all containers in a `Pod` share lifecycles, disk volumes, network, etc. The `Sidecar` pattern is about adding other containers to a `Pod` to extend and augment the capabilities of the main container.\\n\\nThe `Pod` is then created via the kubectl, and then the `Pod` execution status is viewed via `kubectl get po`.\\n\\n```shell\\n$ kubectl create -f pod.yaml\\n$ kubectl get po\\nNAME READY STATUS RESTARTS AGE\\nweb-app 1/1 Running 0 45m\\n```\\n\\nYou can see that a `Pod` named `web-app` is up and running properly, containing the `Nginx` service. To configure port forwarding for external access, the port 3999 of the host corresponds to port 80 of the master container:\\n\\n```shell\\n$ kubectl port-forward web-app 3999:80\\nForwarding from 127.0.0.1:3999 ->80\\nForwarding from [::1]:3999 -> 80\\n```\\n\\nPort forwarding is a blocking procedure, keep the command line open. Then open the test page in your browser at\\n\\n![](/img/blog/2023-06-05-k8s-side-car/port-forward.png)\\n\\n## Expand the page content by Sidecar\\n\\nIn this section, we try to add the ability to customize web pages to the `Nginx` service via Sidecar without modifying the original `Nginx` container image. Before we start, remove the previously started `Pod`:\\n\\n```shell\\n$ kubectl delete po web-app\\npod \\"web-app\\" deleted\\n```\\n\\nThen add a second `Busybox` Sidecar container to the `Pod`, with the `pod.yaml` file as follows:\\n\\n```yaml\\napiVersion: v1\\nkind: Pod\\nmetadata:\\n  name: web-app\\nspec:\\n  containers:\\n  - image: nginx\\n    name: main-container\\n    ports:\\n      - containerPort: 80\\n\\n    # --- Here are the new additions ---\\n\\n    # andSidecar share file directories to be published via disk volumes\\n    volumeMounts:\\n    - name: var-logs\\n      mountPath: /usr/share/nginx/html\\n\\n  # Sidecar Container\\n  - image: busybox\\n    command: [\\"/bin/sh\\"]\\n    args: [\\"-c\\", \\"while true; do echo $(date -u) \'Hi I am from Sidecar container\' > /var/log/index.html; sleep 5;done\\"]\\n    name: Sidecar-container\\n    volumeMounts: var-logs\\n      mountPath: /var/log\\n\\n  # All containers in Pod share disk volumes\\n  volumes:\\n  - name: var-logs\\n    emptyDir: {}\\n\\n```\\n\\nThe commands executed by the `Busybox` Sidecar container correspond to the following shell scripts:\\n\\n```bash\\nwhile true; do\\n\\techo $(date -u) \'Hi I am from Sidecar container\' > /var/log/index.html;\\n\\tsleep 5;\\ndone\\n```\\n\\nThe `Busybox` has only one function: it overwrites the `/var/log/index.html` file every 5 seconds, which happens to correspond to the home page file of the Nginx service.\\n\\nThen restart the Pod and remap the local host port to the container port.\\n\\n```shell\\n$ kubectl create -f pod.yaml\\npod/web-app created\\n$ kubectl port-forward web-app 3999:80\\nForwarding from 127.0.0.1:3999 -> 80\\nForwarding from [::1]:3999 -> 80\\n```\\n\\nUpon reopening your browser you will see the following page:\\n\\n![](/img/blog/2023-06-05-k8s-side-car/port-forward-1.png)\\n\\n## How Sidecar mode works\\n\\n`Busybox` is a `Sidecar` container that produces the home page data, while `Nginx` is the main container that consumes the home page data produced by `Busybox`; the two containers share space through the var-logs disk volume.\\n\\n![](/img/blog/2023-06-05-k8s-side-car/how-sidecar-work.png)\\n\\nIn the example, `Nginx` is still the main container, and the `Sidecar` container is BusyBox. we can also add more `Sidecar` containers for network, monitoring, logging, etc.\\n\\n![](/img/blog/2023-06-05-k8s-side-car/how-sidecar-work-1.png)\\n\\n## Advantages of Sidecar\\n\\nContainers have now become a popular packaging technology, where various teams can build, publish and run programs in a unified way, and even manage various resources through containers. So a container is more like a product with its own runtime, release cycle, documentation, API, etc. A good container/product is responsible for solving only one problem, and maintaining the KISS principle allows the container itself to be extremely reusable and replaceable.\\n\\nIt is reusability that makes the modern build process more agile and efficient. But reusable containers are generally single-function, and we often need to extend the functionality of containers, as well as the need for more collaboration between containers.\\n\\nThe Sidecar can be added lots of trailers without modifying the main motorcycle, and accordingly the `Sidecar` pattern can extend and enhance the existing main container functions without modifying the main container.\\n\\nThere is a rule in object-oriented programming that \\"combination is better than inheritance, use more combination and less inheritance\\", so `Sidecar` is also a recommended pattern to use. Because of the advantages of the Sidecar pattern, it has recently been used in a lot of cloud-native scenarios. For example, it can be used to encrypt communication between Pods through a service mesh or to act as a database proxy. Sidecar containers can be used for log forwarding (e.g., `fluentd`), Service Mesh (e.g., `Istio`, `Linkerd`), proxying (e.g., `Docker Ambassador`), health checking (to check if certain components are working properly), and other auxiliary tasks (such as copying files or downloading files).\\n\\n## Summary\\n\\nIn this article, we briefly introduce and demonstrate the `Sidecar` pattern, while comparing the relationship between `Sidecar` pattern and the combinatorial programming pattern in the context of traditional object-oriented programming ideas. the advantages of the `Sidecar` pattern are not only in the harmless enhancement of the main container, but also in the more flexible ability to dynamically adjust the main container capability.\\n\\nIn later articles, we will try to simplify writing `Sidecar` configurations by modern cloud-native configuration languages such as `KCL`. Extending existing configuration based on `Sidecar` by dynamically injecting and modifying it through `KCL`."},{"id":"2023-05-30-vs-helm","metadata":{"permalink":"/blog/2023-05-30-vs-helm","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-05-30-vs-helm/index.md","source":"@site/blog/2023-05-30-vs-helm/index.md","title":"Differences between KCL and Helm","description":"Introduction","date":"2023-05-30T00:00:00.000Z","formattedDate":"May 30, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Helm","permalink":"/blog/tags/helm"}],"readingTime":8.855,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-05-30-vs-helm","title":"Differences between KCL and Helm","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Helm"]},"prevItem":{"title":"Talking about the Sidecar design pattern in K8S - Part 1","permalink":"/blog/2023-06-05-k8s-sidecar-1"},"nextItem":{"title":"Differences between KCL and Kustomize","permalink":"/blog/2023-05-20-vs-kustomize"}},"content":"## Introduction\\n\\n[Helm](https://helm.sh/) is a tool for generating deployable manifests for Kubernetes objects, which philosophically takes the task of generating the final manifests in two distinct forms. Helm is an imperative templating tool for managing Kubernetes packages called charts. Charts are a templated version of your yaml manifests with a subset of Go Templating mixed throughout, as well it is a package manager for kubernetes that can package, configure, and deploy/apply the helm charts onto kubernetes clusters.\\n\\nIn KCL, the user can directly write the configuration instead of template files with more tools and IDE plugin support that needs to be modified in the corresponding code in the corresponding place, eliminating the cost of reading basic YAML. At the same time, the user can reuse the configuration fragments by code, avoiding massive copying and pasting of YAML configuration. The information density is higher, and it is not easy to make mistakes through KCL.\\n\\nA classic example of helm chart configuration management is used to explain the differences between Helm and KCL in Kubernetes resource configuration management.\\n\\n## Helm\\n\\nHelm has the concepts of `values.yaml` and `template`. In general, the Helm chart project is generally a directory including a `Chart.yaml`.:\\n\\nWe can execute the following command line to obtain a typical Helm Chart project.\\n\\n- Create a directory named `workload-helm` to hold the chart project\\n\\n```bash\\n# Create a directory to hold the chart project\\nmkdir workload-helm\\n# Create a workload-helm/Chart.yaml\\ncat <<EOF > workload-helm/Chart.yaml\\napiVersion: v2\\nappVersion: 0.3.0\\ndescription: A helm chart to provision standard workloads.\\nname: workload\\ntype: application\\nversion: 0.3.0\\nEOF\\n# Create a workload-helm/values.yaml\\ncat <<EOF > workload-helm/values.yaml\\nservice:\\n  type: ClusterIP\\n  ports:\\n    - name: www\\n      protocol: TCP\\n      port: 80\\n      targetPort: 80\\n\\ncontainers:\\n  my-container:\\n    image:\\n      name: busybox:latest\\n    command: [\\"/bin/echo\\"]\\n    args:\\n      - \\"-c\\"\\n      - \\"Hello World!\\"\\n    resources:\\n      limits:\\n        cpu: 100m\\n        memory: 128Mi\\n      requests:\\n        cpu: 100m\\n        memory: 128Mi\\nEOF\\n```\\n\\n- Create a directory to hold templates\\n\\n```bash\\n# Create a directory to hold templates\\nmkdir workload-helm/templates\\n# Create a workload-helm/templates/helpers.tpl\\ncat <<EOF > workload-helm/templates/helpers.tpl\\n{{/*\\nExpand the name of the chart.\\n*/}}\\n{{- define \\"workload.name\\" -}}\\n{{- default .Release.Name .Values.nameOverride | trunc 63 | trimSuffix \\"-\\" }}\\n{{- end }}\\n{{/*\\nCreate a default fully qualified app name.\\nWe truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).\\nIf release name contains chart name it will be used as a full name.\\n*/}}\\n{{- define \\"workload.fullname\\" -}}\\n{{- \\\\$name := default .Chart.Name .Values.nameOverride }}\\n{{- if contains \\\\$name .Release.Name }}\\n{{- .Release.Name | trunc 63 | trimSuffix \\"-\\" }}\\n{{- else }}\\n{{- printf \\"%s-%s\\" .Release.Name \\\\$name | trunc 63 | trimSuffix \\"-\\" }}\\n{{- end }}\\n{{- end }}\\n{{/*\\nCreate chart name and version as used by the chart label.\\n*/}}\\n{{- define \\"workload.chart\\" -}}\\n{{- printf \\"%s-%s\\" .Chart.Name .Chart.Version | replace \\"+\\" \\"_\\" | trunc 63 | trimSuffix \\"-\\" }}\\n{{- end }}\\n{{/*\\nCommon labels\\n*/}}\\n{{- define \\"workload.labels\\" -}}\\nhelm.sh/chart: {{ include \\"workload.chart\\" . }}\\n{{ include \\"workload.selectorLabels\\" . }}\\n{{- if .Chart.AppVersion }}\\napp.kubernetes.io/version: {{ .Chart.AppVersion | quote }}\\n{{- end }}\\napp.kubernetes.io/managed-by: {{ .Release.Service }}\\n{{- end }}\\n{{/*\\nSelector labels\\n*/}}\\n{{- define \\"workload.selectorLabels\\" -}}\\napp.kubernetes.io/name: {{ include \\"workload.name\\" . }}\\napp.kubernetes.io/instance: {{ .Release.Name }}\\n{{- end }}\\nEOF\\ncat <<EOF > workload-helm/templates/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: {{ include \\"workload.name\\" . }}\\n  labels:\\n    {{- include \\"workload.labels\\" . | nindent 4 }}\\nspec:\\n  selector:\\n    matchLabels:\\n      {{- include \\"workload.selectorLabels\\" . | nindent 6 }}\\n  template:\\n    metadata:\\n      labels:\\n        {{- include \\"workload.selectorLabels\\" . | nindent 8 }}\\n    spec:\\n      containers:\\n        {{- range \\\\$name, \\\\$container := .Values.containers }}\\n        - name: {{ \\\\$name }}\\n          image: \\"{{ $container.image.name }}\\"\\n          {{- with \\\\$container.command }}\\n          command:\\n            {{- toYaml \\\\$container.command | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.args }}\\n          args:\\n            {{- toYaml \\\\$container.args | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.env }}\\n          env:\\n            {{- toYaml \\\\$container.env | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.volumeMounts }}\\n          volumeMounts:\\n            {{- toYaml \\\\$container.volumeMounts | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.livenessProbe }}\\n          livenessProbe:\\n            {{- toYaml \\\\$container.livenessProbe | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.readinessProbe }}\\n          readinessProbe:\\n            {{- toYaml \\\\$container.readinessProbe | nindent 12 }}\\n          {{- end }}\\n          {{- with \\\\$container.resources }}\\n          resources:\\n            {{- toYaml \\\\$container.resources | nindent 12 }}\\n          {{- end }}\\n        {{- end }}\\nEOF\\ncat <<EOF > workload-helm/templates/service.yaml\\n{{ if .Values.service }}\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: {{ include \\"workload.name\\" . }}\\n  labels:\\n    {{- include \\"workload.labels\\" . | nindent 4 }}\\nspec:\\n  type: {{ .Values.service.type }}\\n  selector:\\n    {{- include \\"workload.selectorLabels\\" . | nindent 4 }}\\n  {{- with .Values.service.ports }}\\n  ports:\\n    {{- toYaml . | nindent 4 }}\\n  {{- end }}\\n{{- end }}\\nEOF\\n```\\n\\nThus, we can get a basic Helm chart directory\\n\\n```txt\\n.\\n\u251c\u2500\u2500 Chart.yaml\\n\u251c\u2500\u2500 templates\\n\u2502   \u251c\u2500\u2500 _helpers.tpl\\n\u2502   \u251c\u2500\u2500 deployment.yaml\\n\u2502   \u2514\u2500\u2500 service.yaml\\n\u2514\u2500\u2500 values.yaml\\n```\\n\\nWe can display the real deployment configuration of through the following command.\\n\\n```bash\\nhelm template workload-helm\\n```\\n\\nThe output YAML is\\n\\n```yaml\\n---\\n# Source: workload-helm/templates/service.yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: release-name\\n  labels:\\n    helm.sh/chart: workload-0.3.0\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\n    app.kubernetes.io/version: \\"0.3.0\\"\\n    app.kubernetes.io/managed-by: Helm\\nspec:\\n  type: ClusterIP\\n  selector:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\n  ports:\\n    - name: www\\n      port: 80\\n      protocol: TCP\\n      targetPort: 80\\n---\\n# Source: workload-helm/templates/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: release-name\\n  labels:\\n    helm.sh/chart: workload-0.3.0\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\n    app.kubernetes.io/version: \\"0.3.0\\"\\n    app.kubernetes.io/managed-by: Helm\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  template:\\n    metadata:\\n      labels:\\n        app.kubernetes.io/name: release-name\\n        app.kubernetes.io/instance: release-name\\n    spec:\\n      containers:\\n        - name: my-container\\n          image: \\"busybox:latest\\"\\n          command:\\n            - /bin/echo\\n          args:\\n            - -c\\n            - Hello World!\\n          resources:\\n            limits:\\n              cpu: 100m\\n              memory: 128Mi\\n            requests:\\n              cpu: 100m\\n              memory: 128Mi\\n```\\n\\n## KCL\\n\\nIn KCL, we provide the ability similar to Helm `values.yaml` to configure dynamic parameters through configuration files `kcl.yaml`.\\n\\nWe can execute the following command line to obtain a typical KCL project with the `kcl.yaml`.\\n\\n- Create a directory named `workload-kcl` to hold the KCL project\\n\\n```bash\\n# Create a directory to hold the KCL project\\nmkdir workload-kcl\\n# Create a workload-kcl/kcl.yaml\\ncat <<EOF > workload-kcl/kcl.yaml\\nkcl_options:\\n  - key: containers\\n    value:\\n      my-container:\\n        image:\\n          name: busybox:latest\\n        command: [\\"/bin/echo\\"]\\n        args:\\n          - \\"-c\\"\\n          - \\"Hello World!\\"\\n        resources:\\n          limits:\\n            cpu: 100m\\n            memory: 128Mi\\n          requests:\\n            cpu: 100m\\n            memory: 128Mi\\n\\n  - key: service\\n    value:\\n      type: ClusterIP\\n      ports:\\n        - name: www\\n          protocol: TCP\\n          port: 80\\n          targetPort: 80\\nEOF\\n```\\n\\n- Create KCL files to hold kubernetes resources.\\n\\n```bash\\n# Create a workload-kcl/deployment.k\\ncat <<EOF > workload-kcl/deployment.k\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"release-name\\"\\n    labels = {\\n        \\"app.kubernetes.io/name\\" = \\"release-name\\"\\n        \\"app.kubernetes.io/instance\\" = \\"release-name\\"\\n    }\\n}\\nspec = {\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = n\\n            image = container.image.name\\n            command = container.command\\n            command = container.args\\n            env = container.env\\n            resources = container.resources\\n        } for n, container in option(\\"containers\\") or {}\\n    ]\\n}\\nEOF\\ncat <<EOF > workload-kcl/service.k\\napiVersion = \\"v1\\"\\nkind = \\"Service\\"\\nmetadata = {\\n    name = \\"release-name\\"\\n    labels = {\\n        \\"app.kubernetes.io/name\\" = \\"release-name\\"\\n        \\"app.kubernetes.io/instance\\" = \\"release-name\\"\\n    }\\n}\\nspec = {\\n    selector.matchLabels = metadata.labels\\n    type = option(\\"service\\", default={})?.type\\n    ports = option(\\"service\\", default={})?.ports\\n}\\nEOF\\n```\\n\\nIn the above KCL code, we declare the `apiVersion`, `kind`, `metadata`, `spec` and other attributes of Kubernetes `Deployment` and `Service` resources, and assign the corresponding contents respectively. In particular, we assign `metadata.labels` to `spec.selector.matchLabels` and `spec.template.metadata.labels`. It can be seen that the data structure defined by KCL is more compact than Helm template or YAML, and configuration reuse can be realized by defining local variables.\\n\\nIn KCL, we can dynamically receive external parameters through conditional statements and the `option` builtin function, and set different configuration values to generate resources.\\n\\nWe can get the `Deployment` and `Service` resources throw the following command:\\n\\n- `Deployment`\\n\\n```shell\\nkcl workload-kcl/deployment.k -Y workload-kcl/kcl.yaml\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: release-name\\n  labels:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  template:\\n    metadata:\\n      labels:\\n        app.kubernetes.io/name: release-name\\n        app.kubernetes.io/instance: release-name\\n    spec:\\n      containers:\\n        - name: my-container\\n          image: busybox:latest\\n          command:\\n            - -c\\n            - Hello World!\\n          resources:\\n            limits:\\n              cpu: 100m\\n              memory: 128Mi\\n            requests:\\n              cpu: 100m\\n              memory: 128Mi\\n```\\n\\n- `Service`\\n\\n```shell\\nkcl workload-kcl/service.k -Y workload-kcl/kcl.yaml\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: release-name\\n  labels:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  type: ClusterIP\\n  ports:\\n    - name: www\\n      protocol: TCP\\n      port: 80\\n      targetPort: 80\\n```\\n\\nIn addition, we can overwrite the value in the `kcl.yaml` file with the `-D` parameter, such as executing the following command.\\n\\n```shell\\nkcl workload-kcl/service.k -Y workload-kcl/kcl.yaml -D service=None\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: release-name\\n  labels:\\n    app.kubernetes.io/name: release-name\\n    app.kubernetes.io/instance: release-name\\nspec:\\n  selector:\\n    matchLabels:\\n      app.kubernetes.io/name: release-name\\n      app.kubernetes.io/instance: release-name\\n  type: null\\n  ports: null\\n```\\n\\n## Summary\\n\\nIt can be seen that, compared with Helm, KCL reduces the number of configuration files and code lines by means of code generation on the basis of configuration reuse and coverage, And like Helm, it is a pure client solution, which can move the configuration and policy verification to the left as far as possible without additional dependency or burden on the cluster, or even without a real Kubernetes cluster.\\n\\nHelm can define reusable templates in the `.tpl` file and support other templates to reference it. However, only defined templates can be reused. In a complex Helm chart project, we need to define a lot of additional basic templates. Compared with the cumbersome writing method of Helm, all contents in KCL are variables. No additional syntax is required to specify templates. Any variables can be referenced to each other.\\n\\nIn addition, there are a large number of `{{- include }}`, `nindent` and `toYaml` tag characters that have nothing to do with actual logic in Helm. You need to calculate spaces and indents at each reference. In KCL, there are fewer useless codes, and there is no need for too many `{{*}}` to mark code blocks. The information density is higher, and the indentation and space have been completely liberated.\\n\\nIn fact, KCL and Helm are not antagonistic. We can even use KCL to write HelmRelease templates and provide programmable extension capabilities for existing Helm chart to write YAML validators.\\n\\n## Future Plan\\n\\nWe also expect that KCL models and constraints can be managed as a package (this package has only KCL files). For example, the Kubernetes models and constraints can be used out of the box. Users can generate configurations or verify existing configurations, and can simply extend the models and constraints users want through KCL inheritance.\\n\\nAt this stage, you can use tools such as Git or [OCI Registry As Storage (ORAS)](https://github.com/oras-project/oras) to manage KCL configuration versions.\\n\\n## More Documents\\n\\n- KCL Github Repo: [https://github.com/kcl-lang/kcl](https://github.com/kcl-lang/kcl)\\n- KCL Website: [https://kcl-lang.io](https://kcl-lang.io)"},{"id":"2023-05-20-vs-kustomize","metadata":{"permalink":"/blog/2023-05-20-vs-kustomize","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-05-20-vs-kustomize/index.md","source":"@site/blog/2023-05-20-vs-kustomize/index.md","title":"Differences between KCL and Kustomize","description":"Introduction","date":"2023-05-20T00:00:00.000Z","formattedDate":"May 20, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Kustomize","permalink":"/blog/tags/kustomize"}],"readingTime":5.885,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-05-20-vs-kustomize","title":"Differences between KCL and Kustomize","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","Kustomize"]},"prevItem":{"title":"Differences between KCL and Helm","permalink":"/blog/2023-05-30-vs-helm"},"nextItem":{"title":"See Goodbye to Old KCL Go SDK, the New One is Out!","permalink":"/blog/2023-new-version-feature-interpretation-kclvm-go-feature-overview"}},"content":"## Introduction\\n\\n[Kustomize](https://kustomize.io/) provides a solution to customize the basic configuration and differential configuration of Kubernetes resources without templates. The configuration can be merged or overwritten through file-level YAML configuration with multiple strategies. In Kustomize, users need to know more about the content and location to be changed, For basic YAML with complex recursion too deep, it may not be easy to match Kustomize files through selectors.\\n\\nIn KCL, the user can directly write the configuration that needs to be modified in the corresponding code in the corresponding place, eliminating the cost of reading basic YAML. At the same time, the user can reuse the configuration fragments by code, avoiding massive copying and pasting of YAML configuration. The information density is higher, and it is not easy to make mistakes through KCL.\\n\\nA classic example of Kustomize multi-environment configuration management is used to explain the differences between Kustomize and KCL in Kubernetes resource configuration management.\\n\\n## Kustomize\\n\\nKustomize has the concepts of `base` and `overlay`. In general, base and overlay are general a directory including a `kustomization.yaml` file. One base directory can be used by multiple overlay directories.\\n\\nWe can execute the following command line to obtain a typical Kustomize project\\n\\n- Create a base directory and create a deployment resource\\n\\n```bash\\n# Create a directory to hold the base\\nmkdir base\\n# Create a base/deployment.yaml\\ncat <<EOF > base/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: ldap\\n  labels:\\n    app: ldap\\nspec:\\n  replicas: 1\\n  selector:\\n    matchLabels:\\n      app: ldap\\n  template:\\n    metadata:\\n      labels:\\n        app: ldap\\n    spec:\\n      containers:\\n        - name: ldap\\n          image: osixia/openldap:1.1.11\\n          args: [\\"--copy-service\\"]\\n          volumeMounts:\\n            - name: ldap-data\\n              mountPath: /var/lib/ldap\\n          ports:\\n            - containerPort: 389\\n              name: openldap\\n      volumes:\\n        - name: ldap-data\\n          emptyDir: {}\\nEOF\\n# Create a base/kustomization.yaml\\ncat <<EOF > base/kustomization.yaml\\nresources:\\n- deployment.yaml\\nEOF\\n```\\n\\n- Create a directory to hold the prod overlay configuration.\\n\\n```bash\\n# Create a directory to hold the prod overlay\\nmkdir prod\\n# Create a prod/deployment.yaml\\ncat <<EOF > prod/deployment.yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: ldap\\nspec:\\n  replicas: 6\\n  template:\\n    spec:\\n      volumes:\\n        - name: ldap-data\\n          emptyDir: null\\n          gcePersistentDisk:\\n            readOnly: true\\n            pdName: ldap-persistent-storage\\nEOF\\ncat <<EOF > prod/kustomization.yaml\\nresources:\\n  - ../base\\npatchesStrategicMerge:\\n  - deployment.yaml\\nEOF\\n```\\n\\nThus, we can get a basic Kustomize directory\\n\\n```txt\\n.\\n\u251c\u2500\u2500 base\\n\u2502   \u251c\u2500\u2500 deployment.yaml\\n\u2502   \u2514\u2500\u2500 kustomization.yaml\\n\u2514\u2500\u2500 prod\\n    \u251c\u2500\u2500 deployment.yaml\\n    \u2514\u2500\u2500 kustomization.yaml\\n```\\n\\nThe base directory stores the basic deployment configuration, and the prod environment stores the deployment configuration that needs to be overwritten. The `metadata.name` and other attributes such as `spec.template.spec.volumes[0].name` are used to indicate which resource to overwrite\\n\\nWe can display the real deployment configuration of the prod environment through the following command.\\n\\n```shell\\nkubectl kustomize ./prod\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  labels:\\n    app: ldap\\n  name: ldap\\nspec:\\n  replicas: 6\\n  selector:\\n    matchLabels:\\n      app: ldap\\n  template:\\n    metadata:\\n      labels:\\n        app: ldap\\n    spec:\\n      containers:\\n        - args:\\n            - --copy-service\\n          image: osixia/openldap:1.1.11\\n          name: ldap\\n          ports:\\n            - containerPort: 389\\n              name: openldap\\n          volumeMounts:\\n            - mountPath: /var/lib/ldap\\n              name: ldap-data\\n      volumes:\\n        - gcePersistentDisk:\\n            pdName: ldap-persistent-storage\\n            readOnly: true\\n          name: ldap-data\\n```\\n\\nWe can also directly apply the configuration to the cluster through the following command.\\n\\n```shell\\nkubectl apply -k ./prod\\n```\\n\\nThe output is\\n\\n```shell\\ndeployment.apps/ldap created\\n```\\n\\n## KCL\\n\\nWe can write the following KCL code and name it `main.k`.\\n\\n```python\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"ldap\\"\\n    labels.app = \\"ldap\\"\\n}\\nspec = {\\n    replicas = 1\\n    # When env is prod, override the `replicas` attribute with `6`\\n    if option(\\"env\\") == \\"prod\\": replicas = 6\\n    # Assign `metadata.labels` to `selector.matchLabels`\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"osixia/openldap:1.1.11\\"\\n            args = [\\"--copy-service\\"]\\n            volumeMounts = [{ name = \\"ldap-data\\", mountPath = \\"/var/lib/ldap\\" }]\\n            ports = [{ containerPort = 80, name = \\"openldap\\" }]\\n        }\\n    ]\\n    template.spec.volumes = [\\n        {\\n            name = \\"ldap-data\\"\\n            emptyDir = {}\\n            # When env is prod\\n            # override the `emptyDir` attribute with `None`\\n            # patch a `gcePersistentDisk` attribute with the value `{readOnly = True, pdName = \\"ldap-persistent-storage\\"}`\\n            if option(\\"env\\") == \\"prod\\":\\n                emptyDir = None\\n                gcePersistentDisk = {\\n                    readOnly = True\\n                    pdName = \\"ldap-persistent-storage\\"\\n                }\\n        }\\n    ]\\n}\\n```\\n\\nIn the above KCL code, we declare the `apiVersion`, `kind`, `metadata`, `spec` and other attributes of a Kubernetes `Deployment` resource, and assign the corresponding contents respectively. In particular, we assign `metadata.labels` to `spec.selector.matchLabels` and `spec.template.metadata.labels`. It can be seen that the data structure defined by KCL is more compact than Kustomize or YAML, and configuration reuse can be realized by defining local variables.\\n\\nIn KCL, we can dynamically receive external parameters through conditional statements and the `option` builtin function, and set different configuration values for different environments to generate resources. For example, for the above code, we wrote a conditional statement and entered a dynamic parameter named `env`. When `env` is `prod`, we will overwrite the `replicas` attribute from `1` to `6`, and make some adjustments to the volume configuration named `ldap-data`, such as changing the `emptyDir` attribute to `None`, and adding the configuration value of `gcePersistentDisk`.\\n\\nWe can use the following command to view diff between different environment configurations\\n\\n```bash\\ndiff \\\\\\n  <(kcl main.k) \\\\\\n  <(kcl main.k -D env=prod) |\\\\\\n  more\\n```\\n\\nThe output is\\n\\n```diff\\n8c8\\n<   replicas: 1\\n---\\n>   replicas: 6\\n30c30,33\\n<         emptyDir: {}\\n---\\n>         emptyDir: null\\n>         gcePersistentDisk:\\n>           readOnly: true\\n>           pdName: ldap-persistent-storage\\n```\\n\\nIt can be seen that the diff between the production environment configuration and the base configuration mainly lies in the attributes of `replicas`, `emptyDir` and `gcePersistentDisk`, which is consistent with the expectation.\\n\\nIn addition, we can use the `-o` parameter of the KCL command line tool to output the compiled YAML to a file and view the diff between files\\n\\n```bash\\n# Generate base deployment\\nkcl main.k -o deployment.yaml\\n# Generate prod deployment\\nkcl main.k -o prod-deployment.yaml -D env=prod\\n# Diff prod deployment and base deployment\\ndiff prod-deployment.yaml deployment.yaml\\n```\\n\\nOf course, we can also use KCL tools together with kubectl and other tools to apply the configuration of the production environment to the cluster\\n\\n```shell\\nkcl main.k -D env=prod | kubectl apply -f -\\n```\\n\\nThe output is\\n\\n```shell\\ndeployment.apps/ldap created\\n```\\n\\nFinally, check the deployment status through kubectl\\n\\n```shell\\nkubectl get deploy\\n```\\n\\nThe output is\\n\\n```shell\\nNAME   READY   UP-TO-DATE   AVAILABLE   AGE\\nldap   0/6     6            0           15s\\n```\\n\\nIt can be seen from the results of the command that it is completely consistent with the deployment experience of using Kustomize configuration and kubectl apply directly, and there are no more side effects.\\n\\n## Summary\\n\\nThis article briefly introduces the quick start of writing complex multi-environment Kubernetes configuration with KCL and the comparison of Kustomize tool for Kubernetes multi-environment configuration management.\\n\\nIt can be seen that, compared with Kustomize, KCL reduces the number of configuration files and code lines by means of code generation on the basis of configuration reuse and coverage, And like Kustomize, it is a pure client solution, which can move the configuration and policy verification to the left as far as possible without additional dependency or burden on the cluster, or even without a real Kubernetes cluster."},{"id":"2023-new-version-feature-interpretation-kclvm-go-feature-overview","metadata":{"permalink":"/blog/2023-new-version-feature-interpretation-kclvm-go-feature-overview","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-04-27-new-version-feature-interpretation-kclvm-go-feature-overview/index.md","source":"@site/blog/2023-04-27-new-version-feature-interpretation-kclvm-go-feature-overview/index.md","title":"See Goodbye to Old KCL Go SDK, the New One is Out!","description":"What is KCL","date":"2023-04-27T00:00:00.000Z","formattedDate":"April 27, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"kclvm-go","permalink":"/blog/tags/kclvm-go"}],"readingTime":3.075,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-new-version-feature-interpretation-kclvm-go-feature-overview","title":"See Goodbye to Old KCL Go SDK, the New One is Out!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["KCL","kclvm-go"]},"prevItem":{"title":"Differences between KCL and Kustomize","permalink":"/blog/2023-05-20-vs-kustomize"},"nextItem":{"title":"KCL v0.4.6 Release Blog","permalink":"/blog/2022-kcl-0.4.6-release-blog"}},"content":"## What is KCL\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\n## What is KCL Go SDK?\\n\\nkclvm is a runtime library for the KCL language that provides a programming interface for interacting with the KCL compiler. It is a client library that can be used to perform various operations on KCL source code such as execution and formatting. KCL Go SDK is a Go language wrapper for kclvm that provides an SDK for KCL language integration in cloud-native environments.\\n\\nThe current version of `KCL Go SDK` is built on top of the kclvm json2 RPC API, which means that it uses the same API as other language KCL clients to interact with KCL source code. The way it works is similar to other language KCL SDKs, but it provides a more user-friendly Go language style wrapper.\\n\\n## What problems does the new version of KCL Go SDK solve?\\n\\nKCL is closely related to the cloud-native domain as a configuration language, while on the other hand, Go has become the de facto standard programming language for cloud-native domains. In this context, the development of a Go SDK for the KCL compiler to directly interact with Go was necessary, which is the reason for the creation of `KCL Go SDK`.\\n\\nThe initial version of the KCL compiler and runtime were written in Python, and the runtime for the first version of the KCL language had a lot of room for improvement in terms of performance and security due to the performance issues and characteristics of the dynamic nature of the Python language. In light of security and efficiency considerations, later versions of the KCL compiler were written in the Rust programming language. As a result, the new version of `KCL Go SDK` is based on rust-implemented kclvm packaging, eliminating Python dependencies, simplifying installation, and optimizing the user experience.\\n\\n## How to integrate KCL with Go code?\\n\\nHere is an example of how to integrate KCL into your Go program. Using the hello.k file from the previous example, construct the following main.go code:\\n\\n```go\\npackage main\\n\\nimport (\\n\\t\\"fmt\\"\\n\\n\\tkcl \\"kcl-lang.io/kcl-go\\"\\n)\\n\\nfunc main() {\\n\\tyaml := kcl.MustRun(\\"kubernetes.k\\", kcl.WithCode(code)).GetRawYamlResult()\\n\\tfmt.Println(yaml)\\n}\\n\\nconst code = `\\napiVersion = \\"apps/v1\\"\\nkind = \\"Deployment\\"\\nmetadata = {\\n    name = \\"nginx\\"\\n    labels.app = \\"nginx\\"\\n}\\nspec = {\\n    replicas = 3\\n    selector.matchLabels = metadata.labels\\n    template.metadata.labels = metadata.labels\\n    template.spec.containers = [\\n        {\\n            name = metadata.name\\n            image = \\"${metadata.name}:1.14.2\\"\\n            ports = [{ containerPort = 80 }]\\n        }\\n    ]\\n}\\n`\\n```\\n\\n- `kcl.MustRun(\\"kubernetes.k\\", kcl.WithCode(code)).GetRawYamlResult()` runs the corresponding KCL source file\\n- `fmt.Println(yaml)` prints the result of the run\\n\\n## Conclusion\\n\\nThrough the version change, we have removed Python dependencies and switched to a more efficient Rust runtime. The article briefly demonstrates how to use the kcl-go command line tool to execute KCL source code and how to integrate KCL into your Go program.\\n\\nIn addition to compiling and running KCL source code, the KCL Go SDK provides a variety of features to facilitate KCL integration in Go, including:\\n\\n- KCL static error analysis (lint and format)\\n- KCL dependency analysis\\n- Go struct and KCL Schema mutual conversion\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [kcl-go Repo](https://github.com/kcl-lang/kcl-go)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-0.4.6-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.6-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-04-14-kcl-0.4.6-release/index.md","source":"@site/blog/2023-04-14-kcl-0.4.6-release/index.md","title":"KCL v0.4.6 Release Blog","description":"Introduction","date":"2023-04-14T00:00:00.000Z","formattedDate":"April 14, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":8.2,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.6-release-blog","title":"KCL v0.4.6 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"See Goodbye to Old KCL Go SDK, the New One is Out!","permalink":"/blog/2023-new-version-feature-interpretation-kclvm-go-feature-overview"},"nextItem":{"title":"KCL Introduction on OS2ATC 2022 Meeting","permalink":"/blog/2023-03-26-kcl-os2atc-meeting"}},"content":"\x3c!-- KCL v0.4.6 is Coming - New IDE Extension, Helm/Kustomize/KPT Integrations--\x3e\\n\\n## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.6 is now available! This release has brought three key updates to everyone: **Language**, **Tools**, and **Integrations**.\\n\\n- _Use KCL IDE extensions to improve KCL code writing experience and efficiency_\\n- _Helm/Kustomize/KPT cloud-native community tool integrations_\\n- _Improve the KCL multilingual SDK for easy application integration_\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.6) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.4.6 and recent developments in the KCL community to readers.\\n\\n## Language\\n\\n### Builtin Functions\\n\\nAdded KCL string `removeprefix` and `removesuffix` member functions to remove prefix and suffix substrings from strings\\n\\n```python\\ndata1 = \\"prefix-string\\".removeprefix(\\"prefix-\\") # \\"string\\"\\ndata2 = \\"string-suffix\\".removesuffix(\\"-suffix\\") # \\"string\\"\\n```\\n\\nSee [here](https://kcl-lang.io/docs/reference/model/builtin#string-builtin-member-functions) for more.\\n\\n### Compiler Information\\n\\nIn previous versions of KCL, running the KCL command-line tool once only displayed one error message and warning. In KCL v0.4.6, it supported the ability to display multiple errors and warnings in one compilation and improved error information to improve the efficiency of KCL code error troubleshooting, such as for the following KCL code (main.k).\\n\\n```python\\nmetadata = {\\n    labels = {key = \\"kcl\\n}\\n```\\n\\nExecute the following KCL command, then you can see the syntax errors including the unterminated string and the brace mismatch errors.\\n\\n```shell\\nkcl main.k\\n```\\n\\nThe output is\\n\\n```shell\\nerror[E1001]: InvalidSyntax\\n --\x3e main.k:2:21\\n  |\\n2 |     labels = {key = \\"kcl\\n  |                     ^ unterminated string\\n  |\\n\\nerror[E1001]: InvalidSyntax\\n --\x3e main.k:2:24\\n  |\\n2 |     labels = {key = \\"kcl\\n  |                        ^ expected \\"}\\"\\n  |\\n```\\n\\n### Top-level schema assign statement union operator\\n\\nIn previous versions of KCL, when writing the following KCL code, the two schema configurations with the same name were merged and output. In KCL v0.4.6, it was required to explicitly use the attribute merge operator instead of the attribute overlay operator.\\n\\n- Before\\n\\n```python\\nschema Config:\\n    id?: int\\n    value?: str\\n\\nconfig = Config {\\n    id = 1\\n}\\nconfig = Config {\\n    value = \\"value\\"\\n}\\n```\\n\\n- After\\n\\n```python\\nschema Config:\\n    id?: int\\n    value?: str\\n\\n# Use the union operator `:` instead of the override operator\\nconfig: Config {\\n    id = 1\\n}\\n# Use the union operator `:` instead of the override operator\\nconfig: Config {\\n    value = \\"value\\"\\n}\\n```\\n\\n### Path selector simplification\\n\\nWe use the path selector CLI parameter (-S) without filling in the package path, and can directly filter internal variables.\\n\\nFor the KCL code (main.k):\\n\\n```python\\nschema Person:\\n    name: str\\n    age: int\\n\\nperson = Person {\\n    name = \\"Alice\\"\\n    age = 18\\n}\\n```\\n\\nWe run the following command:\\n\\n```shell\\nkcl main.k -S person\\n```\\n\\nThe output is\\n\\n```yaml\\nname: Alice\\nage: 18\\n```\\n\\n### Bugfix\\n\\n#### Inline conditional configuration block syntax error\\n\\nBefore KCL v0.4.6, an unexpected syntax error will appear when writing the following KCL code. In the new version, we fixed similar issues.\\n\\n```python\\nenv = \\"prod\\"\\nconfig = {if env == \\"prod\\": labels = {\\"kubernetes.io/env\\" = env}}\\n```\\n\\n#### Schema required attribute check\\n\\nIn previous versions of KCL, for the following KCL code, there was an error where the `versions` attribute was not assigned as expected. In KCL v0.4.6, we fixed similar issues.\\n\\n```python\\nschema App:\\n    data?: [int]\\n    version: Version\\n\\nschema Version:\\n    versions: [str]\\n\\napp = App {\\n    version = Version {}\\n}\\n```\\n\\n## Tools\\n\\n### KCL VS Code Extension\\n\\nIn this version, we have released a new KCL VS Code extension and a language service server rewritten using the Rust language, which has improved performance by about 20 times compared to previous KCL IDE versions. We also support real-time display of KCL errors and warnings in the IDE, as well as new features such as KCL code completion.\\n\\n- **Real-time display of KCL errors and warnings**\\n\\n![Diagnostics](/img/docs/tools/Ide/vs-code/Diagnostics.gif)\\n\\n- **Go to Definition**\\n\\n![Goto Definition](/img/docs/tools/Ide/vs-code/GotoDef.gif)\\n\\n- **Completion**\\n\\n![Completion](/img/docs/tools/Ide/vs-code/Completion.gif)\\n\\n- **Hover**\\n\\n![Hover](/img/docs/tools/Ide/vs-code/Hover.gif)\\n\\nSee [here](https://kcl-lang.io/docs/tools/Ide/vs-code) for more.\\n\\n### Package Management Tools\\n\\nIn the new version of KCL v0.4.6, we have provided a new KCL package management tool with the alpha version, which allows users to access the KCL modules in the community with a few commands. For example, the KCL Kubernetes model can be imported through the following command.\\n\\n```shell\\nkpm init kubernetes_demo && kpm add -git https://github.com/awesome-kusion/konfig.git -tag v0.0.1\\n```\\n\\nWrite a KCL code to import the Kubernetes models (main.k).\\n\\n```python\\nimport konfig.base.pkg.kusion_kubernetes.api.apps.v1 as apps\\n\\napps.Deployment {\\n    metadata.name = \\"nginx-deployment\\"\\n    spec = {\\n        replicas = 3\\n        selector.matchLabels.app = \\"nginx\\"\\n        template.metadata.labels = selector.matchLabels\\n        template.spec.containers = [\\n            {\\n                name = selector.matchLabels.app\\n                image = \\"nginx:1.14.2\\"\\n                ports = [\\n                    {containerPort = 80}\\n                ]\\n            }\\n        ]\\n    }\\n}\\n```\\n\\nExecute the following command to run the KCL code to obtain an nginx deployment YAML output.\\n\\n```shell\\nkpm run\\n```\\n\\nThe output is\\n\\n```yaml\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n        - image: \\"nginx:1.14.2\\"\\n          name: nginx\\n          ports:\\n            - containerPort: 80\\n```\\n\\n- See [here](https://kcl-lang.io/docs/user_docs/guides/package-management/overview) for more information about the **kpm** tool.\\n- See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-konfig/overview) for more information about the **konfig** model.\\n\\n## Integrations\\n\\n### Kubernetes Tool Integrations\\n\\nIn KCL v0.4.6, we provide KCL plugin support for configuration management tools such as Helm, Kustomize, and KPT in the Kubernetes community using a unified programming interface. Writing a few lines of KCL code can non-intrusively complete the mutation and validation of existing Kustomize YAML and Helm Charts.\\n\\nFor example, writing a small amount of KCL code to modify resource labels/annotations, injecting sidecar container configuration, and using KCL schema to verify resources.\\n\\nBelow is a detailed explanation of the integration of KCL using the Kustomize tool. There is no need to install any KCL-related binaries to use the Kustomize KCL plugin, just install the Kustomize tool locally.\\n\\nFirstly, execute the following command to obtain a Kustomize YAML configuration example:\\n\\n```shell\\ngit clone https://github.com/kcl-lang/kustomize-kcl.git &&cd ./kustomize-kcl/examples/set-annotation/\\n```\\n\\nThen execute the following command using KCL code to add only one `managed-by=kustomize-kcl` annotation for all `Deployment` resources\\n\\n```shell\\nsudo kustomize fn run ./local-resource/ --as-current-user --dry-run\\n```\\n\\nThe output YAML is:\\n\\n```yaml\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: test\\n  annotations:\\n    config.kubernetes.io/path: example-use.yaml\\n    internal.config.kubernetes.io/path: example-use.yaml\\nspec:\\n  selector:\\n    app: MyApp\\n  ports:\\n    - protocol: TCP\\n      port: 80\\n      targetPort: 9376\\n---\\napiVersion: apps/v1\\nkind: Deployment\\nmetadata:\\n  name: nginx-deployment\\n  labels:\\n    app: nginx\\n  annotations:\\n    config.kubernetes.io/path: example-use.yaml\\n    internal.config.kubernetes.io/path: example-use.yaml\\n    # This annotation is added through the kcl code.\\n    managed-by: kustomize-kcl\\nspec:\\n  replicas: 3\\n  selector:\\n    matchLabels:\\n      app: nginx\\n  template:\\n    metadata:\\n      labels:\\n        app: nginx\\n    spec:\\n      containers:\\n        - name: nginx\\n          image: nginx:1.14.2\\n          ports:\\n            - containerPort: 80\\n```\\n\\nIn the YAML configuration mentioned above, we only wrote one line of KCL code to add a `managed-by=kustomize-kcl` annotation to all deployment resources.\\n\\n```python\\n[resource | {if resource.kind == \\"Deployment\\": metadata.annotations: {\\"managed-by\\" = \\"kcl\\"}} for resource in option(\\"resource_list\\").item]\\n```\\n\\nIn addition, we have provided commonly used container and service configuration mutation and validation KCL models for Kustomize/Helm/KPT tools and will continue to improve them.\\n\\n- See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/kustomize_kcl_plugin) for more information about the Kustomize KCL plugin.\\n- See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/helm_kcl_plugin) for more information about the Helm KCL Plugin.\\n- See [here](https://kcl-lang.io/docs/user_docs/guides/working-with-k8s/kpt_kcl_sdk) for more information about the KPT KCL Plugin.\\n\\n### Multilingual SDK\\n\\nIn this new version, we have released a new kclvm-go SDK that integrates KCL into your Go application and provides rich APIs for interacting with KCL. You can click [here](https://kcl-lang.io/docs/next/reference/xlang-api/go-api) for detailed API documents. In addition, we have also updated the following features and bug fixes:\\n\\n- Thank @jakezhu9 for fixing unexpected KCL formatting API unit testing errors in CI Pipeline for kclvm-go.\\n- Thank @Ekko for contributing to the bidirectional conversion support of Go struct and KCL schema. Please refer to:\\n  - [Go struct -> KCL schema](https://github.com/kcl-lang/kcl-go/blob/main/pkg/tools/gen/genkcl.go#L23)\\n  - [KCL schema -> Go struct](https://github.com/kcl-lang/kcl-go/blob/main/pkg/tools/gen/gengo.go#L23)\\n- Support for conversion from KCL schema to protobuf message, see [here](https://github.com/kcl-lang/kcl-go/blob/main/pkg/tools/gen/genpb.go#L25) for more.\\n- Support APIs for obtaining schema types and instances from the KCL code, see [here](https://kcl-lang.io/docs/reference/xlang-api/go-api#func-getschematype) for more.\\n\\n## Other updates and bug fixes\\n\\n- The KCL Python plugin function is not enabled by default. If you need to enable it, please refer to the [plugin document](https://kcl-lang.io/docs/reference/plugin/overview).\\n- KCL playground supports code-sharing capabilities, which can be accessed by visiting the [KCL website](https://kcl-lang.io/) and clicking on the playground button to experience.\\n- See [here](https://github.com/kcl-lang/kcl/milestone/3?closed=1) for more updates and bug fixes.\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, v0.4.5, and v0.4.6 versions are supported.\\n\\n## Next\\n\\nIt is expected that in the middle of 2023, we will release **KCL v0.5.0**. The expected key evolution includes:\\n\\n- More IDE extensions, package management tools, Helm/Kustomize/KPT scenario integration, feature support, and user experience improvement.\\n- Provide more out-of-box KCL model support for cloud-native scenarios, mainly including containers, services, computing, storage, and networks.\\n- Support KCL Schema to directly generate Kubernetes CRD.\\n- Support `kubectl` and `helmfile` KCL plugins, directly generating, mutating, and validating Kubernetes resources through the KCL code.\\n- Support for mutating and validating YAML by running KCL code through the admission controller at the Kubernetes runtime.\\n- More support for non-Kubernetes scenarios, such as data cleaning of AI models through the KCL schema and database schema integration support.\\n\\nFor more details, please refer to [KCL v0.5.0 Milestone](https://github.com/kcl-lang/kcl/milestone/5)\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-03-26-kcl-os2atc-meeting","metadata":{"permalink":"/blog/2023-03-26-kcl-os2atc-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-03-26-kcl-os2atc-meeting/index.md","source":"@site/blog/2023-03-26-kcl-os2atc-meeting/index.md","title":"KCL Introduction on OS2ATC 2022 Meeting","description":"KCL Talk Cover","date":"2023-03-26T00:00:00.000Z","formattedDate":"March 26, 2023","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Policy","permalink":"/blog/tags/policy"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2023-03-26-kcl-os2atc-meeting","title":"KCL Introduction on OS2ATC 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration","Policy"]},"prevItem":{"title":"KCL v0.4.6 Release Blog","permalink":"/blog/2022-kcl-0.4.6-release-blog"},"nextItem":{"title":"KCL v0.4.6-alpha.1 Release Blog","permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog"}},"content":"![KCL Talk Cover](/img/blog/2023-03-26-kcl-os2atc-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-os2atc2022.pdf)"},{"id":"2022-kcl-0.4.6-alpha.1-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-03-20-kcl-0.4.6-alpha.1-release/index.md","source":"@site/blog/2023-03-20-kcl-0.4.6-alpha.1-release/index.md","title":"KCL v0.4.6-alpha.1 Release Blog","description":"Introduction","date":"2023-03-20T00:00:00.000Z","formattedDate":"March 20, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":1.17,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.6-alpha.1-release-blog","title":"KCL v0.4.6-alpha.1 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Introduction on OS2ATC 2022 Meeting","permalink":"/blog/2023-03-26-kcl-os2atc-meeting"},"nextItem":{"title":"The new playground of the KCL programming language is coming!","permalink":"/blog/2023-kcl-playground-0.4.5-release"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.6-alpha.1 is now available!\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.6-alpha.1) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\n## Release Content\\n\\n- Lexical error recovery including numbers, literal values, parentheses, etc\\n- KCL IDE plug-in supports error and warning display, go-to-definition, and other capabilities.\\n- Some compiler error reporting improvements\\n- KCL Playground supports code sharing capabilities\\n- [KPT Tool KCL SDK](https://github.com/kcl-lang/kcl/issues/434)\\n- [Helm KCL Plugin](https://github.com/kcl-lang/kcl/issues/426)\\n\\n## Next\u200b\\n\\n- KPM package management tool release\\n- More KCL compiler syntax error recovery supports the release of new IDE plug-ins, with an expected performance improvement of 20 times\\n- KCL integration of Kubernetes tools such as Helm and KPT release\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2023-kcl-playground-0.4.5-release","metadata":{"permalink":"/blog/2023-kcl-playground-0.4.5-release","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-03-17-kcl-playground-0.4.5-release/index.md","source":"@site/blog/2023-03-17-kcl-playground-0.4.5-release/index.md","title":"The new playground of the KCL programming language is coming!","description":"Introduction","date":"2023-03-17T00:00:00.000Z","formattedDate":"March 17, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Playground","permalink":"/blog/tags/playground"}],"readingTime":0.995,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2023-kcl-playground-0.4.5-release","title":"The new playground of the KCL programming language is coming!","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL","Playground"]},"prevItem":{"title":"KCL v0.4.6-alpha.1 Release Blog","permalink":"/blog/2022-kcl-0.4.6-alpha.1-release-blog"},"nextItem":{"title":"KCL v0.4.5 Release Blog","permalink":"/blog/2022-kcl-0.4.5-release-blog"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that the new playground of KCL v0.4.5 is now available!\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the complexity of writing numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nYou can visit the [KCL website](https://kcl-lang.io/) and click the playground link and play. In this new version, we support the ability to automatically compile and run KCL code, format it, and share code. Welcome to writing and sharing KCL codes.\\n\\n![](/img/blog/2023-03-17-kcl-playground-0.4.5-release/kcl-website-playground.png)\\n\\n![](/img/blog/2023-03-17-kcl-playground-0.4.5-release/kcl-playground.png)\\n\\n## Next\u200b\\n\\nIt is expected that in the middle of April 2023, we will release a new KCL Playground including KCL version selection, reference to Github code, and other capabilities.\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-0.4.5-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.5-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2023-02-27-kcl-0.4.5-release-blog/index.md","source":"@site/blog/2023-02-27-kcl-0.4.5-release-blog/index.md","title":"KCL v0.4.5 Release Blog","description":"Introduction","date":"2023-02-27T00:00:00.000Z","formattedDate":"February 27, 2023","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":11.215,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.5-release-blog","title":"KCL v0.4.5 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"The new playground of the KCL programming language is coming!","permalink":"/blog/2023-kcl-playground-0.4.5-release"},"nextItem":{"title":"KCL Introduction on OSDT 2022 Meeting","permalink":"/blog/2022-kcl-osdt-meeting"}},"content":"## Introduction\\n\\nThe KCL team is pleased to announce that KCL v0.4.5 is now available! This release is mainly aimed at improving the convenience and stability of KCL language writing, improving error information, and supporting more platforms including Windows version and more download methods. In KCL v0.4.5, users can eliminate more configuration templates by writing fewer KCL codes. In the new version, preliminary KCL Playground support is provided, which can be used to write and run KCL code online without installation. In addition, this release also includes many compiler error information optimization and bug fixes.\\n\\nYou can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.5) or the [KCL website](https://kcl-lang.io/) to get KCL binary download link and more detailed release information.\\n\\n[KCL](https://github.com/kcl-lang/kcl) is an open-source, constraint-based record and functional language. KCL improves the writing of numerous complex configurations, such as cloud-native scenarios, through its mature programming language technology and practice. It is dedicated to building better modularity, scalability, and stability around configurations, simpler logic writing, faster automation, and great built-in or API-driven integrations.\\n\\nThis blog will introduce the content of KCL v0.4.5 and recent developments in the KCL community to readers.\\n\\n## Features\\n\\n### Language Writing Convenience Improvement\\n\\n#### Lazy Validation of Non-null Attributes in the KCL Schema\\n\\nIn previous KCL versions, we have supported the lazy evaluation and validation capabilities of schema attribute cross-reference (including inheritance) and check expressions. In this version, we have supported more schema lazy evaluation capabilities such as the schema attribute non-null lazy validation. For example, for the following KCL codes:\\n\\n```python\\nschema Spec:\\n    id: int\\n    value: str\\n\\nschema Config:\\n    name?: str\\n    spec: Spec = Spec {\\n        id = 1\\n    } # Before KCL v0.4.5, this statement will report an attribute non-null error. After v0.4.5, the schema non-null attribute lazy validation is supported\\n\\nconfig = Config {\\n    spec.value = \\"value\\"\\n}\\n```\\n\\nBefore KCL v0.4.5, directly executing the above code will throw an error that the `value` attribute of `spec` cannot be `None` at the `spec: Spec=Spec {` statement block of the `schema Config`, because only the `id` attribute of `spec` is assigned a value of `1`, and no value is assigned to the `value` attribute of `spec`.\\n\\nAfter KCL v0.4.5, we will avoid throwing this error after supporting the lazy non-null validation capability of the schema attribute. That is, when the `spec.value=\\"value\\"` and `spec.id=1` of the `config` attributes are merged, all the attributes of `config` will be checked recursively for non-null. At this time, all the values of the `spec` attribute are fully assigned (the value of the `id` attribute of `spec` is `1`, and the `value` attribute is `\\"value\\"`), the error that the required schema attribute is null will not be thrown.\\n\\nTherefore, after KCL v0.4.5 and executing the above KCL code, we will get the complete YAML output as follows:\\n\\n```yaml\\nconfig:\\n  spec:\\n    id: 1\\n    value: value\\n```\\n\\n#### Mutual Reference of Configuration Block Attributes\\n\\nIn versions before v0.4.5, KCL has not yet supported the mutual reference of attributes within the configuration block, resulting in the need to define additional configuration variables or templates for reference in some scenarios, resulting in more configuration templates and duplicate codes, such as the KCL code shown below:\\n\\n```python\\nname = \\"app-name\\"\\ndata = {\\n    name = name\\n    metadata.name = name  # `metadata.name` cannot directly reference the `name` attribute inside the `data` configuration.\\n}\\n```\\n\\nThe `metadata.name` attribute of the `data` configuration block cannot directly reference the `name` attribute inside the `data`. We need to define an additional global variable `name` for reference.\\n\\nAfter KCL v0.4.5, we support the feature of mutual reference of configuration block attributes, which can be used to eliminate more configuration templates, such as the KCL code shown below:\\n\\n```python\\ndata = {\\n    name = \\"app-name\\"\\n    metadata.name = name  # Directly reference the name attribute of the `data` configuration\\n}\\n```\\n\\nThe `metadata.name` attribute of the `data` configuration block can directly reference the `name` attribute inside the `data` without defining additional global variables.\\n\\nThe following YAML output can be obtained by executing the above KCL code:\\n\\n```yaml\\ndata:\\n  name: app-name\\n  metadata:\\n    name: app-name\\n```\\n\\nHere is a more complex example:\\n\\n```python\\nname = \\"global-name\\"\\nmetadata = {\\n    name = \\"metadata-name\\"\\n    labels = {\\n        \\"app.kubernetes.io/name\\" = name  # Directly reference `metadata.name`\\n        \\"app.kubernetes.io/instance\\" = name  # Directly reference `metadata.name`\\n    }\\n}\\ndata = {\\n    name = name  # Reference the global variable `name`\\n    metadata = metadata  # Reference global variables `metadata`\\n    spec.template.metadata.name = metadata.name  # Reference `metadata` variables inside `data`.\\n}\\n```\\n\\nThe following YAML output can be obtained by executing the above code:\\n\\n```yaml\\nname: global-name\\nmetadata:\\n  name: metadata-name\\n  labels:\\n    app.kubernetes.io/name: metadata-name\\n    app.kubernetes.io/instance: metadata-name\\ndata:\\n  name: global-name\\n  metadata:\\n    name: metadata-name\\n    labels:\\n      app.kubernetes.io/name: metadata-name\\n      app.kubernetes.io/instance: metadata-name\\n  spec:\\n    template:\\n      metadata:\\n        name: metadata-name\\n```\\n\\n> \u26a0\ufe0f Note: The current KCL version does not support the backward reference of the internal attributes of the configuration block and the direct reference of global variables by skipping the internal scope. The referenced attributes need to be written in front of the configuration reference.\\n\\n### New Language Features\\n\\n#### Index Formatting of String Format Member function\\n\\nAfter KCL v0.4.5, KCL supports the use of the index tag style format `<format_ele_index>[<index_or_key>]` in the `{}` format block for KCL variables of list and dictionary types similar to the Python language.\\n\\n- `<format_ele_index>` indicates the index that is needed to serialize list and dictionary-type elements.\\n- `<index_or_key>` indicates the list sub-element index or dictionary sub-element key value of the corresponding list and dictionary type element.\\n\\nFor example, for the following KCL code\\n\\n```python\\n# 0[0] means taking the 0th element of [\\"Hello\\", \\"World\\"]: \\"Hello\\"\\n# 0[1] means taking the 1th element of [\\"Hello\\", \\"World\\"]: \\"\\"World\\"\\nlistIndexFormat = \\"{0[0]}{0[1]}\\".format([\\"Hello\\", \\"World\\"])\\n# 0[0] means taking the 0th element of [\\"0\\", \\"1\\"]: \\"0\\"\\n# 1[Hello] means taking {\\"Hello\\": \\"World\\"} dictionary element whose key value is Hello: \\"World\\"\\ndictIndexFormat = \\"0{0[0]}, 1{0[1]}, Hello{1[Hello]}\\".format([\\"0\\", \\"1\\"], {\\"Hello\\": \\"World\\"})\\n```\\n\\nThe following YAML output can be obtained by executing the above code:\\n\\n```yaml\\nlistIndexFormat: HelloWorld\\ndictIndexFormat: \\"00, 11, HelloWorld\\"\\n```\\n\\n### KCL Playground\\n\\nIn this update, we have updated the version of the KCL playground and support the automatic compilation and formatting of KCL code. You can visit the [KCL website](https://kcl-lang.io/) and click the playground button to experience it.\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-website-playground.png)\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-playground.png)\\n\\nIn the subsequent KCL versions, we will continue to update the KCL playground to support more capabilities, such as KCL version selection and code sharing.\\n\\n### More Platforms and Download Methods for KCL\\n\\n#### Windows\\n\\nKCL Windows binary version can now be downloaded from [Github](https://github.com/kcl-lang/kcl/releases/) manually. After the download, add `{install_location}\\\\kclvm\\\\bin` to the environment variable `PATH`.\\n\\n```powershell\\n$env:PATH += \\";{install-location}\\\\kclvm\\\\bin;\\"\\n```\\n\\nIn addition, you can also install KCL through the Powershell script shown below:\\n\\n```powershell\\npowershell -Command \\"iwr -useb https://kcl-lang.io/script/install.ps1 | iex\\"\\n```\\n\\nWe will support more Windows package management download methods in the future, such as `Scoop`.\\n\\n#### More Download Methods\\n\\nIn this version update, we support more KCL download methods, including scripts, Python, Go, Homebrew, and Docker one-click installation. For more details, please refer to [KCL Download and Installation](https://kcl-lang.io/docs/user_docs/getting-started/install), we will support more KCL installation methods in the future.\\n\\n> \u26a0\ufe0f Note: For all the above operating systems and installation methods, if you want to use [KCL Python plug-in](https://kcl-lang.io/docs/reference/plugin/overview), you need to ensure that Python 3.7+ is installed and add the python3 command to your PATH environment variable.\\n\\n## Bugfix\\n\\n### The configuration merge order is incorrect when the right value of a non-configured expression exists\\n\\n```python\\nschema Resource:\\n    cpu: int\\n    memory: str\\n\\nschema Config:\\n    resource: Resource\\n\\nr = Resource {\\n    cpu = 4\\n    memory = \\"8Gi\\"\\n}\\n\\nconfig: Config {\\n    resource: Resource {\\n        cpu = 2\\n        memory = \\"4Gi\\"\\n    }\\n}\\n\\nconfig: Config {\\n    resource: r\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code (main.k) will get unexpected configuration values because the KCL compiler incorrectly optimized the following form of equivalent merge configuration blocks:\\n\\n```python3\\nconfig: Config {\\n    resource: r\\n    resource: Resource {\\n        cpu = 2\\n        memory = \\"4Gi\\"\\n    }\\n}\\n```\\n\\nAfter KCL v0.4.5, the incorrect configuration of the merge order is corrected. You can execute `main.k` and obtain the expected YAML output:\\n\\n```yaml\\nr:\\n  cpu: 4\\n  memory: 8Gi\\nconfig:\\n  resource:\\n    cpu: 4\\n    memory: 8Gi\\n```\\n\\nFor more information, see [KCL Issue #422](https://github.com/kcl-lang/kcl/issues/422).\\n\\n### Configure if expression type mismatch error optimization\\n\\n```python\\nconfig: {\\"A\\"|\\"B\\": int} = {\\n    if True:\\n        A = \\"2\\"\\n}\\n```\\n\\nBefore KCL v0.4.5, for the configuration if expression, executing the above code will get the expected configuration value, resulting in the type unsoundness problem, because the KCL compiler incorrectly checks that the value `\\"2\\"` of the `A` attribute does not match the declared type `int`. After the KCL v0.4.5, this problem has been corrected. You can execute the above code to obtain the expected type mismatch error:\\n\\n```stderr\\nKCL Compile Error[E2G22] : The type got is inconsistent with the type expected\\n---\x3e File main.k:1:1\\n1 |config: {\\"A\\"|\\"B\\": int} = {\\n 1 ^  -> got {str(A):str(2)}\\nexpect {str(A)|str(B):int}, got {str(A):str(2)}\\n```\\n\\nFor more information, see [KCL Issue #389](https://github.com/kcl-lang/kcl/issues/389).\\n\\n### Rule statement validation does not work\\n\\nIn previous KCL versions, when the following rule code is used (main.k), the constraint code of `ServiceCheckRule` will not take effect.\\n\\n```python\\nprotocol KubeResourceProtocol:\\n    svc: Service\\n\\nschema Service:\\n    name: str\\n\\nrule ServiceCheckRule for KubeResourceProtocol:\\n    svc.name != \\"name\\"\\n\\nsvc = Service {\\n    name = \\"name\\"\\n}\\n\\nServiceCheckRule {\\n    svc = svc\\n}\\n```\\n\\nAfter the improvement, we execute the above code and get an accurate validation failure error:\\n\\n```stderr\\nKCL Runtime Error[E3B17] : Schema check is failed to check condition\\n---\x3e File main.k:14\\n14 |ServiceCheckRule { -> Instance check failed\\n    ---\x3e File main.k:8\\n    8 |    svc.name != \\"name\\" -> Check failed on the condition\\nCheck failed on check conditions\\n```\\n\\n### Configuration block attribute type inference optimization\\n\\n```python\\nschema Id:\\n    id?: int = 1\\n\\nschema Config:\\n    data?: {\\"A\\"|\\"B\\": Id}\\n\\nc = Config {\\n    data = {\\n        A = Id()  # Before v0.4.5, we will get a type mismatch error here.\\n        B = Id()\\n    }\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code would result in an unexpected type mismatch, because the KCL compiler incorrectly deduced the type of the `c.data.A` attribute to the `str` type, resulting in a mismatch error with the string literal union type `\\"A\\"|\\"B\\"`. After KCL v0.4.5 was updated, this problem was corrected, and the expected YAML output could be obtained by executing the above code:\\n\\n```yaml\\nc:\\n  data:\\n    A:\\n      id: 1\\n    B:\\n      id: 1\\n```\\n\\n### Assignment statement uses schema type annotation error optimization\\n\\n```python\\nschema Foo:\\n    foo: int\\n\\nschema Bar:\\n    bar: int\\n\\nfoo: Foo = Bar {  # Before v0.4.5, we will get a runtime type mismatch error here\\n    bar: 1\\n}\\n```\\n\\nBefore KCL v0.4.5, executing the above code will result in a runtime type mismatch error. After the version is updated, this type mismatch error will be optimized to compile time, and the error will be moved to the left to find this type of error earlier.\\n\\n### Error on KCL module type with the ?. operator\\n\\n```python\\nimport math\\n\\ndata = math?.log(10)  # Before v0.4.5, we will get an unexpected \'math is not defined\' error here\\n```\\n\\nBefore KCL v0.4.5, executing the above code will result in an unexpected undefined variable error because the KCL compiler does not correctly handle the `math` module type and the `?.` operators are used in combination. After KCL v0.4.5, such issues are fixed.\\n\\n## Other Updates and Issues\\n\\nFor more updates and bug fixes, see [here](https://github.com/kcl-lang/kcl/milestone/3)\\n\\n## Documents\\n\\nThe versioning semantic option is added to the [KCL website](https://kcl-lang.io/). Currently, v0.4.3, v0.4.4, and v0.4.5 versions are supported.\\n\\n![](/img/blog/2023-02-27-kcl-0.4.5-release-blog/kcl-website-doc-version.png)\\n\\n## Community\\n\\n- Two external contributors @thinkrapido and @Rishav1707 have participated in the KCL community, thank them for their enthusiasm and active participation in contributing.\\n- Thank @Rishav1707 for establishing the Rust version of [kcl-loader-rs](https://github.com/i-think-rapido/kcl-loader-rs) sub-project based on KCL, which supports the automatic generation of Rust structure according to the schema and configuration definition in the KCL file and the deserialization function from KCL value to Rust structure value.\\n\\n## Next\\n\\nIt is expected that in the middle of April 2023, we will release **KCL v0.4.6**. The expected key evolution includes:\\n\\n- KCL language is further improved for convenience, the user interface is continuously optimized and experience is improved, user support and pain points are solved.\\n- A new version of the KCL language server and [VSCode language plug-in](https://github.com/kcl-lang/vscode-kcl), the performance is expected to increase by **20 times**, and it is expected to support core basic capabilities such as code warning and error wavy line prompt, jump, reference search, etc.\\n- Continuously improve the language ability for the pain points of Kubernetes Manifests configuration management scenarios. For example, design and provide the [Helm](https://github.com/helm/helm) KCL Schema plug-in and provide the KCL SDK for the [kpt](https://github.com/GoogleContainerTools/kpt) tool.\\n- [KCL package management tool called KPM](https://github.com/kcl-lang/kpm) release. It is expected to support Git repo code dependency configuration and update, code download, and other basic capabilities.\\n- [KCL Playground](https://github.com/kcl-lang/kcl-playground): Support code sharing and KCL version selection.\\n- [KCL Go SDK](https://github.com/kcl-lang/kcl-go): More capability support such as supporting the bidirectional conversion of the KCL schema and Go structure\\n- [KCL Python SDK](https://github.com/kcl-lang/kclvm-py): More capability support.\\n\\nFor more details, please refer to [KCL v0.4.6 Milestone](https://github.com/kcl-lang/kcl/milestone/4)\\n\\n## FAQ\\n\\nFor more information, see [KCL FAQ](https://kcl-lang.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\nThank all KCL users for their valuable feedback and suggestions during this version release. For more resources, please refer to:\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-osdt-meeting","metadata":{"permalink":"/blog/2022-kcl-osdt-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-12-10-kcl-osdt-meeting/index.md","source":"@site/blog/2022-12-10-kcl-osdt-meeting/index.md","title":"KCL Introduction on OSDT 2022 Meeting","description":"KCL Talk Cover","date":"2022-12-10T00:00:00.000Z","formattedDate":"December 10, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"},{"label":"Policy","permalink":"/blog/tags/policy"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-osdt-meeting","title":"KCL Introduction on OSDT 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration","Policy"]},"prevItem":{"title":"KCL v0.4.5 Release Blog","permalink":"/blog/2022-kcl-0.4.5-release-blog"},"nextItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"}},"content":"![KCL Talk Cover](/img/blog/2022-12-10-kcl-osdt-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-osdt2022.pdf)"},{"id":"2022-kcl-0.4.4-release-blog","metadata":{"permalink":"/blog/2022-kcl-0.4.4-release-blog","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","source":"@site/blog/2022-12-06-kcl-0.4.4-release-blog/index.md","title":"KCL v0.4.4 Release Blog","description":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest KCL Python SDK, which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the KCL release page to get more detailed release information and KCL binary download link.","date":"2022-12-06T00:00:00.000Z","formattedDate":"December 6, 2022","tags":[{"label":"Release Blog","permalink":"/blog/tags/release-blog"},{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":6.975,"hasTruncateMarker":false,"authors":[{"name":"KCL Team","title":"KCL Team"}],"frontMatter":{"slug":"2022-kcl-0.4.4-release-blog","title":"KCL v0.4.4 Release Blog","authors":{"name":"KCL Team","title":"KCL Team"},"tags":["Release Blog","KCL"]},"prevItem":{"title":"KCL Introduction on OSDT 2022 Meeting","permalink":"/blog/2022-kcl-osdt-meeting"},"nextItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"}},"content":"The KCL team is pleased to announce that v0.4.4 is now available! This release mainly adds the ability to customize YAML manifests output for KCL. Users can customize the style of YAML output by writing code and calling system functions without understanding the complex schema settings semantics. In addition, this release provides the latest [KCL Python SDK](https://github.com/kcl-lang/kclvm-py), which can be used for Python users to directly integrate KCL. At the same time, we have greatly reduced the size of the KCL installation package. The average installation package size has been reduced to one-fifth of that of the previous version. It also includes a number of compiler error message optimization and bug fix. You can visit the [KCL release page](https://github.com/kcl-lang/kcl/releases/tag/v0.4.4-alpha.2) to get more detailed release information and KCL binary download link.\\n\\n## Background\\n\\nKCL is an open-source constraint-based record and functional language. KCL improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionality.\\n\\nThis blog will introduce the recent developments of KCL community to readers.\\n\\n## Features\\n\\n### Customize YAML Manifest Output\\n\\nIn previous KCL versions, the style of YAML output is hard coded in the KCL compiler, and users can set the `__settings__` meta attribute with different values to determine the YAML output style, which brings high complexity. Therefore, in version 0.4.4, we provide a system module function for developers to easily customize the YAML output style. The signature of this function is as follows:\\n\\n```python\\nmanifests.yaml_stream(values: [any], opts: {str:} = {\\n    sort_keys = False\\n    ignore_private = True\\n    ignore_none = False\\n    sep = \\"---\\"\\n})\\n```\\n\\nThis function is used to serialize the KCL object list into YAML output with the `---` separator. It has two parameters:\\n\\n- `values` - A list of KCL objects\\n- `opts` - The YAML serialization options\\n  - `sort_keys`: Whether to sort the serialized results in the dictionary order of attribute names (the default is `False`).\\n  - `ignore_private`: Whether to ignore the attribute output whose name starts with the character `_` (the default value is `True`).\\n  - `ignore_none`: Whether to ignore the attribute with the value of\' None \'(the default value is `False`).\\n  - `sep`: Set the separator between multiple YAML documents (the default value is `\\"---\\"`).\\n\\nHere\'s an example:\\n\\n```python\\nimport manifests\\n\\nschema Deployment:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Deployment\\"\\n    metadata: {str:} = {\\n        name = \\"deploy\\"\\n    }\\n    spec: {str:} = {\\n        replica = 2\\n    }\\n\\nschema Service:\\n    apiVersion: str = \\"v1\\"\\n    kind: str = \\"Service\\"\\n    metadata: {str:} = {\\n         name = \\"svc\\"\\n    }\\n    spec: {str:} = {}\\n\\ndeployments = [Deployment {}, Deployment {}]\\nservices = [Service {}, Service {}]\\n\\nmanifests.yaml_stream(deployments + services)\\n```\\n\\nFirst, we use the `import` keyword to import the `manifests` module and define two deployment resources and two service resources. When we want to output these four resources in YAML stream format with `---` as the separator, we can put them into a KCL list and use the `manifests.yaml_stream` function pass it to the `values` parameter (if there is no special requirement, the `opts` parameter can generally use the default value). Finally, the YAML output is:\\n\\n```yaml\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Deployment\\nmetadata:\\n  name: deploy\\nspec:\\n  replica: 2\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n---\\napiVersion: v1\\nkind: Service\\nmetadata:\\n  name: svc\\n```\\n\\n> Note: The feature of schema `__settings__` meta attribute setting YAML output style can still be used in v0.4.4. We will remove this feature in KCL v0.4.6 after the next two minor versions are released.\\n\\nFor more information, see [https://github.com/kcl-lang/kcl/issues/94](https://github.com/kcl-lang/kcl/issues/94).\\n\\n### Python SDK\\n\\nIn addition to the existing [KCL Go SDK](https://github.com/kcl-lang/kcl-go), this release also adds the KCL Python SDK. Using the Python SDK requires that you have a local Python version higher than 3.7.3 and a local pip package management tool. You can use the following command to install and obtain helpful information.\\n\\n```bash\\npython3 -m pip install kclvm --user && python3 -m kclvm --help\\n```\\n\\n#### Command Line Tool\\n\\nPrepare a KCL file named `main.k`\\n\\n```python\\nname = \\"kcl\\"\\nage = 1\\n\\nschema Person:\\n    name: str = \\"kcl\\"\\n    age: int = 1\\n\\nx0 = Person {}\\nx1 = Person {\\n    age = 101\\n}\\n```\\n\\nExecute the following command and get the output:\\n\\n```shell\\npython3 -m kclvm hello.k\\n```\\n\\nThe expect output is\\n\\n```yaml\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\n#### API\\n\\nIn addition, we can also execute KCL files through Python code.\\n\\nPrepare a KCL file named `main.py`\\n\\n```python\\nimport kclvm.program.exec as kclvm_exec\\nimport kclvm.vm.planner as planner\\n\\nprint(planner.plan(kclvm_exec.Run([\\"hello.k\\"]).filter_by_path_selector()))\\n```\\n\\nExecute the following command and get the output:\\n\\n```shell\\npython3 main.py\\n```\\n\\nThe expect output is\\n\\n```yaml\\nname: kcl\\nage: 1\\nx0:\\n  name: kcl\\n  age: 1\\nx1:\\n  name: kcl\\n  age: 101\\n```\\n\\nYou can see that the same output can be obtained through command line tools and APIs.\\n\\nAt present, the KCL Python SDK is still in the early preview version. The KCL team will continue to update and provide more functions in the future. For more information, see [https://github.com/kcl-lang/kclvm-py](https://github.com/kcl-lang/kclvm-py)\\n\\n## Installation Size Optimization\\n\\nIn the new KCL version, we split the built-in Python 3 of KCL, reducing the average size of the KCL binary compression package from 200M to 35M. Users can download and use KCL faster, and the Python plugin becomes an option. If you want to enable the KCL Python plugin, an additional requirement is that you have Python and pip package management tools that are higher than 3.7.3. For more details, please see [https://github.com/kcl-lang/kcl-plugin](https://github.com/kcl-lang/kcl-plugin)\\n\\n## Bugfix\\n\\n### Function Call Error Information Optimization\\n\\nIn version 0.4.4, KCL optimizes the output of error messages when the number of function arguments does not match, and supports the display of function names and the number of argument mismatches\\n\\n```python\\nschema Foo[x: int]:\\n    bar?: int = x\\n\\nf = lambda x {\\n    x + 1\\n}\\n\\nfoo = Foo(1,2,3)  # Error: \\"Foo\\" takes 1 positional argument but 3 were given\\nf(1,2)  # Error: \\"f\\" takes 1 positional argument but 2 were given\\n```\\n\\nFor more information, see [https://github.com/kcl-lang/kcl/issues/299](https://github.com/kcl-lang/kcl/issues/299)\\n\\n### Formatting Error of Interpolated Three Quote String\\n\\nIn previous KCL versions, formatting the following code would incorrectly convert the three quotation marks with string interpolation into single quotation marks and cause compilation errors. In version 0.4.4, we have fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, variable \\"bar\\" will be formatted as:\\n#\\n# foo = 1\\n# bar = \\"\\n# ${foo}\\n# \\"\\nfoo = 1\\nbar = \\"\\"\\"\\n${foo}\\n\\"\\"\\"\\n```\\n\\nFor more information, see [https://github.com/kcl-lang/kcl/issues/294](https://github.com/kcl-lang/kcl/issues/294)\\n\\n### Formatting Error of Config If Block\\n\\nIn previous KCL versions, formatting the following code would lead to incorrect indent levels. In version 0.4.4, we have fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, variable \\"foo\\" will be formatted as:\\n#\\n# foo = [\\n#     if True:\\n#         {key = \\"value\\"}\\n#     {key = \\"value\\"}\\n# ]\\nfoo = [\\n    if True:\\n        {key = \\"value\\"}\\n        {key = \\"value\\"}\\n]\\n```\\n\\n### String Literal Type Check Error\\n\\nIn previous KCL versions, formatting the following code would lead to incorrect indent levels. In version 0.4.4, we have fixed the issue.\\n\\n```python\\n# Before KCL v0.4.4, we will get a unexpected type mismatch error.\\nfoo: {\\"A\\"|\\"B\\": int} = {A = 1}\\n```\\n\\n### Other Issues\\n\\nFor more issues, see [https://github.com/kcl-lang/kcl/milestone/2?closed=1](https://github.com/kcl-lang/kcl/milestone/2?closed=1)\\n\\n## Documents\\n\\n[KCL website](https://kcl-lang.github.io/) preliminary establishment and improvement of Kubernetes scenarios [related documents](https://kcl-lang.github.io/docs/user_docs/guides/working-with-k8s/).\\n\\nFor more information, see [https://kcl-lang.github.io/](https://kcl-lang.github.io/)\\n\\n## Community\\n\\nThree external contributors @my-vegetable-has-exploded, @possible-fqz, @orangebees have participated in the KCL community, thank them for their enthusiasm and active participation in contributing.\\n\\n## Next\\n\\nIt is estimated that by the end of January 2023, we will release KCL v0.4.5, and the key evolution is expected to include\\n\\n- Continuous optimization of the KCL user interface, improvement of experience and user pain points.\\n- More scenarios and ecology integration, such as Kubernetes and CI/CD Pipeline scenarios.\\n- KCL Windows version support.\\n- KCL package management tool `kpm` release.\\n- The new version of KCL playground.\\n\\nFor more information, see [KCL v0.4.5 Milestone](https://github.com/kcl-lang/kcl/milestone/3).\\n\\n## FAQ\\n\\nFor more information, see [https://kcl-lang.github.io/docs/user_docs/support/](https://kcl-lang.github.io/docs/user_docs/support/).\\n\\n## Additional Resources\\n\\n- [KCL Website](https://kcl-lang.io/)\\n- [Kusion Website](https://kusionstack.io/)\\n- [KCL Repo](https://github.com/kcl-lang/kcl)\\n- [Kusion Repo](https://github.com/KusionStack/kusion)\\n- [Konfig Repo](https://github.com/KusionStack/konfig)\\n\\nSee the [community](https://github.com/kcl-lang/community) for ways to join us. \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f"},{"id":"2022-kcl-rewrite-with-rust","metadata":{"permalink":"/blog/2022-kcl-rewrite-with-rust","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-11-29-kcl-rewrite-with-rust/index.md","source":"@site/blog/2022-11-29-kcl-rewrite-with-rust/index.md","title":"40x Faster! We rewrote our project with Rust","description":"Introduction","date":"2022-11-29T00:00:00.000Z","formattedDate":"November 29, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Rust","permalink":"/blog/tags/rust"},{"label":"Performance","permalink":"/blog/tags/performance"},{"label":"Programming Language","permalink":"/blog/tags/programming-language"},{"label":"Compiler","permalink":"/blog/tags/compiler"}],"readingTime":9.745,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-rewrite-with-rust","title":"40x Faster! We rewrote our project with Rust","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Rust","Performance","Programming Language","Compiler"]},"prevItem":{"title":"KCL v0.4.4 Release Blog","permalink":"/blog/2022-kcl-0.4.4-release-blog"},"nextItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"}},"content":"## Introduction\\n\\nRust has quietly become one of the most popular programming languages. As an popular emerging system language, Rust has many great characteristics, such as its memory security mechanism, performance close to that of C/C++, an excellent development community and helpful documentation, tool chains and IDEs. In this blog, we will introduce the process of using Rust for a rewrite and gradually implementing the production environment, as well as the reasons for choosing Rust, any issues we have encountered, and the results of the rewrite.\\n\\nThe project we are using Rust to develop is called [KCL](https://github.com/kcl-lang/kcl). KCL is an open-source, constraint-based record and functional programming language. It leverages mature programming language technology and practice to facilitate the writing of many complex configurations. KCL is designed to improve modularity, scalability, and stability around configuration, simplify logic writing, speed up automation and create a thriving extension ecosystem. To learn more about specific KCL usage scenarios, please refer to the [KCL website](https://kcl-lang.github.io/). This blog will not go into too much detail about that.\\n\\nKCL was written in Python before. After carefully evaluating the user experience, performance and stability, we decided to rewrite KCL in Rust, and the following benefits were obtained:\\n\\n- Rust\'s powerful compilation checks and error handling led to fewer bugs.\\n- There was a 66% improvement in end-to-end compilation and execution performance.\\n- The language front-end parser performance improved by up to 20 times.\\n- The language semantic analyzer performance improved by up to 40 times.\\n- The average memory usage of the language compiler during compilation was roughly half of the original Python version.\\n\\n## What problems have we encountered\\n\\nThe compiler, build system or runtime uses Rust to do similar things in technology like projects of the same type in the community [deno](https://github.com/denoland/deno), [swc](https://github.com/swc-project/swc), [turbopack](https://github.com/vercel/turbo), [rustc](https://github.com/rust-lang/rust). We used Rust to completely build the front, middle and runtime of the compiler, and achieved some results, but we did not do this about a year ago.\\n\\nA year ago, we used Python to build the entire KCL compiler implementation, which initially ran well due to Python\u2019s ease of use, rich ecosystem, and the team\'s high research and development efficiency. However, as the codebase and number of engineers grew, code maintenance became increasingly difficult. To counter this, we enforced the usage of Python type annotations and employed stricter linting tools, as well as achieving >90% code test coverage. Yet, runtime errors such as empty Python objects and missing attributes remained, and refactoring had to be done with caution.\\n\\nAs KCL users are mostly developers, any mishaps in the language or compiler internals were unacceptable, leading to a range of issues with user experience. Furthermore, programs written in Python had slow startup times, and their performance did not meet the efficiency demands of automating the online compilation and execution. Therefore, a compiler written in Python was unable to adequately meet use requirements.\\n\\nConsequently, we decided to rewrite KCL in Rust to not only improve user experience, but to also benefit from Rust\u2019s powerful compilation checks and error handling. This led to a 66% improvement in end-to-end compilation and execution performance, as well as a 20- and 40-fold improvement in the language front-end and semantic analyser performance, respectively. The average memory usage of the compiler during compilation was also roughly halved.\\n\\n## Why use Rust\\n\\nWe chose Rust for the following reasons:\\n\\n- We implemented a simple programming language stack virtual machine in Python, Go, and Rust and conducted a performance comparison, Rust was adopted under comprehensive consideration as Go and Rust had similar performance whereas Python had a large performance gap. The details of the stack virtual machine code implemented by the three languages are here: [https://github.com/Peefy/StackMachine](https://github.com/Peefy/StackMachine).\\n- Rust has been widely utilized for compilers or runtimes of programming languages, especially in front-end infrastructure projects, and is present in various fields such as infrastructure, database, search engine, network, cloud-native, UI, and embedded systems, ensuring its feasibility and stability.\\n- Considering that the subsequent project development will involve the direction of blockchain and smart contract, and a large number of blockchain and smart contract projects in the community are written by Rust.\\n- Rust provides better performance and stability, making the system easier to maintain and more robust, while allowing developers to expose C APIs through FFI for multilingual use and expansion.\\n- Rust\'s friendly support for Web Assembly (WASM) is extremely beneficial for the development of blockchain and smart contract projects.\\n\\nBased on the above reasons, we chose Rust instead of Go. In the whole rewriting process, we found that Rust\'s comprehensive quality is impressive because it not only provides high performance but also a sufficient abstraction, although there is some cost in certain language features such as lifetime. Nevertheless, its ecology is not as rich as other languages.\\n\\n## What are the difficulties in using Rust\\n\\nAlthough we decided to rewrite the entire KCL project with Rust, most team members have no experience in writing a certain project with Rust, and I has only learned [The Rust Programming Language](https://doc.rust-lang.org/book/). I vaguely remember that I gave up when I learned about intelligent pointers such as `Rc` and `RefCell`. At that time, I didn\'t expect that there would be anything similar to C++ in Rust.\\n\\nThe risk of utilizing Rust is mainly the expense of learning the language, which is evidently discussed in a multitude of Rust blogs. Seeing that the overall structure of the KCL project had not been altered considerably, and some modules\' designs and their code had been greatly improved for Rust, the entire rewrite was accomplished through a process of mastering Rust whilst practicing. When we set out to use Rust to create the whole project, time was spent on knowledge querying, compilation and debugging. As the project advanced, however, the main challenges that arose from utilizing Rust were mainly the transformation of our mindsets, as well as the efficiency of development.\\n\\n### Mental transformation\\n\\nFirst of all, the syntax and semantics of Rust well absorb and integrate the concepts related to the type system in functional programming, such as the Abstract Algebraic Type (ADT). In addition, there is no concept related to \\"inheritance\\" in Rust. If you can\'t understand it well, even ordinary structure definitions in other languages may take a lot of time in Rust. For example, the following Python code may be defined like this in Rust.\\n\\n- Python\\n\\n```python\\nfrom dataclasses import dataclass\\n\\nclass KCLObject:\\n    pass\\n\\n@dataclass\\nclass KCLIntObject(KCLObject):\\n    value: int\\n\\n@dataclass\\nclass KCLFloatObject(KCLObject):\\n    value: float\\n```\\n\\n- Rust\\n\\n```rust\\nenum KCLObject {\\n    Int(u64),\\n    Float(f64),\\n}\\n```\\n\\nOf course, more time is spent fighting against the error reports of the Rust compiler itself. The Rust compiler will often cause developers to \\"run into a wall\\", such as borrowing check errors. Especially for the KCL compiler, its core structure is the Abstract Syntax Tree (AST), which is a recursive and nested tree structure.\\n\\nIt is sometimes difficult to give consideration to the relationship between variable variability and borrowing check in Rust, Just like the scope structure `Scope` defined in KCL compiler, for scenarios with circular references, it is used to display the interdependence of data that needs to be aware of, while making extensive use of intelligent pointer structures commonly used in Rust such as `Rc`, `RefCell` and `Weak`.\\n\\n```rust\\n/// A Scope maintains a set of objects and links to its containing\\n/// (parent) and contained (children) scopes. Objects may be inserted\\n/// and looked up by name. The zero value for Scope is a ready-to-use\\n/// empty scope.\\n#[derive(Clone, Debug)]\\npub struct Scope {\\n    /// The parent scope.\\n    pub parent: Option<Weak<RefCell<Scope>>>,\\n    /// The child scope list.\\n    pub children: Vec<Rc<RefCell<Scope>>>,\\n    /// The scope object mapping with its name.\\n    pub elems: IndexMap<String, Rc<RefCell<ScopeObject>>>,\\n    /// The scope start position.\\n    pub start: Position,\\n    /// The scope end position.\\n    pub end: Position,\\n    /// The scope kind.\\n    pub kind: ScopeKind,\\n}\\n```\\n\\n### Development efficiency\\n\\nThe efficiency of utilizing Rust may appear low at first, but it will become substantially high upon gaining familiarity with it. Initially, if the team members have not been exposed to concepts such as functional programming and related coding practices, the development speed will be much slower than that of languages such as Python, Go, and Java. Nevertheless, once they become familiarized with the conventional methods and best practices of the Rust standard library, as well as the common fixes for Rust compiler errors, the development efficiency will be dramatically boosted, and they will be able to compose high-quality, safe, and efficient code naturally.\\n\\nFor instance, I ran into a Rust lifetime error in the following code. After troubleshooting for a lengthy duration, it became apparent that the lifetime inconsistency was due to neglecting to label lifetime parameters. Additionally, Rust\u2019s lifetime is combined with concepts such as type system, scope, ownership, and borrowing inspection, resulting in a higher cost and complexity of understanding, with error reporting information often not as clear-cut as type errors. The lifetime inconsistency error reporting information can sometimes be somewhat inflexible, which may lead to a costly troubleshooting procedure. Of course, efficiency will be improved with increasing familiarity with the pertinent concepts.\\n\\n```rust\\nstruct Data<\'a> {\\n    b: &\'a u8,\\n}\\n\\n// func2 omit lifecycle parameters, and func2 does not.\\n// The lifecycle of func2 will be deduced as \'_ by the Rust compiler by default,\\n// which may lead to lifetime mismatch error.\\nimpl<\'a> Data<\'a> {\\n    fn func1(&self) -> Data<\'a> {Data { b: &0 }}\\n    fn func2(&self) -> Data {Data { b: &0 }}\\n}\\n```\\n\\n## Rewrite revenue ratio using Rust\\n\\nAfter spending several months using Rust to completely rewrite and steadily deploy the KCL project into a production environment, we have looked back on the whole process and found it highly rewarding.\\n\\nFrom a technical point of view, the rewrite process not only trained us to quickly learn a new programming language and its associated knowledge, but it also enabled us to put them into practice. The whole rewrite process also made us reflect on the unrational design of the KCL compiler and modify it accordingly. For a programming language, this is a long-cycle project. We have learned that such a compiler system should be more stable, and secure, with legible code, fewer bugs, and better performance.\\n\\nAlthough not all modules achieved a 40-fold improvement in performance (due to memory deep copy operations being the main bottleneck of some modules, such as the KCL runtime), I still think it is particularly beneficial. With enough experience in Rust, mental and development efficiency are no longer limiting factors.\\n\\nOverall, although our team encountered obstacles while using Rust to rewrite the KCL project, we eventually succeeded. We have acquired invaluable knowledge and experience in the process, which will be immensely beneficial in the future.\\n\\n## Conclusion\\n\\nI personally think that the most important thing after using Rust to rewrite the project is whether I have learned a new programming language or whether Rust is very popular and we have written many fancy codes using Rust. The stability, startup-time, and automation-efficiency of the KCL compiler and language is significantly improved. Furthermore, with Rust\'s non-GC, high-performance, improved error handling, memory management, and lack of abstraction, the performance of KCL improves substantially as compared to other languages in similar fields. In short, the users of KCL are the biggest beneficiaries of the improvements made possible by Rust.\\n\\nIf you are interested in the KCL project, wish to use KCL for your personal use cases, or want to use Rust to participate in an open-source project, welcome to visit [https://github.com/kcl-lang/community](https://github.com/kcl-lang/community) to join our community to participate in discussion and co construction \ud83d\udc4f\ud83d\udc4f\ud83d\udc4f\u3002\\n\\n## Reference\\n\\n- https://github.com/kcl-lang/kcl\\n- https://github.com/Peefy/StackMachine\\n- https://doc.rust-lang.org/book/\\n- https://github.com/sunface/rust-course\\n- https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/"},{"id":"2022-kcl-setta-meeting","metadata":{"permalink":"/blog/2022-kcl-setta-meeting","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-10-27-kcl-setta-meeting/index.md","source":"@site/blog/2022-10-27-kcl-setta-meeting/index.md","title":"KCL Introduction on SETTA 2022 Meeting","description":"KCL Talk Cover","date":"2022-10-27T00:00:00.000Z","formattedDate":"October 27, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":0.025,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-setta-meeting","title":"KCL Introduction on SETTA 2022 Meeting","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"40x Faster! We rewrote our project with Rust","permalink":"/blog/2022-kcl-rewrite-with-rust"},"nextItem":{"title":"KCL papers were accepted by SETTA 2022","permalink":"/blog/2022-kcl-setta-paper"}},"content":"![KCL Talk Cover](/img/blog/2022-10-27-kcl-setta-meeting/talk-cover.jpg)\\n\\n[Download PDF](https://kcl-lang.github.io/talks/kcl-setta2022.pdf)"},{"id":"2022-kcl-setta-paper","metadata":{"permalink":"/blog/2022-kcl-setta-paper","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-10-13-kcl-setta-paper/index.md","source":"@site/blog/2022-10-13-kcl-setta-paper/index.md","title":"KCL papers were accepted by SETTA 2022","description":"Recently, the KCL paper written by the team members was accepted by SETTA 2022 International Conference.","date":"2022-10-13T00:00:00.000Z","formattedDate":"October 13, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":1.03,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-kcl-setta-paper","title":"KCL papers were accepted by SETTA 2022","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"KCL Introduction on SETTA 2022 Meeting","permalink":"/blog/2022-kcl-setta-meeting"},"nextItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"Recently, the KCL paper written by the team members was accepted by SETTA 2022 International Conference.\\n\\n![](/img/docs/events/2022/kcl_paper_setta.png)\\n\\nThe purpose of the Symposium on Dependable Software Engineering (SETTA) symposium is to bring international researchers together to exchange research results and ideas on bridging the gap between formal methods and software engineering. This is for instance reflected by the challenges in applying formal techniques and tools to engineering large-scale systems such as Cyber-Physical Systems (CPS), Internet-of-Things (IoT), Enterprise Systems, Cloud-Based Systems, and so forth.\\n\\nThe title of the paper \\"KCL: A Declarative Language for Large scale Configuration and Policy Management\\". The core contribution of this paper is to propose the KCL declarative language, development mechanism, and consistent workflow. Through the language model and constraint capabilities, we can improve the large-scale efficiency and liberate multi-team collaborative productivity of operational development and operation systematically while ensuring stability for large-scale configuration and policy management.\\n\\nIn addition, SETTA 2022 will hold an online conference from October 27 to October 28 (Beijing time), at which time the details of KCL papers will be shared and welcome to join [KCL Community](https://github.com/kcl-lang/community). For details of SETTA 2022 meeting agenda, please refer to [https://lcs.ios.ac.cn/setta2022/program.php](https://lcs.ios.ac.cn/setta2022/program.php)\\n\\nNote: KCL has been open-source in Github. Visit [https://github.com/kcl-lang/kcl](https://github.com/kcl-lang/kcl) for more information."},{"id":"2022-declarative-config-overview","metadata":{"permalink":"/blog/2022-declarative-config-overview","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2022-09-15-declarative-config-overview/index.md","source":"@site/blog/2022-09-15-declarative-config-overview/index.md","title":"The Landscape of Declarative Configuration","description":"The blog is only used to clarify the landscape of declarative configuration, KCL core concept and features, as well as the comparison with other configuration languages.","date":"2022-09-15T00:00:00.000Z","formattedDate":"September 15, 2022","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"},{"label":"Configuration","permalink":"/blog/tags/configuration"}],"readingTime":26.955,"hasTruncateMarker":false,"authors":[{"name":"Pengfei, Xu","title":"KCL Team Member"}],"frontMatter":{"slug":"2022-declarative-config-overview","title":"The Landscape of Declarative Configuration","authors":{"name":"Pengfei, Xu","title":"KCL Team Member"},"tags":["KCL","Configuration"]},"prevItem":{"title":"KCL papers were accepted by SETTA 2022","permalink":"/blog/2022-kcl-setta-paper"},"nextItem":{"title":"KCL Introduction on GIAC 2021 Meeting","permalink":"/blog/2021-kcl-intro"}},"content":"The blog is only used to clarify the landscape of declarative configuration, [KCL](https://github.com/kcl-lang/kcl) core concept and features, as well as the comparison with other configuration languages.\\n\\n## 1. The Landscape of Declarative Configuration\\n\\n### 1.1 Importance of Configuration\\n\\n- There are thousands of configuration updates every day because the software development and the configuration itself are gradually evolving, which has a high demand for large-scale efficiency.\\n  - **The configuration is updated more frequently**: The evolving business requirements, infrastructure requirements and other factors mean that the system needs to change constantly, and the configuration provides a low-cost way to change the system functions.\\n  - **The configuration scale is getting larger**: A configuration is often distributed to different cloud sites, different tenants, different environments, etc.\\n  - **Wide configuration scenarios**: Application, database, network, monitoring, etc.\\n  - **Various configuration formats**: JSON, YAML, XML, TOML, various configuration templates such as Java Velocity, Go Template, etc.\\n- The stability of the configuration is crucial. One of the main reasons for system errors is that a large number of engineers frequently update the configuration. Table 1 shows several system error events caused by configuration.\\n\\n| Time    | Event                                                                                                                         |\\n| ------- | ----------------------------------------------------------------------------------------------------------------------------- |\\n| 2021.07 | The Bilibili website in China went down because SLB Lua configuration code fell into an infinite loop with calculation errors |\\n| 2021.10 | KT Company in South Korea suffers major network interruption nationwide due to wrong routing configuration                    |\\n\\nTable 1 System error events caused by configuration.\\n\\n### 1.2 Classification of Declarative Configuration\\n\\nThe cloud-native era has brought about rapid technological development, with a large number of declarative configurations. As shown in Fig. 1, declarative configuration can be generally divided into the following ways.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/01-declarative-config.png)\\n\\nFig. 1: Classification of declarative configuration.\\n\\n#### 1.2.1 Structured K-V\\n\\nStructured K-V meets the minimum data declaration requirements (int, string, list, dict, etc.). Declarative API meets the development demands of X as Data with the rapid development and application of cloud-native technology. Machine-readable and writable, human-readable.\\n\\n- Pros.\\n  - Simple syntax, easy to write and read.\\n  - Rich multilingual APIs.\\n  - Various path tools for data query, such as XPath, JsonPath, etc.\\n- Cons.\\n  - Too much redundant information: when the configuration scale is large, it is difficult to maintain the configuration, because important configuration information is hidden in a large number of irrelevant repetitive data details.\\n  - Lack of functionality: constraint, complex logic, test, debug, abstraction, etc.\\n  - [Kustomize](https://kustomize.io/)\'s patches are basically by fixing several patch merge strategies\\n\\nRepresentative technologies of structured KV include:\\n\\n- JSON/YAML: It is very convenient for reading and automation, and has different languages API support.\\n- [Kustomize](https://kustomize.io/): It provides a solution to customize the Kubernetes resource base configuration and differential configuration without **template** and **DSL**. It does not solve the constraint problem itself, but needs to cooperate with a large number of additional tools to check constraints, such as [Kube-linter](https://github.com/stackrox/kube-linter)\u3001[Checkov](https://github.com/bridgecrewio/checkov). Fig. 2shows the typical working mode of Kustomize.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/02-kustomize.png)\\n\\nFig. 2: Typical working mode of Kustomize.\\n\\n#### 1.2.3 Templated K-V\\n\\nThe Templated KV has the capability of static configuration data and dynamic parameters, and can output different static configuration data with one template+dynamic parameters. The advantages and disadvantages are as follows:\\n\\n- Pros.\\n  - Simple configuration logic and loop support.\\n  - External dynamic parameter support.\\n- Cons.\\n  - It is easy to fall into the trap that all configurations are template parameters.\\n  - When the configuration scale becomes larger, it is difficult for developers and tools to maintain and analyze them.\\n\\nRepresentative technologies of templated KV include:\\n\\n- [Helm](https://helm.sh/): The package management tool of Kubernetes resources, which manages the configuration of Kubernetes resources through the configuration template. Fig. 3 shows a Helm Jenkins Package ConfigMap configuration template. It can be seen that these templates are very short with simple logic. A series of resource configurations suitable forKubernetes basic components are installed through package management and additional configuration parameters. Compared with the simply templatedK-V, Helm provides template storage, reference and semantic version management capabilities. Compared with Kustomize, Helm is more suitable for managing external Charts but is not good at multi-environment and multi-tenant configuration management.\\n- Other configuration templates: Java Velocity, Go Template and other text template engines are very suitable for HTML writing templates. However,when used in configuration scenarios, they are difficult for developers and tools to maintain and analyze.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/03-helm.png)\\n\\nFig. 3: Helm Jenkins Package ConfigMap configuration template.\\n\\n#### 1.2.3 Programmable K-V\\n\\n`Configuration as Code (CaC)` uses code to generate configuration, just like engineers only need to write advanced GPL code, rather than manually writing error-prone and difficult-to-understand server binary code.\\n\\n- Configuration changes are treated as seriously as code changes, and unit tests and integration tests can also be executed.\\n- Code modularization is a key reason why maintaining configuration code is easier than manually editing configuration files such as JSON/YAML.\\n\\n- Capability\\n  - Necessary programming language abilities (variable definitions, logical judgments, loops, assertions, etc.).\\n  - Necessary template capability, which supports the definition of data templates and the use of templates to obtain new configuration data.\\n  - Code modularity: structure definition and package management.\\n  - Machine-readable and writable, human-readable and writable.\\n- Pros.\\n  - Necessary programming ability.\\n  - Code modularization and abstraction.\\n  - Configuration template and override ability.\\n- Cons.\\n  - Insufficient type check.\\n  - Insufficient constraint capacity.\\n  - Many runtime errors.\\n\\nRepresentative technologies of programmable KV include:\\n\\n- [GCL](https://github.com/rix0rrr/gcl): A declarative configuration programming language implemented in Python provides the necessary language capabilities to support template abstraction. However, the compiler itself is written in Python, and the language itself is interpreted and executed. For large template instances (such as Kubernetes models), the performance is poor.\\n- [HCL](https://github.com/hashicorp/hcl): A Go implementation structured configuration language. The native syntax of HCL is inspired by libucl and nginx configurations. It is used to create a structured configuration language that is friendly to humans and machines, mainly for DevOps tools, server configurations, and resource configurations as a [Terraform language](https://www.terraform.io/language).\\n- [Jsonnet](https://github.com/google/jsonnet): A data template language implemented in C++, suitable for application and tool developers, can generate configuration data and organize, simplify and manage large configurations without side effects.\\n\\n#### 1.2.4 Typed K-V\\n\\n- Capability\\n  - Based on programmable K-V, typed K-V has more capabilities of type constraints.\\n- Pros.\\n  - The configuration merge is completely idempotent, which naturally prevents configuration conflicts.\\n  - Rich constraint syntax for writing configuration.\\n  - Abstract the type and value constraints into the same form, which is simple to write.\\n  - Configuration order independent.\\n- Cons.\\n  - The concepts of graph merging and idempotent merging are complex, and the understanding cost is high.\\n  - The mixed definition of type and value improves the degree of abstraction and the cost of understanding. All constraints are checked at runtime, and there is a performance bottleneck for the large-scale configuration code.\\n  - It is difficult to implement multi-tenant and multi-environment scenarios that want to configure coverage and modification.\\n  - For constrained scenarios with conditions, the user interface for writing hybrid definitions of definition and verification is unfriendly.\\n\\nRepresentative technologies of typed KV include:\\n\\n- [CUE](https://github.com/cue-lang/cue): The core problem CUE solves is \\"type checking\\", which is mainly used in configuration constraint verification scenarios and simple cloud native configuration scenarios.\\n\\n#### 1.2.5 Modeled K-V\\n\\n- Pros.\\n  - High-level language modeling capability as the core description\\n    - Modeling\\n    - Immutability\\n    - Constraints\\n  - High scalability through automatic merge mechanism of isolated config blocks.\\n  - Writing and testing methods like a high-level programming language.\\n  - Machine-readable and writable, human-readable and writable.\\n- Cons.\\n  - The expansion of new models and ecological construction requires certain R&D costs\\n\\nRepresentative technologies of modeled KV include:\\n\\n- [KCL](https://github.com/kcl-lang/kcl): A declarative configuration and policy programming language implemented by Rust, which improves the writing of a large number of complex configurations through mature programming language technology and practice, and is committed to building better modularity, scalability and stability around configuration, simpler logic writing, fast automation and good ecological extensionally. Fig. 4 shows a typical scenario of KCL writing application delivery configuration code.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/04-kcl-app-code.png)\\n\\nFig. 4: A typical scenario of KCL writing application delivery configuration code.\\n\\n### 1.3 Guidelines and Best Practices for Different Declarative Configurations\\n\\n- Configuration scale: For small-scale configuration scenarios, we can use YAML/JSON and other configurations, such as the simple configuration of the application itself and CI/CD configuration. In addition, for the requirements of multi-environment and multi-tenant in small-scale configuration scenarios, Kustomize\'s overlay capability can be used to implement operations such as merging and covering simple configurations.\\n\\n- The necessity of model abstraction and constraint: For large-scale configuration scenarios, especially for those with urgent needs for configuration model and O&M feature R&D and precipitation of multi-tenant and multi-environment, the K-V method of coding, typing and modeling can be used.\\n\\nIn addition, consider the use scenarios of different declarative configurations:\\n\\n- YAML is recommended if you need to write structured static K-V or use Kubernetes\' native tools.\\n- HCL is recommended if you want to use programming language convenience to remove boilerplate with good human readability, or if you are already a Terraform user.\\n- CUE is recommended if you want to use a type system to improve stability and maintain scalable configurations.\\n- KCL is recommended if you want types and modelings like a modern language, scalable configurations, in-house pure functions and rules, and production-ready performance and automation.\\n\\nDifferent from other languages of the same type in the community, KCL is a static strongly typed compilation language for application developers and adopts modern language design and technology.\\n\\n> Note that this blog will not discuss the general language used for writing configuration. The general language is usually overkill, that is, it goes far beyond the problems that need to be solved. There are various security problems in the general language, such as the ability boundary problem (starting local threads, accessing IO, network, code infinitive looping and other security risks). For example, in the music field, there are special notes to express music, which is convenient for learning and communication, It can not be expressed clearly in general language.\\n>\\n> In addition, because of its various styles of the general language, which has the cost of unified maintenance, management and automation. The general language is usually used to write the client runtime, which is a continuation of the server runtime. It is not suitable for writing configurations that are independent of the runtime, and it is compiled into binary and started from the process finally. Besides, the stability and scalability are not easy to control. However, the configuration language often be used to write data, which is combined with simple logic, and it describes the expected final result, which is then consumed by the compiler or engine.\\n\\n## 2. KCL Core Features and Use Cases\\n\\nThe core features of KCL are its **modeling** and **constraint** capabilities, and the basic functions of KCL revolve around the two core features. In addition, KCL follows the user-centric configuration concept to design its basic functions, which can be understood from two aspects:\\n\\n- **Domain model-centric configuration view**: With the rich features of KCL language and [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tools, we can directly integrate a wide range of well-designed models in the community into KCL (such as the K8s resource model). We can also design and implement our own KCL models or libraries according to different scenarios, forming a complete set of domain models for other configuration end users to use.\\n- **End user-centric configuration view**: With KCL\'s code encapsulation, abstraction and reuse capabilities, the model architecture can be further abstracted and simplified (for example, the K8s resource model is abstracted into an application-centered server model) to **minimize the end user configuration input**, simplify the user\'s configuration interface, and facilitate manual or automatic API modification.\\n\\nNo matter what configuration view is centered on, for configuration code, there are requirements for configuration data constraints, such as type constraints, required/optional constraints on configuration attributes, range constraints, and immutability constraints. This is also one of the core issues KCL is committed to solving. KCL mainly contains the core features shown in Fig. 5.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/05-kcl-core-feature.png)\\n\\nFig. 5: KCL core features.\\n\\n- **Easy-to-use**: Originated from high-level languages \u200b\u200bsuch as Python and Golang, incorporating functional language features with low side effects.\\n- **Well-designed**: Independent Spec-driven syntax, semantics, runtime and system modules design.\\n- **Quick modeling**: [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema)-centric configuration types and modular abstraction.\\n- **Rich capabilities**: Configuration with type, logic and policy based on [Config](https://kcl-lang.io/docs/reference/lang/tour#config-operations), [Schema](https://kcl-lang.io/docs/reference/lang/tour#schema), [Lambda](https://kcl-lang.io/docs/reference/lang/tour#function), [Rule](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Stability**: Configuration stability built on [static type system](https://kcl-lang.io/docs/reference/lang/tour/#type-system), [constraints](https://kcl-lang.io/docs/reference/lang/tour/#validation), and [rules](https://kcl-lang.io/docs/reference/lang/tour#rule).\\n- **Scalability**: High scalability through [automatic merge mechanism](https://kcl-lang.io/docs/reference/lang/tour/#-operators-1) of isolated config blocks.\\n- **Fast automation**: Gradient automation scheme of [CRUD APIs](https://kcl-lang.io/docs/reference/lang/tour/#kcl-cli-variable-override), [multilingual SDKs](https://kcl-lang.io/docs/reference/xlang-api/overview), [language plugin](https://github.com/kcl-lang/kcl-plugin)\\n- **High performance**: High compile time and runtime performance using Rust & C and [LLVM](https://llvm.org/), and support compilation to native code and [WASM](https://webassembly.org/).\\n- **API affinity**: Native support API ecological specifications such as [OpenAPI](https://github.com/kcl-lang/kcl-openapi), Kubernetes CRD, Kubernetes YAML spec.\\n- **Development friendly**: Friendly development experiences with rich [language tools](https://kcl-lang.io/docs/tools/cli/kcl/) (Format, Lint, Test, Vet, Doc, etc.) and [IDE plugins](https://github.com/kcl-lang/vscode-kcl).\\n- **Safety & maintainable**: Domain-oriented, no system-level functions such as native threads and IO, low noise and security risk, easy maintenance and governance.\\n- **Rich multi-language SDK**: [Go](https://kcl-lang.io/docs/reference/xlang-api/go-api), [Python](https://kcl-lang.io/docs/reference/xlang-api/python-api) and [REST APIs](https://kcl-lang.io/docs/reference/xlang-api/rest-api) meet different scenarios and application use prelude.\\n- **Production-ready**: Widely used in production practice of platform engineering and automation at Ant Group.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/06-kcl-code-design.png)\\n\\nFig. 6: KCL core design.\\n\\nFor more language design and capabilities, see [KCL Documents](https://kcl-lang.io/docs/reference/lang/tour). Although KCL is not a general language, it has corresponding application scenarios. As shown in Fig. 6, developers can write **config**, **schema**, **function** and **rule** through KCL, where config is used to define data, schema is used to describe the model definition of data, rule is used to validate data, and schema and rule can also be combined to use models and constraints that fully describe data, In addition, we can also use the lambda pure function in KCL to organize data code, encapsulate common code, and call it directly when needed.\\n\\nFor use cases, KCL can perform structured K-V data validation complex configuration model definition and abstraction, strong constraint verification to avoid configuration errors, automation integration and engineering expansion. These features and use cases are described below.\\n\\n### 2.1 Validation of Structured Data\\n\\nAs shown in Fig 7, KCL supports format validation of JSON/YAML data. As a configuration language, KCL covers almost all features of OpenAPI in terms of validation. In KCL, the configuration data can be constrained by a structure definition. At the same time, it supports user-defined constraint rules through check blocks, and writing validation expressions in the schema to verify and constrain the attributes defined in the schema. The check expression can be used to clearly and simply verify whether the input JSON/YAML meets the corresponding schema structure definition and check constraints.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/07-kcl-validation.png)\\n\\nFig. 7: Validation of structured data in KCL.\\n\\nBased on this, KCL provides the corresponding [Validation Tool](https://kcl-lang.io/docs/tools/cli/kcl/vet) to validate JSON/YAML data directly. In addition, based on this capability, we can build a K-V validation visualization product as shown in Fig. 8.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/08-kcl-validation-ui.png)\\n\\nFig. 8: A K-V validation visualization product based on KCL.\\n\\n### 2.2 Definition and Abstraction of Complex Configuration Model\\n\\nAs shown in Fig 9, with the help of the [KCL OpenAPI](https://kcl-lang.io/docs/tools/cli/openapi/) tool, we can directly integrate a wide range of well-designed models.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/09-kcl-modeling.png)\\n\\nFig. 9: General way of KCL complex configuration modeling.\\n\\nAs shown in Figure 10, [Konfig](https://github.com/KusionStack/konfig) is used to manage all KCL configuration codes, the business configuration code and basic configuration code are stored in a mono repo, which facilitates the version dependency management between codes, and the automatic system processing is relatively simple. It is sufficient to locate the directory and files of the unique code base. The codes are interconnected, managed uniformly, and easy to find, modify, and maintain. Besides, the unified CI/CD process can be used for configuration management.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/10-kcl-konfig.png)\\n\\nFig. 10: Using KCL\'s language capabilities to integrate domain models and user models.\\n\\n### 2.3 Strong Constraint to Avoid Errors\\n\\nAs shown in Fig. 11, configuration errors can be avoided through strong constraint-checking methods in KCL.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/11-kcl-constraint.png)\\n\\nFig. 11: Strong constraint checking methods in KCL.\\n\\n- The KCL language\'s type system is designed to be static. Type and value definitions are separated. Type derivation and type checking at compile time are supported. Static types can not only analyze most type errors at compile time in advance, but also reduce the performance loss of dynamic type checking at runtime. In addition, the attributes of the KCL schema are forced to be not null, which can effectively avoid configuration omissions.\\n- When KCL configurations to be exported are declared, their types and values cannot change. This static feature ensures that the configuration will not be tampered with at will.\\n- KCL supports further ensuring stability through the built-in validation rules of the structure. For example, Fig. 12 shows that the KCL code defines the constraints for `containerPort`, `services`, and `volumes` in `App`.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/12-kcl-app-schema.png)\\n\\nFig. 12: KCL code validation with constraint rules.\\n\\n### 2.4 Isolated Configuration Block Merging\\n\\nKCL provides the ability to write isolated configuration blocks and automatically merge them, and supports idempotent merge, patch merge, and other strategies. Multiple configurations in idempotent merging need to meet the exchange law, and developers need to manually handle configuration conflicts between base and different environments. The patch merging includes overlay, deletion and addition. KCL simplifies the collaborative development on the user side and reduces the coupling between configurations through multiple merging strategies.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/13-kcl-isolated-config.png)\\n\\nFig. 13: Multi-environment scenario configuration block writing.\\n\\n### 2.5 Automation\\n\\nKCL provides many automation-related capabilities, mainly including tools and multilingual APIs. Via `package_identifier : key_identifier` mode, KCL supports the indexing of any configured key value, thus completing the addition, deletion, modification and query of any key value. For example, Fig 14. shows that we can directly execute the following command to modify the image. The code diff before and after modification is also shown in Fig. 14.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/14-kcl-image-update.png)\\n\\nFig. 14: Automatic modification of application configuration image via KCL CLI/API.\\n\\nIn addition, the automation capability of KCL can be realized and integrated into CI/CD as shown in Fig. 15.\\n\\n![](/img/blog/2022-09-15-declarative-config-overview/15-kcl-automation.png)\\n\\nFig. 15: Typical KCL automation integration.\\n\\n## 3. Comparison between KCL and Other Declarative Configurations\\n\\n### 3.1 vs. JSON/YAML\\n\\nYAML/JSON configurations are suitable for small-scale configuration scenarios. For large-scale cloud native configuration scenarios that need frequent modifications, they are more suitable for KCL. The main difference involved is the difference between configuration data abstraction and deployment:\\n\\nThe advantages of using KCL for configuration are: for static data, the advantage of abstracting one layer means that the overall system has **deployment flexibility**. Different configuration environments, tenants, and runtime may have different requirements for static data, and even different organizations may have different specifications and product requirements. KCL can be used to expose the most needed and frequently modified configurations to users.\\n\\n### 3.2 vs. Kustomize\\n\\nThe core capability of Kustomize is its file-level overlay capability. However, there is a problem with multiple overlay chains, because finding the statement of a specific attribute value does not guarantee that it is the final value, because another specific value that appears elsewhere can override it. For complex scenarios, retrieval of the inheritance chain of Kustomize files is often not as convenient as retrieval of the inheritance chain of KCL code, The specified configuration file overwrite order needs to be carefully considered. In addition, Kustomize cannot solve the problems of YAML configuration writing, constraint verification, model abstraction and development, and is more suitable for simple configuration scenarios.\\n\\nIn KCL, the configuration merge operation can be fine-grained to each configuration attribute in the code, and the merge strategy can be flexibly set, not limited to the overall resource, and the dependency between configurations can be statically analyzed through the import statement of KCL.\\n\\n### 3.3 vs. HCL\\n\\n#### 3.3.1 Features\\n\\n|              | HCL                                                                                                                                                                                                                                                                                                                               | KCL                                                                                                                                                                              |\\n| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| Modeling     | The user interface is not directly perceived through the Terraform provider Schema definition. In addition, the user interface is cumbersome when writing complex object and required/optional field definitions.                                                                                                                 | Modeling through KCL schema, and achieve high model abstraction through language level engineering and some object-oriented features.                                            |\\n| Constraint   | The dynamic parameters are constrained by the condition field of the variable. The constraints of the resource itself need to be defined by provider schema or combined with Sentinel/Rego and other policy languages. The integrity of the language itself cannot be self closed, and its implementation methods are not unified | Define structures and constraints in a unified way.                                                                                                                              |\\n| Scalability  | Terraform HCL overrides by file. The mode is fixed and the capability is limited.                                                                                                                                                                                                                                                 | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios. |\\n| Code writing | The user interface is complicated when writing complex object definitions and required/optional field definitions.                                                                                                                                                                                                                | Complex structure definitions and constraint are easy to write without using other GPLs or tools.                                                                                |\\n\\n#### 3.3.2 Examples\\n\\n**Terraform HCL variable vs. KCL schema**\\n\\n- HCL\\n\\n```python\\nvariable \\"subnet_delegations\\" {\\n  type = list(object({\\n    name               = string\\n    service_delegation = object({\\n      name    = string\\n      actions = list(string)\\n    })\\n  }))\\n  default     = null\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.name : (n != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for d in var.subnet_delegations.*.service_delegation : (d != null)])\\n  }\\n  validation {\\n    condition = var.subnet_delegations == null ? true : alltrue([for n in var.subnet_delegations.*.service_delegation.name : (n != null)])\\n  }\\n}\\n```\\n\\n- KCL\\n\\n```python\\nschema SubnetDelegation:\\n    name: str\\n    service_delegation: ServiceDelegation\\n\\nschema ServiceDelegation:\\n    name: str  # Required attributes\\n    actions?: [str]  # Optional attributes\\n\\nsubnet_delegations: [SubnetDelegation] = option(\\"subnet_delegations\\")\\n```\\n\\n**Terraform HCL Function vs. KCL Lambda**\\n\\n- As shown in [https://www.terraform.io/language/functions](https://www.terraform.io/language/functions) and [https://github.com/hashicorp/terraform/issues/27696](https://github.com/hashicorp/terraform/issues/27696)\uff0cTerraform HCL provides rich built-in functions, but it does not support users to define functions in Terraform (or need to write complex Go providers to simulate local user-defined functions); KCL not only supports users to use the lambda keyword to directly define functions in KCL code, but also supports the use of Python, Go and other languages to write [plugins](https://kcl-lang.io/docs/reference/plugin/overview).\\n\\n- Defining functions and calling them in KCL\\n\\n```python\\nadd_func = lambda x: int, y: int -> int {\\n    x + y\\n}\\ntwo = add_func(1, 1)  # 2\\n```\\n\\n**Remove null values in HCL vs. Remove null values in KCL**\\n\\n- HCL\\n\\n```python\\nvariable \\"conf\\" {\\n  type = object({\\n    description = string\\n    name        = string\\n    namespace   = string\\n    params = list(object({\\n      default     = optional(string)\\n      description = string\\n      name        = string\\n      type        = string\\n    }))\\n    resources = optional(object({\\n      inputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n      outputs = optional(list(object({\\n        name = string\\n        type = string\\n      })))\\n    }))\\n    results = optional(list(object({\\n      name        = string\\n      description = string\\n    })))\\n    steps = list(object({\\n      args    = optional(list(string))\\n      command = optional(list(string))\\n      env = optional(list(object({\\n        name  = string\\n        value = string\\n      })))\\n      image = string\\n      name  = string\\n      resources = optional(object({\\n        limits = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n        requests = optional(object({\\n          cpu    = string\\n          memory = string\\n        }))\\n      }))\\n      script     = optional(string)\\n      workingDir = string\\n    }))\\n  })\\n}\\n\\nlocals {\\n  conf = merge(\\n    defaults(var.conf, {}),\\n    { for k, v in var.conf : k => v if v != null },\\n    { resources = { for k, v in var.conf.resources : k => v if v != null } },\\n    { steps = [for step in var.conf.steps : merge(\\n      { resources = {} },\\n      { for k, v in step : k => v if v != null },\\n    )] },\\n  )\\n}\\n```\\n\\n- KCL (using `-n` flag)\\n\\n```python\\nschema Param:\\n    default?: str\\n    name: str\\n\\nschema Resource:\\n    cpu: str\\n    memory: str\\n\\nschema Step:\\n    args?: [str]\\n    command?: [str]\\n    env?: {str:str}\\n    image: str\\n    name: str\\n    resources?: {\\"limits\\" | \\"requests\\": Resource}\\n    script?: str\\n    workingDir: str\\n\\nschema K8sManifest:\\n    name: str\\n    namespace: str\\n    params: [Param]\\n    results?: [str]\\n    steps: [Step]\\n\\nconf: K8sManifest = option(\\"conf\\")\\n```\\n\\nTo sum up, in KCL, its types and constraints are defined in a declarative way through schema. It can be seen that compared with Terraform HCL, KCL constraints can be written more simply when the same functions are implemented (validation and condition fields do not need to be written repeatedly like Terraform), In addition, it provides the ability to set fields as optional (unlike the Terraform configuration field, which can be null by default).\\n\\n### 3.4 vs. CUE\\n\\n#### 3.4.1 Features\\n\\n|              | CUE                                                                                                                                                                                                                                                                          | KCL                                                                                                                                                                                                                                                                                                                                                 |\\n| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\n| Modeling     | Modeling through struct, no inheritance and other features, can achieve high abstraction when there is no conflict between model definitions. Because CUE performs all constraint checks at runtime, there may be performance bottlenecks in large-scale modeling scenarios. | Modeling is conducted through KCL schema, and high model abstraction can be achieved through language level engineering and some object-oriented features (such as single inheritance). KCL is a statically compiled language with low overhead for large-scale modeling scenarios.                                                                 |\\n| Constraint   | CUE combines types and values into one concept. It simplifies the writing of constraints through various syntax. For example, generic types and enumerations are not required. Summing types and null value merging are the same thing.                                      | KCL provides a richer check declarative constraint syntax, which makes it easier to write. For some configuration field combination constraints, it is simpler to write (compared with CUE, KCL provides more if guard combination constraints, all/any/map/filter and other collection constraint writing methods, which makes it easier to write) |\\n| Scalability  | CUE supports configuration merging but it is completely idempotent. It may not meet the requirements of complex multi-tenant and multi- environment configuration scenarios                                                                                                  | KCL can customize the configuration block writing method and multiple strategies to meet the requirements of complex multi-tenant and multi-environment configuration scenarios.                                                                                                                                                                    |\\n| Code writing | For complex loop and constraint scenarios, it is complex to write, and it is cumbersome to write scenarios that require accurate configuration modifications.                                                                                                                | Complex structure definition, loop, and conditional constraint scenarios are easy to write.                                                                                                                                                                                                                                                         |\\n\\n#### 3.4.2 Examples\\n\\n**CUE constraint vs. KCL constraint**\\n\\nCUE (run `cue export base.cue prod.cue`)\\n\\n- base.cue\\n\\n```cue\\n// base.cue\\nimport \\"list\\"\\n\\n#App: {\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\",\\n    containerPort: >=1 & <=65535,\\n    volumes: [...#Volume],\\n    services: [...#Service],\\n}\\n\\n#Service: {\\n    clusterIP: string,\\n    type: string,\\n\\n    if type == \\"ClusterIP\\" {\\n        clusterIP: \\"None\\"\\n    }\\n}\\n\\n#Volume: {\\n    container: string | *\\"*\\"  // The default value of `container` is \\"*\\"\\n    mountPath: string,\\n    _check: false & list.Contains([\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"], mountPath),\\n}\\n\\napp: #App & {\\n    domainType: \\"Standard\\",\\n    containerPort: 80,\\n    volumes: [\\n        {\\n            mountPath: \\"/tmp\\"\\n        }\\n    ],\\n    services: [\\n        {\\n            clusterIP: \\"None\\",\\n            type: \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.cue\\n\\n```python\\n// prod.cue\\napp: #App & {\\n    containerPort: 8080,  // error: app.containerPort: conflicting values 8080 and 80:\\n}\\n```\\n\\nKCL (run `kcl base.k prod.k`)\\n\\n- base.k\\n\\n```python\\n# base.k\\nschema App:\\n    domainType: \\"Standard\\" | \\"Customized\\" | \\"Global\\"\\n    containerPort: int\\n    volumes: [Volume]\\n    services: [Service]\\n\\n    check:\\n        1 <= containerPort <= 65535\\n\\nschema Service:\\n    clusterIP: str\\n    $type: str\\n\\n    check:\\n        clusterIP == \\"None\\" if $type == \\"ClusterIP\\"\\n\\nschema Volume:\\n    container: str = \\"*\\"  # The default value of `container` is \\"*\\"\\n    mountPath: str\\n\\n    check:\\n        mountPath not in [\\"/\\", \\"/boot\\", \\"/home\\", \\"dev\\", \\"/etc\\", \\"/root\\"]\\n\\napp: App {\\n    domainType = \\"Standard\\"\\n    containerPort = 80\\n    volumes = [\\n        {\\n            mountPath = \\"/tmp\\"\\n        }\\n    ]\\n    services = [\\n        {\\n            clusterIP = \\"None\\"\\n            $type = \\"ClusterIP\\"\\n        }\\n    ]\\n}\\n\\n```\\n\\n- prod.k\\n\\n```python\\n# prod.k\\napp: App {\\n    # Using `=` attribute operator to modify the `containerPort` of the base `app`.\\n    containerPort = 8080\\n    # Using `+=` attribute operator to add volumes of the base `app`.\\n    # Here, it means to add one volume in the prod environment.\\n    volumes += [\\n        {\\n            mountPath = \\"/tmp2\\"\\n        }\\n    ]\\n}\\n```\\n\\nIn addition, due to the idempotent merge feature of CUE, it is not easy to use an overlay configuration similar to Kustomize to override the additional capability in scenarios, such as the above CUE code will report a conflict error.\\n\\n### 3.5 Performance\\n\\nKCL performs better than CUE/Jsonnet/HCL and other languages in scenarios with large code size or high computation load (CUE and other languages are limited by the runtime constraint checking overhead, while KCL is a statically compiled language).\\n\\n- CUE (test.cue)\\n\\n```cue\\nimport \\"list\\"\\n\\ntemp: {\\n        for i, _ in list.Range(0, 10000, 1) {\\n                \\"a\\\\(i)\\": list.Max([1, 2])\\n        }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\na = lambda x: int, y: int -> int {\\n    max([x, y])\\n}\\ntemp = {\\"a${i}\\": a(1, 2) for i in range(10000)}\\n```\\n\\n- Jsonnet (test.jsonnet)\\n\\n```jsonnet\\nlocal a(x, y) = std.max(x, y);\\n{\\n    temp: {[\\"a%d\\" % i]: a(1, 2) for i in std.range(0, 10000)},\\n}\\n```\\n\\n- Terraform HCL (test.tf. Since the terraform `range` function only supports up to 1024 iterators, the `range(10000)` is divided into 10 sub ranges)\\n\\n```python\\noutput \\"r1\\" {\\n  value = {for s in range(0, 1000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r2\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r3\\" {\\n  value = {for s in range(1000, 2000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r4\\" {\\n  value = {for s in range(2000, 3000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r5\\" {\\n  value = {for s in range(3000, 4000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r6\\" {\\n  value = {for s in range(5000, 6000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r7\\" {\\n  value = {for s in range(6000, 7000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r8\\" {\\n  value = {for s in range(7000, 8000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r9\\" {\\n  value = {for s in range(8000, 9000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\noutput \\"r10\\" {\\n  value = {for s in range(9000, 10000) : format(\\"a%d\\", s) => max(1, 2)}\\n}\\n```\\n\\n- Running time (considering the actual resource cost of the production environment, this test is subject to the single core).\\n\\n| Environment                                                                                            | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) | Jsonnet v0.18.0 Running time (including compilation+runtime) | HCL in Terraform v1.3.0 Running time (including compilation+runtime) |\\n| ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ | -------------------------------------------------------------------- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 440 ms (kcl test.k)                                     | 6290 ms (cue export test.cue)                           | 3340 ms (jsonnet test.jsonnet)                               | 1774 ms (terraform plan -parallelism=1)                              |\\n\\n#### Another Complex Case\\n\\nUsing KCL and CUE to write Kubernetes configuration.\\n\\n- CUE (test.cue)\\n\\n```cue\\npackage templates\\n\\nimport (\\n apps \\"k8s.io/api/apps/v1\\"\\n)\\n\\ndeployment: apps.#Deployment\\n\\ndeployment: {\\n apiVersion: \\"apps/v1\\"\\n kind:       \\"Deployment\\"\\n metadata: {\\n  name:   \\"me\\"\\n  labels: me: \\"me\\"\\n }\\n}\\n```\\n\\n- KCL (test.k)\\n\\n```python\\nimport kubernetes.api.apps.v1\\n\\ndeployment = v1.Deployment {\\n    metadata.name = \\"me\\"\\n    metadata.labels.name = \\"me\\"\\n}\\n```\\n\\n| Environment                                                                                            | KCL v0.4.3 Running time (including compilation+runtime) | CUE v0.4.3 Running time (including compilation+runtime) |\\n| ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------- | ------------------------------------------------------- |\\n| OS: macOS 10.15.7; CPU: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz; Memory: 32 GB 2400 MHz DDR4; no NUMA | 140 ms (kcl test.k)                                     | 350 ms (cue export test.cue)                            |\\n\\n## 4. Summary\\n\\nThe blog gives a landscape overview of declarative configuration technology, focusing on the KCL concept, core features, usage cases and comparison with other configuration languages, hoping to help you understand declarative configuration technology and KCL language. For more information about the concept, background and design of KCL, please visit the [KCL website](https://kcl-lang.io/)\\n\\n## 5. Reference\\n\\n- KusionStack Cloud Native Configuration Practice Blog: [https://kusionstack.io/blog/2021-kusion-intro](https://kusionstack.io/blog/2021-kusion-intro)\\n- Terraform Language: [https://www.terraform.io/language](https://www.terraform.io/language)\\n- Terraform Provider Kubernetes: [https://github.com/hashicorp/terraform-provider-kubernetes](https://github.com/hashicorp/terraform-provider-kubernetes)\\n- Terraform Provider AWS: [https://github.com/hashicorp/terraform-provider-aws](https://github.com/hashicorp/terraform-provider-aws)\\n- Pulumi: [https://www.pulumi.com/docs/](https://www.pulumi.com/docs/)\\n- Pulumi vs. Terraform: [https://www.pulumi.com/docs/intro/vs/terraform/](https://www.pulumi.com/docs/intro/vs/terraform/)\\n- Google SRE Work Book Configuration Design: [https://sre.google/workbook/configuration-design/](https://sre.google/workbook/configuration-design/)\\n- Google Borg Paper: [https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/43438.pdf)\\n- Holistic Configuration Management at Facebook: [https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf](https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/printable/008-tang.pdf)\\n- JSON Spec: [https://www.json.org/json-en.html](https://www.json.org/json-en.html)\\n- YAML Spec: [https://yaml.org/spec/](https://yaml.org/spec/)\\n- GCL: [https://github.com/rix0rrr/gcl](https://github.com/rix0rrr/gcl)\\n- HCL: [https://github.com/hashicorp/hcl](https://github.com/hashicorp/hcl)\\n- CUE: [https://github.com/cue-lang/cue](https://github.com/cue-lang/cue)\\n- Jsonnet: [https://github.com/google/jsonnet](https://github.com/google/jsonnet)\\n- Dhall: [https://github.com/dhall-lang/dhall-lang](https://github.com/dhall-lang/dhall-lang)\\n- Thrift: [https://github.com/Thriftpy/thriftpy2](https://github.com/Thriftpy/thriftpy2)\\n- Kustomize: [https://kustomize.io/](https://kustomize.io/)\\n- Kube-linter: [https://github.com/stackrox/kube-linter](https://github.com/stackrox/kube-linter)\\n- Checkov: [https://github.com/bridgecrewio/checkov](https://github.com/bridgecrewio/checkov)\\n- KCL Documents: [https://kcl-lang.io/docs/reference/lang/tour](https://kcl-lang.io/docs/reference/lang/tour)\\n- How Terraform Works: A Visual Intro: [https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067](https://betterprogramming.pub/how-terraform-works-a-visual-intro-6328cddbe067)\\n- How Terraform Works: Modules Illustrated: [https://awstip.com/terraform-modules-illustrate-26cbc48be83a](https://awstip.com/terraform-modules-illustrate-26cbc48be83a)\\n- Helm: [https://helm.sh/](https://helm.sh/)\\n- Helm vs. Kustomize: [https://harness.io/blog/helm-vs-kustomize](https://harness.io/blog/helm-vs-kustomize)\\n- KubeVela: [https://kubevela.io/docs/](https://kubevela.io/docs/)"},{"id":"2021-kcl-intro","metadata":{"permalink":"/blog/2021-kcl-intro","editUrl":"https://github.com/kcl-lang/kcl-lang.io/tree/main/blog/2021-08-03-kcl-giac-metting/index.md","source":"@site/blog/2021-08-03-kcl-giac-metting/index.md","title":"KCL Introduction on GIAC 2021 Meeting","description":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.","date":"2021-08-03T00:00:00.000Z","formattedDate":"August 3, 2021","tags":[{"label":"KCL","permalink":"/blog/tags/kcl"}],"readingTime":0.125,"hasTruncateMarker":false,"authors":[{"name":"Shushan, Chai","title":"KCL Team Member"}],"frontMatter":{"slug":"2021-kcl-intro","title":"KCL Introduction on GIAC 2021 Meeting","authors":{"name":"Shushan, Chai","title":"KCL Team Member"},"tags":["KCL"]},"prevItem":{"title":"The Landscape of Declarative Configuration","permalink":"/blog/2022-declarative-config-overview"}},"content":"This blog introduces the birth background, language characteristics, practical exploration and future development of KCL.\\n\\n- Introduction\uff1ahttps://giac.msup.com.cn/course?id=15307\\n- Content\uff1ahttps://segmentfault.com/a/1190000040455559\\n- [PDF (Chinese)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)\\n\\n[![KCL Talk Cover](/img/blog/2021-08-03-kcl-intro/talk-cover.png)](https://gw.alipayobjects.com/os/bmw-prod/2cb0c283-5f24-485e-b635-b6efac887eba.pdf)"}]}')}}]);