"use strict";(self.webpackChunkkcl_website=self.webpackChunkkcl_website||[]).push([[62487],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=s(n),c=i,k=d["".concat(p,".").concat(c)]||d[c]||u[c]||l;return n?a.createElement(k,r(r({ref:t},m),{},{components:n})):a.createElement(k,r({ref:t},m))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var s=2;s<l;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},76511:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(87462),i=(n(67294),n(3905));const l={title:"Modules",linkTitle:"Modules",type:"docs",weight:2,description:"Modules"},r=void 0,o={unversionedId:"reference/lang/spec/modules",id:"reference/lang/spec/modules",title:"Modules",description:"Modules",source:"@site/docs/reference/lang/spec/modules.md",sourceDirName:"reference/lang/spec",slug:"/reference/lang/spec/modules",permalink:"/docs/next/reference/lang/spec/modules",draft:!1,editUrl:"https://github.com/kcl-lang/kcl-lang.io/tree/main/docs/reference/lang/spec/modules.md",tags:[],version:"current",lastUpdatedBy:"Peefy",lastUpdatedAt:1715583130,formattedLastUpdatedAt:"May 13, 2024",frontMatter:{title:"Modules",linkTitle:"Modules",type:"docs",weight:2,description:"Modules"},sidebar:"reference",previous:{title:"Lexical",permalink:"/docs/next/reference/lang/spec/lexical"},next:{title:"Schema",permalink:"/docs/next/reference/lang/spec/schema"}},p={},s=[{value:"Modules and the Import System",id:"modules-and-the-import-system",level:2},{value:"Packages",id:"packages",level:2},{value:"Intra-Package Name Space Sharing",id:"intra-package-name-space-sharing",level:3},{value:"Package Initialization",id:"package-initialization",level:3},{value:"Searching",id:"searching",level:2},{value:"Module Cache",id:"module-cache",level:3},{value:"Module Names",id:"module-names",level:3},{value:"Uniqueness of Module",id:"uniqueness-of-module",level:3},{value:"Standard System Packages",id:"standard-system-packages",level:2},{value:"The Built-in System Package",id:"the-built-in-system-package",level:3},{value:"Plugin Modules",id:"plugin-modules",level:3},{value:"Replacing Standard System Packages",id:"replacing-standard-system-packages",level:3},{value:"Examples",id:"examples",level:2},{value:"Importing a Standard System Package",id:"importing-a-standard-system-package",level:3},{value:"Importing a Regular Module",id:"importing-a-regular-module",level:3},{value:"Importing a Package",id:"importing-a-package",level:3},{value:"Importing a Subpackage",id:"importing-a-subpackage",level:3},{value:"Relative Importing",id:"relative-importing",level:3},{value:"Importing from a Root Path",id:"importing-from-a-root-path",level:3},{value:"Importing a Module Inside a Package",id:"importing-a-module-inside-a-package",level:3},{value:"Precedence of Importing",id:"precedence-of-importing",level:3},{value:"Package Implemented with Multiple Files",id:"package-implemented-with-multiple-files",level:3}],m={toc:s},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"modules-and-the-import-system"},"Modules and the Import System"),(0,i.kt)("p",null,"KCL code is organized in ",(0,i.kt)("strong",{parentName:"p"},"modules"),". For code in one module to access the code defined in another module, a process called ",(0,i.kt)("strong",{parentName:"p"},"importing")," must be used."),(0,i.kt)("p",null,"Importing is undertaken at compile-time in KCL. The advantage is to have static checking enabled."),(0,i.kt)("p",null,"A regular KCL module is a file on the file system. It is required to have a ",(0,i.kt)("inlineCode",{parentName:"p"},".k")," suffix."),(0,i.kt)("h2",{id:"packages"},"Packages"),(0,i.kt)("p",null,"To help manage modules and provide a naming hierarchy, KCL has the concept of packages. In KCL, a package maps to exactly a file system directory, and a regular module maps to a file."),(0,i.kt)("p",null,"Files directly under a package are considered parts of the package, instead of individual regular modules."),(0,i.kt)("p",null,"Packages can have sub-packages."),(0,i.kt)("p",null,"Packages are special modules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"All packages in KCL are modules."),(0,i.kt)("li",{parentName:"ul"},"A single-file module can never be a package.")),(0,i.kt)("p",null,"All modules have a name."),(0,i.kt)("p",null,"Sub package names are separated from their parent package name by dots."),(0,i.kt)("p",null,"To summary, a regular KCL module is a ",(0,i.kt)("inlineCode",{parentName:"p"},".k")," file, and a package is a directory on the file system. All ",(0,i.kt)("inlineCode",{parentName:"p"},".k")," files directly under the directory are included in the package, other files are ignored. If the directory has subdirectories, they become sub-packages as long as there are ",(0,i.kt)("inlineCode",{parentName:"p"},".k")," files underneath."),(0,i.kt)("h3",{id:"intra-package-name-space-sharing"},"Intra-Package Name Space Sharing"),(0,i.kt)("p",null,"Inside a package, all ",(0,i.kt)("inlineCode",{parentName:"p"},".k")," files are considered parts of the package, instead of regular modules. Code in these files share a single name space and can access names defined in other files, without explicitly granted."),(0,i.kt)("h3",{id:"package-initialization"},"Package Initialization"),(0,i.kt)("p",null,"A package can have the initialization code. The code must exist in only one of the ",(0,i.kt)("inlineCode",{parentName:"p"},".k")," files under this package. The interpreter guarantees that the initialization code is executed after all definitions."),(0,i.kt)("h2",{id:"searching"},"Searching"),(0,i.kt)("p",null,"The searching begins when an ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," statement is used to import a module."),(0,i.kt)("h3",{id:"module-cache"},"Module Cache"),(0,i.kt)("p",null,"In KCL, only standard system modules are cached. When a cached module is imported, the cached version is used. In other words, KCL runtime would not create another copy of the standard system module in memory."),(0,i.kt)("p",null,"However, other modules are uncached. Importing a module multiple time would create multiple instances of the module."),(0,i.kt)("h3",{id:"module-names"},"Module Names"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," statement specifies the name of the module to import. The syntax is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"import <module_name> [as <alias name>]\n")),(0,i.kt)("p",null,"The rule to search with the module name is very simple:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Step 1"),": Searches the module name from the ",(0,i.kt)("strong",{parentName:"li"},"standard system modules"),", then ",(0,i.kt)("strong",{parentName:"li"},"plugins modules"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"See ",(0,i.kt)("strong",{parentName:"li"},"standard system modules")," and ",(0,i.kt)("strong",{parentName:"li"},"plugins modules")," for more details. If matched, the module is imported. Otherwise, continue to ",(0,i.kt)("strong",{parentName:"li"},"Step 2"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Step 2"),". Whether a module name starts with a ",(0,i.kt)("inlineCode",{parentName:"li"},".")," is checked. If yes, the name is a so-called relative pathname, and we go to ",(0,i.kt)("strong",{parentName:"li"},"Step 5"),". Otherwise, continue to ",(0,i.kt)("strong",{parentName:"li"},"Step 3"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Step 3"),": If the module name does not start with any ",(0,i.kt)("inlineCode",{parentName:"li"},"."),", then the compiler searches the nearest ",(0,i.kt)("inlineCode",{parentName:"li"},"root path")," directory from this directory to the parent, and find the module according to the name just from the ",(0,i.kt)("inlineCode",{parentName:"li"},"root path"),". If no ",(0,i.kt)("inlineCode",{parentName:"li"},"root path")," is found, find the module according to the name from the folder the ",(0,i.kt)("inlineCode",{parentName:"li"},".k")," file including this ",(0,i.kt)("inlineCode",{parentName:"li"},"import")," statement exists.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"root path"),": the directory contains a ",(0,i.kt)("inlineCode",{parentName:"li"},"kcl.mod")," file. If matched, the module is imported. Otherwise, continue to ",(0,i.kt)("strong",{parentName:"li"},"Step 4"),"."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Step 4"),": Then the compiler checks if the name is the name of any library module that requires explicit loading. If matched, the library module is imported. Otherwise, continue to ",(0,i.kt)("strong",{parentName:"li"},"Step 6"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Step 5"),". For relative importing, find the module according to the name from the folder the ",(0,i.kt)("inlineCode",{parentName:"li"},".k")," file including this ",(0,i.kt)("inlineCode",{parentName:"li"},"import")," statement exists. Interpret leading dots using the following rule:"),(0,i.kt)("li",{parentName:"ul"},"One dot: Ignore."),(0,i.kt)("li",{parentName:"ul"},"Tow or more dots: Suppose there are ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," leading dots, then the searching starts at ",(0,i.kt)("inlineCode",{parentName:"li"},"n - 1")," levels above this folder. If matched, the module is imported. Otherwise, continue to ",(0,i.kt)("strong",{parentName:"li"},"Step 6"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Step 6"),". Module not found, report an error.")),(0,i.kt)("p",null,"Do case-sensitive search when the operating system allows. If case-sensitive search is not allowed, search directories before regular files."),(0,i.kt)("p",null,"In KCL, the ",(0,i.kt)("inlineCode",{parentName:"p"},"from <> import <>")," is unsupported, and relative import is performed with the ",(0,i.kt)("inlineCode",{parentName:"p"},"import <>")," syntax."),(0,i.kt)("h3",{id:"uniqueness-of-module"},"Uniqueness of Module"),(0,i.kt)("p",null,"Each module has a unique location path in its scope, so that a module or package could be located with a unique location path, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"a.b.c"),"."),(0,i.kt)("p",null,"Searching by location path should be supported by the kcl compiler, which needs to provide corresponding searching features through the command line and api form."),(0,i.kt)("h2",{id:"standard-system-packages"},"Standard System Packages"),(0,i.kt)("p",null,"KCL supports a few standard system modules. ",(0,i.kt)("a",{parentName:"p",href:"docs/reference/model/overview"},"Here")," is the full list of these standard system modules."),(0,i.kt)("h3",{id:"the-built-in-system-package"},"The Built-in System Package"),(0,i.kt)("p",null,"KCL provides a list of built-in system modules, which are loaded automatically and can be directly used without providing any module name. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"print")," is a widely used built-in module."),(0,i.kt)("p",null,"The following is the full list of these built-in system modules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"print()",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The print function."))),(0,i.kt)("li",{parentName:"ul"},"multiplyof(a, b)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Check if the modular result of a and b is 0"))),(0,i.kt)("li",{parentName:"ul"},"isunique(inval)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Check if a list has duplicated elements"))),(0,i.kt)("li",{parentName:"ul"},"len(inval)\nReturn the length of a value"),(0,i.kt)("li",{parentName:"ul"},"abs(x)\nReturn the absolute value of the argument."),(0,i.kt)("li",{parentName:"ul"},"all(iterable)\nReturn True if bool(x) is True for all values x in the iterable. If the iterable is empty, return True."),(0,i.kt)("li",{parentName:"ul"},"any(iterable)\nReturn True if bool(x) is True for any x in the iterable. If the iterable is empty, return False."),(0,i.kt)("li",{parentName:"ul"},"bin(number)\nReturn the binary representation of an integer."),(0,i.kt)("li",{parentName:"ul"},"hex(number)\nReturn the hexadecimal representation of an integer."),(0,i.kt)("li",{parentName:"ul"},"oct(number)\nReturn the octal representation of an integer."),(0,i.kt)("li",{parentName:"ul"},"ord(c) -> int\nReturn the Unicode code point for a one-character string."),(0,i.kt)("li",{parentName:"ul"},"sorted(iterable)\nReturn a new list containing all items from the iterable in ascending order. A custom key function can be supplied to customize the sort order, and the reverse flag can be set to request the result in descending order."),(0,i.kt)("li",{parentName:"ul"},"range(start, end, step=1)\nReturn the range of a value with start, end and step parameter."),(0,i.kt)("li",{parentName:"ul"},"min(iterable)\nWith a single iterable argument, return its smallest item. The default keyword-only argument specifies an object to return if the provided iterable is empty. With two or more arguments, return the smallest argument."),(0,i.kt)("li",{parentName:"ul"},"max(iterable)\nWith a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if the provided iterable is empty. With two or more arguments, return the largest argument."),(0,i.kt)("li",{parentName:"ul"},"sum(iterable, start)\nReturn the sum of a 'start' value (default: 0) plus an iterable of numbers. When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types."),(0,i.kt)("li",{parentName:"ul"},"pow(x, y, z)\nEquivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"x**y")," (with two arguments) or ",(0,i.kt)("inlineCode",{parentName:"li"},"x**y % z")," (with three arguments). Some types, such as ints, are able to use a more efficient algorithm when invoked using the three argument form."),(0,i.kt)("li",{parentName:"ul"},"round(number, ndigits)\nRound a number to a given precision in decimal digits. The return value is an integer if ndigits is omitted or None. Otherwise the return value has the same type as the number. ndigits may be negative."),(0,i.kt)("li",{parentName:"ul"},"typeof(x: any, ","*",", full_name: bool = False) -> str\nReturn the type of the value 'x' at runtime. When the 'full_name' is 'True', return the full package type name such as ",(0,i.kt)("inlineCode",{parentName:"li"},"pkg.schema"),".")),(0,i.kt)("h3",{id:"plugin-modules"},"Plugin Modules"),(0,i.kt)("p",null,"KCL compiler needs to provide the ability to dynamically expand and load plugin modules without modifying the compiler itself. KCL compiler needs to support flexible pluggable module extension mechanism, so that KCL users can use more abundant built-in function capabilities to simplify writing."),(0,i.kt)("p",null,"KCL compiler needs to ensure the stability and safety of the expansion mechanism, without affecting the core of the compiler."),(0,i.kt)("p",null,"Searching extended plugin module is performed after the standard system module. The standard system module has a higher priority in naming. If it exists a standard or built-in system module with the same name, the extended plugin module will be ignored."),(0,i.kt)("p",null,"Importing and using the extended plugin module should be consistent with the standard or built-in system module."),(0,i.kt)("h3",{id:"replacing-standard-system-packages"},"Replacing Standard System Packages"),(0,i.kt)("p",null,"Replacing standard system modules is not allowed."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("p",null,"We show more module features through an example."),(0,i.kt)("p",null,"Suppose we have the following directories and files:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    .\n    \u251c\u2500\u2500 mod1.k\n    \u251c\u2500\u2500 mod2.k\n    \u251c\u2500\u2500 pkg1\n    \u2502\xa0\xa0 \u251c\u2500\u2500 def1.k\n    \u2502\xa0\xa0 \u251c\u2500\u2500 def2.k\n    \u2502\xa0\xa0 \u2514\u2500\u2500 def3init.k\n    \u2514\u2500\u2500 pkg2\n        \u251c\u2500\u2500 file2.k\n        \u2514\u2500\u2500 subpkg3\n            \u2514\u2500\u2500 file3.k\n")),(0,i.kt)("p",null,"From the structure we can see that ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2")," are two packages, ",(0,i.kt)("inlineCode",{parentName:"p"},"subpkg3")," is a subpackage of ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mod2.k")," are regular modules."),(0,i.kt)("h3",{id:"importing-a-standard-system-package"},"Importing a Standard System Package"),(0,i.kt)("p",null,"The following statement can import the standard system module ",(0,i.kt)("inlineCode",{parentName:"p"},"math")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import math\n")),(0,i.kt)("p",null,"This is the only way to import a standard system module. After importing a standard system module, functions, variables and schemas defined in it can be used. For example, the following statement uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"log10")," function\ndefined in ",(0,i.kt)("inlineCode",{parentName:"p"},"math")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = math.log10(100) # a is 2 after computation.\n")),(0,i.kt)("h3",{id:"importing-a-regular-module"},"Importing a Regular Module"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k"),", we can import ",(0,i.kt)("inlineCode",{parentName:"p"},"mod2")," using one of the following syntaxes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import mod2\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import .mod2\n")),(0,i.kt)("p",null,"The difference is that in the first syntax, the KCL compiler will first try to check if ",(0,i.kt)("inlineCode",{parentName:"p"},"mod2")," matches any of the standard system modules' name. Since it does not match any standard system module's name, the statement will check the directory where ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k")," resists in, like what the second statement does."),(0,i.kt)("p",null,"Suppose in ",(0,i.kt)("inlineCode",{parentName:"p"},"mod2.k")," there is a definition of a variable::"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"a = 100\n")),(0,i.kt)("p",null,"After importing ",(0,i.kt)("inlineCode",{parentName:"p"},"mod2"),", we can access ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k")," using the following syntax"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"b = mod2.a\n")),(0,i.kt)("h3",{id:"importing-a-package"},"Importing a Package"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k"),", we can import ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg1")," using one of the following syntaxes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import pkg1\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import .pkg1\n")),(0,i.kt)("p",null,"The difference is that in the first syntax, the KCL compiler will first try to check if ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg1")," matches any of the standard system modules' name. Since it does not match any standard system module's name, the statement will check the directory where ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k")," resists in, like what the second statement does."),(0,i.kt)("p",null,"We can use similar statements to import ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2"),". Note that importing ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2")," will not import ",(0,i.kt)("inlineCode",{parentName:"p"},"subpkg3"),"."),(0,i.kt)("p",null,"The name of the package is the name of the imported module."),(0,i.kt)("p",null,"Suppose in ",(0,i.kt)("inlineCode",{parentName:"p"},"file2.k")," that is inside ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2")," there is a definition to variable ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"foo = 100\n")),(0,i.kt)("p",null,"This variable can be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k")," after importing ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2")," like the following"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"bar = pkg2.foo\n")),(0,i.kt)("h3",{id:"importing-a-subpackage"},"Importing a Subpackage"),(0,i.kt)("p",null,"To import ",(0,i.kt)("inlineCode",{parentName:"p"},"subpkg3")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k"),", one of the following statements can be used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import pkg2.subpkg3\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import .pkg2.subpkg3\n")),(0,i.kt)("p",null,"The behaviors of these statements are identical."),(0,i.kt)("p",null,"The name of the subpackage is the name of the imported module."),(0,i.kt)("p",null,"Suppose in ",(0,i.kt)("inlineCode",{parentName:"p"},"file3.k")," that is inside ",(0,i.kt)("inlineCode",{parentName:"p"},"subpkg3")," there is a definition to variable ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"foo = 100\n")),(0,i.kt)("p",null,"This variable can be used in ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k")," after importing ",(0,i.kt)("inlineCode",{parentName:"p"},"subpkg3")," like the following"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"bar = subpkg3.foo\n")),(0,i.kt)("h3",{id:"relative-importing"},"Relative Importing"),(0,i.kt)("p",null,"Relative importing is useful when there is code trying to import modules that does not exist recursively inside the current directory."),(0,i.kt)("p",null,"For example, the following statements, if written in ",(0,i.kt)("inlineCode",{parentName:"p"},"file3.k"),", can be used to import ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"mod2")," respectively."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import ...pkg2 # Go two levels up then import pkg2\nimport ...pkg1 # Go two levels up then import pkg1\nimport ...mod2 # Go two levels up then import mod2\n")),(0,i.kt)("h3",{id:"importing-from-a-root-path"},"Importing from a Root Path"),(0,i.kt)("p",null,"Suppose we have a ",(0,i.kt)("inlineCode",{parentName:"p"},"kcl.mod")," file in the directory to mark it as a root path, then we have the following files:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    .\n    |\u2500\u2500 kcl.mod\n    \u251c\u2500\u2500 mod1.k\n    \u251c\u2500\u2500 mod2.k\n    \u251c\u2500\u2500 pkg1\n    \u2502\xa0\xa0 \u251c\u2500\u2500 def1.k\n    \u2502\xa0\xa0 \u251c\u2500\u2500 def2.k\n    \u2502\xa0\xa0 \u2514\u2500\u2500 def3init.k\n    \u2514\u2500\u2500 pkg2\n        \u251c\u2500\u2500 file2.k\n        \u2514\u2500\u2500 subpkg3\n            \u2514\u2500\u2500 file3.k\n")),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg1")," ",(0,i.kt)("inlineCode",{parentName:"p"},"def1.k"),", we can import ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg2.subpkg3")," ",(0,i.kt)("inlineCode",{parentName:"p"},"file3")," using the following syntaxes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import pkg2.subpkg3.file3\n")),(0,i.kt)("p",null,"Importing from the root path is very convenient when the code is trying to import modules from a directory needs to look up multiple directories above this directory. At also, it is helpful to organize a large number of files in a root directory."),(0,i.kt)("h3",{id:"importing-a-module-inside-a-package"},"Importing a Module Inside a Package"),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"subpkg3")," is only implemented with one file ",(0,i.kt)("inlineCode",{parentName:"p"},"file3.k"),". The file can be regarded as a regular module and imported directly."),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k"),", the importing statement would be::"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import pkg2.subpkg3.file3\n")),(0,i.kt)("p",null,"Different from importing ",(0,i.kt)("inlineCode",{parentName:"p"},"subpkg3"),", now the name of the module is ",(0,i.kt)("inlineCode",{parentName:"p"},"file3"),". We can access the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," defined in this module with the following\nstatement"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"bar = file3.foo\n")),(0,i.kt)("h3",{id:"precedence-of-importing"},"Precedence of Importing"),(0,i.kt)("p",null,"When an import statement specifies a package to import, the virtual machine first looks for a directory named according to the import statement in the file system."),(0,i.kt)("p",null,"If such a directory is not found, the virtual machine looks for a single file module."),(0,i.kt)("p",null,"For example, when the statement ",(0,i.kt)("inlineCode",{parentName:"p"},"import a.b.c")," appears, the virtual machine first looks for the directory ",(0,i.kt)("inlineCode",{parentName:"p"},"a/b/c")," from the directory of the current file. If ",(0,i.kt)("inlineCode",{parentName:"p"},"a/b/c")," is not found, the virtual machine looks for a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"a/b/c.k"),". If the file is also absent, an error is reported."),(0,i.kt)("h3",{id:"package-implemented-with-multiple-files"},"Package Implemented with Multiple Files"),(0,i.kt)("p",null,"Package ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg1")," is implemented with multiple KCL files."),(0,i.kt)("p",null,"Multiple files can be used to define variables, schemas and functions, and they can access names defined in other files of this package."),(0,i.kt)("p",null,"For example, suppose ",(0,i.kt)("inlineCode",{parentName:"p"},"def1.k")," defines a variable ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"def2.k")," defines ",(0,i.kt)("inlineCode",{parentName:"p"},"bar"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"def3init.k")," defines a variable ",(0,i.kt)("inlineCode",{parentName:"p"},"baz"),", when ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg1")," is imported by ",(0,i.kt)("inlineCode",{parentName:"p"},"mod1.k"),", all these variable can be used"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"import pkg1\na = pkg1.foo + pkg1.bar + pkg1.baz\n")),(0,i.kt)("p",null,"Inside a module, names defined in a file can be accessed in another file without further importing. For example, suppose ",(0,i.kt)("inlineCode",{parentName:"p"},"bar")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"def2.k")," would invoke ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"def1.k"),", it can directly use ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," like the following"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"bar = foo + 1\n")))}u.isMDXComponent=!0}}]);